
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * 
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model VerificationToken
 * 
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model Company
 * 
 */
export type Company = $Result.DefaultSelection<Prisma.$CompanyPayload>
/**
 * Model CompanyUser
 * 
 */
export type CompanyUser = $Result.DefaultSelection<Prisma.$CompanyUserPayload>
/**
 * Model Vehicle
 * 
 */
export type Vehicle = $Result.DefaultSelection<Prisma.$VehiclePayload>
/**
 * Model Driver
 * 
 */
export type Driver = $Result.DefaultSelection<Prisma.$DriverPayload>
/**
 * Model Tariff
 * 
 */
export type Tariff = $Result.DefaultSelection<Prisma.$TariffPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model TripLog
 * 
 */
export type TripLog = $Result.DefaultSelection<Prisma.$TripLogPayload>
/**
 * Model GovernmentApiRequest
 * 
 */
export type GovernmentApiRequest = $Result.DefaultSelection<Prisma.$GovernmentApiRequestPayload>
/**
 * Model LocationUpdate
 * 
 */
export type LocationUpdate = $Result.DefaultSelection<Prisma.$LocationUpdatePayload>
/**
 * Model Subscription
 * 
 */
export type Subscription = $Result.DefaultSelection<Prisma.$SubscriptionPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  ADMIN: 'ADMIN',
  COMPANY_ADMIN: 'COMPANY_ADMIN',
  DRIVER: 'DRIVER',
  RIDER: 'RIDER'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const SubscriptionType: {
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM',
  ENTERPRISE: 'ENTERPRISE'
};

export type SubscriptionType = (typeof SubscriptionType)[keyof typeof SubscriptionType]


export const CompanyStatus: {
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  INACTIVE: 'INACTIVE'
};

export type CompanyStatus = (typeof CompanyStatus)[keyof typeof CompanyStatus]


export const VehicleStatus: {
  ACTIVE: 'ACTIVE',
  MAINTENANCE: 'MAINTENANCE',
  INACTIVE: 'INACTIVE'
};

export type VehicleStatus = (typeof VehicleStatus)[keyof typeof VehicleStatus]


export const DriverStatus: {
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE',
  SUSPENDED: 'SUSPENDED'
};

export type DriverStatus = (typeof DriverStatus)[keyof typeof DriverStatus]


export const TariffType: {
  METER_BASED: 'METER_BASED',
  FIXED_BASED: 'FIXED_BASED'
};

export type TariffType = (typeof TariffType)[keyof typeof TariffType]


export const BookingStatus: {
  PENDING: 'PENDING',
  ACCEPTED: 'ACCEPTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  NO_SHOW: 'NO_SHOW'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const LogType: {
  TRIP_START: 'TRIP_START',
  TRIP_END: 'TRIP_END',
  METER_ON: 'METER_ON',
  METER_OFF: 'METER_OFF',
  DRIVER_LOGIN: 'DRIVER_LOGIN',
  DRIVER_LOGOUT: 'DRIVER_LOGOUT',
  TARIFF_CHANGE: 'TARIFF_CHANGE',
  SYSTEM_EVENT: 'SYSTEM_EVENT',
  ERROR_LOG: 'ERROR_LOG'
};

export type LogType = (typeof LogType)[keyof typeof LogType]


export const ApiRequestType: {
  TRIP_START: 'TRIP_START',
  TRIP_END: 'TRIP_END',
  DRIVER_REGISTRATION: 'DRIVER_REGISTRATION',
  VEHICLE_REGISTRATION: 'VEHICLE_REGISTRATION'
};

export type ApiRequestType = (typeof ApiRequestType)[keyof typeof ApiRequestType]


export const SubscriptionStatus: {
  ACTIVE: 'ACTIVE',
  CANCELLED: 'CANCELLED',
  EXPIRED: 'EXPIRED',
  SUSPENDED: 'SUSPENDED'
};

export type SubscriptionStatus = (typeof SubscriptionStatus)[keyof typeof SubscriptionStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type SubscriptionType = $Enums.SubscriptionType

export const SubscriptionType: typeof $Enums.SubscriptionType

export type CompanyStatus = $Enums.CompanyStatus

export const CompanyStatus: typeof $Enums.CompanyStatus

export type VehicleStatus = $Enums.VehicleStatus

export const VehicleStatus: typeof $Enums.VehicleStatus

export type DriverStatus = $Enums.DriverStatus

export const DriverStatus: typeof $Enums.DriverStatus

export type TariffType = $Enums.TariffType

export const TariffType: typeof $Enums.TariffType

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type LogType = $Enums.LogType

export const LogType: typeof $Enums.LogType

export type ApiRequestType = $Enums.ApiRequestType

export const ApiRequestType: typeof $Enums.ApiRequestType

export type SubscriptionStatus = $Enums.SubscriptionStatus

export const SubscriptionStatus: typeof $Enums.SubscriptionStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company`: Exposes CRUD operations for the **Company** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.company.findMany()
    * ```
    */
  get company(): Prisma.CompanyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companyUser`: Exposes CRUD operations for the **CompanyUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CompanyUsers
    * const companyUsers = await prisma.companyUser.findMany()
    * ```
    */
  get companyUser(): Prisma.CompanyUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **Vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.VehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.driver`: Exposes CRUD operations for the **Driver** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drivers
    * const drivers = await prisma.driver.findMany()
    * ```
    */
  get driver(): Prisma.DriverDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tariff`: Exposes CRUD operations for the **Tariff** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tariffs
    * const tariffs = await prisma.tariff.findMany()
    * ```
    */
  get tariff(): Prisma.TariffDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tripLog`: Exposes CRUD operations for the **TripLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TripLogs
    * const tripLogs = await prisma.tripLog.findMany()
    * ```
    */
  get tripLog(): Prisma.TripLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.governmentApiRequest`: Exposes CRUD operations for the **GovernmentApiRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GovernmentApiRequests
    * const governmentApiRequests = await prisma.governmentApiRequest.findMany()
    * ```
    */
  get governmentApiRequest(): Prisma.GovernmentApiRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.locationUpdate`: Exposes CRUD operations for the **LocationUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LocationUpdates
    * const locationUpdates = await prisma.locationUpdate.findMany()
    * ```
    */
  get locationUpdate(): Prisma.LocationUpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscription`: Exposes CRUD operations for the **Subscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscription.findMany()
    * ```
    */
  get subscription(): Prisma.SubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.10.1
   * Query Engine version: 9b628578b3b7cae625e8c927178f15a170e74a9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    Session: 'Session',
    User: 'User',
    VerificationToken: 'VerificationToken',
    Company: 'Company',
    CompanyUser: 'CompanyUser',
    Vehicle: 'Vehicle',
    Driver: 'Driver',
    Tariff: 'Tariff',
    Booking: 'Booking',
    TripLog: 'TripLog',
    GovernmentApiRequest: 'GovernmentApiRequest',
    LocationUpdate: 'LocationUpdate',
    Subscription: 'Subscription',
    Payment: 'Payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "session" | "user" | "verificationToken" | "company" | "companyUser" | "vehicle" | "driver" | "tariff" | "booking" | "tripLog" | "governmentApiRequest" | "locationUpdate" | "subscription" | "payment"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      Company: {
        payload: Prisma.$CompanyPayload<ExtArgs>
        fields: Prisma.CompanyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findFirst: {
            args: Prisma.CompanyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          findMany: {
            args: Prisma.CompanyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          create: {
            args: Prisma.CompanyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          createMany: {
            args: Prisma.CompanyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          delete: {
            args: Prisma.CompanyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          update: {
            args: Prisma.CompanyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          deleteMany: {
            args: Prisma.CompanyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyPayload>
          }
          aggregate: {
            args: Prisma.CompanyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany>
          }
          groupBy: {
            args: Prisma.CompanyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyCountAggregateOutputType> | number
          }
        }
      }
      CompanyUser: {
        payload: Prisma.$CompanyUserPayload<ExtArgs>
        fields: Prisma.CompanyUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CompanyUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CompanyUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findFirst: {
            args: Prisma.CompanyUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CompanyUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          findMany: {
            args: Prisma.CompanyUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          create: {
            args: Prisma.CompanyUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          createMany: {
            args: Prisma.CompanyUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CompanyUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          delete: {
            args: Prisma.CompanyUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          update: {
            args: Prisma.CompanyUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          deleteMany: {
            args: Prisma.CompanyUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CompanyUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CompanyUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>[]
          }
          upsert: {
            args: Prisma.CompanyUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CompanyUserPayload>
          }
          aggregate: {
            args: Prisma.CompanyUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanyUser>
          }
          groupBy: {
            args: Prisma.CompanyUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompanyUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.CompanyUserCountArgs<ExtArgs>
            result: $Utils.Optional<CompanyUserCountAggregateOutputType> | number
          }
        }
      }
      Vehicle: {
        payload: Prisma.$VehiclePayload<ExtArgs>
        fields: Prisma.VehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findFirst: {
            args: Prisma.VehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          findMany: {
            args: Prisma.VehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          create: {
            args: Prisma.VehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          createMany: {
            args: Prisma.VehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VehicleCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          delete: {
            args: Prisma.VehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          update: {
            args: Prisma.VehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          deleteMany: {
            args: Prisma.VehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VehicleUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>[]
          }
          upsert: {
            args: Prisma.VehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.VehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          count: {
            args: Prisma.VehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      Driver: {
        payload: Prisma.$DriverPayload<ExtArgs>
        fields: Prisma.DriverFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DriverFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DriverFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findFirst: {
            args: Prisma.DriverFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DriverFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          findMany: {
            args: Prisma.DriverFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          create: {
            args: Prisma.DriverCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          createMany: {
            args: Prisma.DriverCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DriverCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          delete: {
            args: Prisma.DriverDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          update: {
            args: Prisma.DriverUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          deleteMany: {
            args: Prisma.DriverDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DriverUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DriverUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>[]
          }
          upsert: {
            args: Prisma.DriverUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DriverPayload>
          }
          aggregate: {
            args: Prisma.DriverAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDriver>
          }
          groupBy: {
            args: Prisma.DriverGroupByArgs<ExtArgs>
            result: $Utils.Optional<DriverGroupByOutputType>[]
          }
          count: {
            args: Prisma.DriverCountArgs<ExtArgs>
            result: $Utils.Optional<DriverCountAggregateOutputType> | number
          }
        }
      }
      Tariff: {
        payload: Prisma.$TariffPayload<ExtArgs>
        fields: Prisma.TariffFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TariffFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TariffFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>
          }
          findFirst: {
            args: Prisma.TariffFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TariffFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>
          }
          findMany: {
            args: Prisma.TariffFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>[]
          }
          create: {
            args: Prisma.TariffCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>
          }
          createMany: {
            args: Prisma.TariffCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TariffCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>[]
          }
          delete: {
            args: Prisma.TariffDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>
          }
          update: {
            args: Prisma.TariffUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>
          }
          deleteMany: {
            args: Prisma.TariffDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TariffUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TariffUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>[]
          }
          upsert: {
            args: Prisma.TariffUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TariffPayload>
          }
          aggregate: {
            args: Prisma.TariffAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTariff>
          }
          groupBy: {
            args: Prisma.TariffGroupByArgs<ExtArgs>
            result: $Utils.Optional<TariffGroupByOutputType>[]
          }
          count: {
            args: Prisma.TariffCountArgs<ExtArgs>
            result: $Utils.Optional<TariffCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      TripLog: {
        payload: Prisma.$TripLogPayload<ExtArgs>
        fields: Prisma.TripLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TripLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TripLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>
          }
          findFirst: {
            args: Prisma.TripLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TripLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>
          }
          findMany: {
            args: Prisma.TripLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>[]
          }
          create: {
            args: Prisma.TripLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>
          }
          createMany: {
            args: Prisma.TripLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TripLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>[]
          }
          delete: {
            args: Prisma.TripLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>
          }
          update: {
            args: Prisma.TripLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>
          }
          deleteMany: {
            args: Prisma.TripLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TripLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TripLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>[]
          }
          upsert: {
            args: Prisma.TripLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TripLogPayload>
          }
          aggregate: {
            args: Prisma.TripLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTripLog>
          }
          groupBy: {
            args: Prisma.TripLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<TripLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.TripLogCountArgs<ExtArgs>
            result: $Utils.Optional<TripLogCountAggregateOutputType> | number
          }
        }
      }
      GovernmentApiRequest: {
        payload: Prisma.$GovernmentApiRequestPayload<ExtArgs>
        fields: Prisma.GovernmentApiRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GovernmentApiRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GovernmentApiRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>
          }
          findFirst: {
            args: Prisma.GovernmentApiRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GovernmentApiRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>
          }
          findMany: {
            args: Prisma.GovernmentApiRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>[]
          }
          create: {
            args: Prisma.GovernmentApiRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>
          }
          createMany: {
            args: Prisma.GovernmentApiRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GovernmentApiRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>[]
          }
          delete: {
            args: Prisma.GovernmentApiRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>
          }
          update: {
            args: Prisma.GovernmentApiRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>
          }
          deleteMany: {
            args: Prisma.GovernmentApiRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GovernmentApiRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GovernmentApiRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>[]
          }
          upsert: {
            args: Prisma.GovernmentApiRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GovernmentApiRequestPayload>
          }
          aggregate: {
            args: Prisma.GovernmentApiRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGovernmentApiRequest>
          }
          groupBy: {
            args: Prisma.GovernmentApiRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<GovernmentApiRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.GovernmentApiRequestCountArgs<ExtArgs>
            result: $Utils.Optional<GovernmentApiRequestCountAggregateOutputType> | number
          }
        }
      }
      LocationUpdate: {
        payload: Prisma.$LocationUpdatePayload<ExtArgs>
        fields: Prisma.LocationUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LocationUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LocationUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>
          }
          findFirst: {
            args: Prisma.LocationUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LocationUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>
          }
          findMany: {
            args: Prisma.LocationUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>[]
          }
          create: {
            args: Prisma.LocationUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>
          }
          createMany: {
            args: Prisma.LocationUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LocationUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>[]
          }
          delete: {
            args: Prisma.LocationUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>
          }
          update: {
            args: Prisma.LocationUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>
          }
          deleteMany: {
            args: Prisma.LocationUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LocationUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LocationUpdateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>[]
          }
          upsert: {
            args: Prisma.LocationUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LocationUpdatePayload>
          }
          aggregate: {
            args: Prisma.LocationUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLocationUpdate>
          }
          groupBy: {
            args: Prisma.LocationUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<LocationUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.LocationUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<LocationUpdateCountAggregateOutputType> | number
          }
        }
      }
      Subscription: {
        payload: Prisma.$SubscriptionPayload<ExtArgs>
        fields: Prisma.SubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findFirst: {
            args: Prisma.SubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          findMany: {
            args: Prisma.SubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          create: {
            args: Prisma.SubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          createMany: {
            args: Prisma.SubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          delete: {
            args: Prisma.SubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          update: {
            args: Prisma.SubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.SubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.SubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubscriptionPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscription>
          }
          groupBy: {
            args: Prisma.SubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    session?: SessionOmit
    user?: UserOmit
    verificationToken?: VerificationTokenOmit
    company?: CompanyOmit
    companyUser?: CompanyUserOmit
    vehicle?: VehicleOmit
    driver?: DriverOmit
    tariff?: TariffOmit
    booking?: BookingOmit
    tripLog?: TripLogOmit
    governmentApiRequest?: GovernmentApiRequestOmit
    locationUpdate?: LocationUpdateOmit
    subscription?: SubscriptionOmit
    payment?: PaymentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    companyUser: number
    riderBookings: number
    tripLogs: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    companyUser?: boolean | UserCountOutputTypeCountCompanyUserArgs
    riderBookings?: boolean | UserCountOutputTypeCountRiderBookingsArgs
    tripLogs?: boolean | UserCountOutputTypeCountTripLogsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCompanyUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountRiderBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTripLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripLogWhereInput
  }


  /**
   * Count Type CompanyCountOutputType
   */

  export type CompanyCountOutputType = {
    vehicles: number
    drivers: number
    tariffs: number
    users: number
    subscriptions: number
    bookings: number
    tripLogs: number
  }

  export type CompanyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | CompanyCountOutputTypeCountVehiclesArgs
    drivers?: boolean | CompanyCountOutputTypeCountDriversArgs
    tariffs?: boolean | CompanyCountOutputTypeCountTariffsArgs
    users?: boolean | CompanyCountOutputTypeCountUsersArgs
    subscriptions?: boolean | CompanyCountOutputTypeCountSubscriptionsArgs
    bookings?: boolean | CompanyCountOutputTypeCountBookingsArgs
    tripLogs?: boolean | CompanyCountOutputTypeCountTripLogsArgs
  }

  // Custom InputTypes
  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyCountOutputType
     */
    select?: CompanyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountVehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTariffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * CompanyCountOutputType without action
   */
  export type CompanyCountOutputTypeCountTripLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripLogWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    drivers: number
    tariffs: number
    bookings: number
    tripLogs: number
    locationUpdates: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    drivers?: boolean | VehicleCountOutputTypeCountDriversArgs
    tariffs?: boolean | VehicleCountOutputTypeCountTariffsArgs
    bookings?: boolean | VehicleCountOutputTypeCountBookingsArgs
    tripLogs?: boolean | VehicleCountOutputTypeCountTripLogsArgs
    locationUpdates?: boolean | VehicleCountOutputTypeCountLocationUpdatesArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountDriversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountTariffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountTripLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripLogWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountLocationUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationUpdateWhereInput
  }


  /**
   * Count Type DriverCountOutputType
   */

  export type DriverCountOutputType = {
    bookings: number
    tripLogs: number
    locationUpdates: number
  }

  export type DriverCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | DriverCountOutputTypeCountBookingsArgs
    tripLogs?: boolean | DriverCountOutputTypeCountTripLogsArgs
    locationUpdates?: boolean | DriverCountOutputTypeCountLocationUpdatesArgs
  }

  // Custom InputTypes
  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DriverCountOutputType
     */
    select?: DriverCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountTripLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripLogWhereInput
  }

  /**
   * DriverCountOutputType without action
   */
  export type DriverCountOutputTypeCountLocationUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationUpdateWhereInput
  }


  /**
   * Count Type TariffCountOutputType
   */

  export type TariffCountOutputType = {
    bookings: number
  }

  export type TariffCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookings?: boolean | TariffCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * TariffCountOutputType without action
   */
  export type TariffCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TariffCountOutputType
     */
    select?: TariffCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TariffCountOutputType without action
   */
  export type TariffCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type TripLogCountOutputType
   */

  export type TripLogCountOutputType = {
    children: number
    apiRequests: number
  }

  export type TripLogCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | TripLogCountOutputTypeCountChildrenArgs
    apiRequests?: boolean | TripLogCountOutputTypeCountApiRequestsArgs
  }

  // Custom InputTypes
  /**
   * TripLogCountOutputType without action
   */
  export type TripLogCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLogCountOutputType
     */
    select?: TripLogCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TripLogCountOutputType without action
   */
  export type TripLogCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripLogWhereInput
  }

  /**
   * TripLogCountOutputType without action
   */
  export type TripLogCountOutputTypeCountApiRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernmentApiRequestWhereInput
  }


  /**
   * Count Type SubscriptionCountOutputType
   */

  export type SubscriptionCountOutputType = {
    payments: number
  }

  export type SubscriptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | SubscriptionCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionCountOutputType
     */
    select?: SubscriptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionCountOutputType without action
   */
  export type SubscriptionCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole | null
    phone: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    email: number
    emailVerified: number
    image: number
    password: number
    role: number
    phone: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    emailVerified?: true
    image?: true
    password?: true
    role?: true
    phone?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    email: string
    emailVerified: Date | null
    image: string | null
    password: string | null
    role: $Enums.UserRole
    phone: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    companyUser?: boolean | User$companyUserArgs<ExtArgs>
    driverProfile?: boolean | User$driverProfileArgs<ExtArgs>
    riderBookings?: boolean | User$riderBookingsArgs<ExtArgs>
    tripLogs?: boolean | User$tripLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    password?: boolean
    role?: boolean
    phone?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "emailVerified" | "image" | "password" | "role" | "phone" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    companyUser?: boolean | User$companyUserArgs<ExtArgs>
    driverProfile?: boolean | User$driverProfileArgs<ExtArgs>
    riderBookings?: boolean | User$riderBookingsArgs<ExtArgs>
    tripLogs?: boolean | User$tripLogsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      companyUser: Prisma.$CompanyUserPayload<ExtArgs>[]
      driverProfile: Prisma.$DriverPayload<ExtArgs> | null
      riderBookings: Prisma.$BookingPayload<ExtArgs>[]
      tripLogs: Prisma.$TripLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      email: string
      emailVerified: Date | null
      image: string | null
      password: string | null
      role: $Enums.UserRole
      phone: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companyUser<T extends User$companyUserArgs<ExtArgs> = {}>(args?: Subset<T, User$companyUserArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    driverProfile<T extends User$driverProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$driverProfileArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    riderBookings<T extends User$riderBookingsArgs<ExtArgs> = {}>(args?: Subset<T, User$riderBookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tripLogs<T extends User$tripLogsArgs<ExtArgs> = {}>(args?: Subset<T, User$tripLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly phone: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.companyUser
   */
  export type User$companyUserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * User.driverProfile
   */
  export type User$driverProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * User.riderBookings
   */
  export type User$riderBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * User.tripLogs
   */
  export type User$tripLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    where?: TripLogWhereInput
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    cursor?: TripLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripLogScalarFieldEnum | TripLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model Company
   */

  export type AggregateCompany = {
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  export type CompanyMinAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    taxNumber: string | null
    taxiLicenseNumber: string | null
    contactPersonName: string | null
    contactPersonEmail: string | null
    contactPersonPhone: string | null
    email: string | null
    phone: string | null
    bankAccount: string | null
    subscriptionType: $Enums.SubscriptionType | null
    logo: string | null
    status: $Enums.CompanyStatus | null
    chironClientId: string | null
    chironClientSecret: string | null
    chironJwtTokenId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyMaxAggregateOutputType = {
    id: string | null
    name: string | null
    address: string | null
    taxNumber: string | null
    taxiLicenseNumber: string | null
    contactPersonName: string | null
    contactPersonEmail: string | null
    contactPersonPhone: string | null
    email: string | null
    phone: string | null
    bankAccount: string | null
    subscriptionType: $Enums.SubscriptionType | null
    logo: string | null
    status: $Enums.CompanyStatus | null
    chironClientId: string | null
    chironClientSecret: string | null
    chironJwtTokenId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CompanyCountAggregateOutputType = {
    id: number
    name: number
    address: number
    taxNumber: number
    taxiLicenseNumber: number
    contactPersonName: number
    contactPersonEmail: number
    contactPersonPhone: number
    email: number
    phone: number
    bankAccount: number
    subscriptionType: number
    logo: number
    status: number
    chironClientId: number
    chironClientSecret: number
    chironJwtTokenId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CompanyMinAggregateInputType = {
    id?: true
    name?: true
    address?: true
    taxNumber?: true
    taxiLicenseNumber?: true
    contactPersonName?: true
    contactPersonEmail?: true
    contactPersonPhone?: true
    email?: true
    phone?: true
    bankAccount?: true
    subscriptionType?: true
    logo?: true
    status?: true
    chironClientId?: true
    chironClientSecret?: true
    chironJwtTokenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyMaxAggregateInputType = {
    id?: true
    name?: true
    address?: true
    taxNumber?: true
    taxiLicenseNumber?: true
    contactPersonName?: true
    contactPersonEmail?: true
    contactPersonPhone?: true
    email?: true
    phone?: true
    bankAccount?: true
    subscriptionType?: true
    logo?: true
    status?: true
    chironClientId?: true
    chironClientSecret?: true
    chironJwtTokenId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CompanyCountAggregateInputType = {
    id?: true
    name?: true
    address?: true
    taxNumber?: true
    taxiLicenseNumber?: true
    contactPersonName?: true
    contactPersonEmail?: true
    contactPersonPhone?: true
    email?: true
    phone?: true
    bankAccount?: true
    subscriptionType?: true
    logo?: true
    status?: true
    chironClientId?: true
    chironClientSecret?: true
    chironJwtTokenId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CompanyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Company to aggregate.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Companies
    **/
    _count?: true | CompanyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyMaxAggregateInputType
  }

  export type GetCompanyAggregateType<T extends CompanyAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany[P]>
      : GetScalarType<T[P], AggregateCompany[P]>
  }




  export type CompanyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyWhereInput
    orderBy?: CompanyOrderByWithAggregationInput | CompanyOrderByWithAggregationInput[]
    by: CompanyScalarFieldEnum[] | CompanyScalarFieldEnum
    having?: CompanyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyCountAggregateInputType | true
    _min?: CompanyMinAggregateInputType
    _max?: CompanyMaxAggregateInputType
  }

  export type CompanyGroupByOutputType = {
    id: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount: string | null
    subscriptionType: $Enums.SubscriptionType
    logo: string | null
    status: $Enums.CompanyStatus
    chironClientId: string | null
    chironClientSecret: string | null
    chironJwtTokenId: string | null
    createdAt: Date
    updatedAt: Date
    _count: CompanyCountAggregateOutputType | null
    _min: CompanyMinAggregateOutputType | null
    _max: CompanyMaxAggregateOutputType | null
  }

  type GetCompanyGroupByPayload<T extends CompanyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyGroupByOutputType[P]>
        }
      >
    >


  export type CompanySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    taxNumber?: boolean
    taxiLicenseNumber?: boolean
    contactPersonName?: boolean
    contactPersonEmail?: boolean
    contactPersonPhone?: boolean
    email?: boolean
    phone?: boolean
    bankAccount?: boolean
    subscriptionType?: boolean
    logo?: boolean
    status?: boolean
    chironClientId?: boolean
    chironClientSecret?: boolean
    chironJwtTokenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicles?: boolean | Company$vehiclesArgs<ExtArgs>
    drivers?: boolean | Company$driversArgs<ExtArgs>
    tariffs?: boolean | Company$tariffsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    subscriptions?: boolean | Company$subscriptionsArgs<ExtArgs>
    bookings?: boolean | Company$bookingsArgs<ExtArgs>
    tripLogs?: boolean | Company$tripLogsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company"]>

  export type CompanySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    taxNumber?: boolean
    taxiLicenseNumber?: boolean
    contactPersonName?: boolean
    contactPersonEmail?: boolean
    contactPersonPhone?: boolean
    email?: boolean
    phone?: boolean
    bankAccount?: boolean
    subscriptionType?: boolean
    logo?: boolean
    status?: boolean
    chironClientId?: boolean
    chironClientSecret?: boolean
    chironJwtTokenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    address?: boolean
    taxNumber?: boolean
    taxiLicenseNumber?: boolean
    contactPersonName?: boolean
    contactPersonEmail?: boolean
    contactPersonPhone?: boolean
    email?: boolean
    phone?: boolean
    bankAccount?: boolean
    subscriptionType?: boolean
    logo?: boolean
    status?: boolean
    chironClientId?: boolean
    chironClientSecret?: boolean
    chironJwtTokenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["company"]>

  export type CompanySelectScalar = {
    id?: boolean
    name?: boolean
    address?: boolean
    taxNumber?: boolean
    taxiLicenseNumber?: boolean
    contactPersonName?: boolean
    contactPersonEmail?: boolean
    contactPersonPhone?: boolean
    email?: boolean
    phone?: boolean
    bankAccount?: boolean
    subscriptionType?: boolean
    logo?: boolean
    status?: boolean
    chironClientId?: boolean
    chironClientSecret?: boolean
    chironJwtTokenId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CompanyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "address" | "taxNumber" | "taxiLicenseNumber" | "contactPersonName" | "contactPersonEmail" | "contactPersonPhone" | "email" | "phone" | "bankAccount" | "subscriptionType" | "logo" | "status" | "chironClientId" | "chironClientSecret" | "chironJwtTokenId" | "createdAt" | "updatedAt", ExtArgs["result"]["company"]>
  export type CompanyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicles?: boolean | Company$vehiclesArgs<ExtArgs>
    drivers?: boolean | Company$driversArgs<ExtArgs>
    tariffs?: boolean | Company$tariffsArgs<ExtArgs>
    users?: boolean | Company$usersArgs<ExtArgs>
    subscriptions?: boolean | Company$subscriptionsArgs<ExtArgs>
    bookings?: boolean | Company$bookingsArgs<ExtArgs>
    tripLogs?: boolean | Company$tripLogsArgs<ExtArgs>
    _count?: boolean | CompanyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CompanyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type CompanyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CompanyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Company"
    objects: {
      vehicles: Prisma.$VehiclePayload<ExtArgs>[]
      drivers: Prisma.$DriverPayload<ExtArgs>[]
      tariffs: Prisma.$TariffPayload<ExtArgs>[]
      users: Prisma.$CompanyUserPayload<ExtArgs>[]
      subscriptions: Prisma.$SubscriptionPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      tripLogs: Prisma.$TripLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      address: string
      taxNumber: string
      taxiLicenseNumber: string
      contactPersonName: string
      contactPersonEmail: string
      contactPersonPhone: string
      email: string
      phone: string
      bankAccount: string | null
      subscriptionType: $Enums.SubscriptionType
      logo: string | null
      status: $Enums.CompanyStatus
      chironClientId: string | null
      chironClientSecret: string | null
      chironJwtTokenId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["company"]>
    composites: {}
  }

  type CompanyGetPayload<S extends boolean | null | undefined | CompanyDefaultArgs> = $Result.GetResult<Prisma.$CompanyPayload, S>

  type CompanyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyCountAggregateInputType | true
    }

  export interface CompanyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Company'], meta: { name: 'Company' } }
    /**
     * Find zero or one Company that matches the filter.
     * @param {CompanyFindUniqueArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyFindUniqueArgs>(args: SelectSubset<T, CompanyFindUniqueArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyFindUniqueOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyFindFirstArgs>(args?: SelectSubset<T, CompanyFindFirstArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindFirstOrThrowArgs} args - Arguments to find a Company
     * @example
     * // Get one Company
     * const company = await prisma.company.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.company.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.company.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyWithIdOnly = await prisma.company.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyFindManyArgs>(args?: SelectSubset<T, CompanyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company.
     * @param {CompanyCreateArgs} args - Arguments to create a Company.
     * @example
     * // Create one Company
     * const Company = await prisma.company.create({
     *   data: {
     *     // ... data to create a Company
     *   }
     * })
     * 
     */
    create<T extends CompanyCreateArgs>(args: SelectSubset<T, CompanyCreateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {CompanyCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyCreateManyArgs>(args?: SelectSubset<T, CompanyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Companies and returns the data saved in the database.
     * @param {CompanyCreateManyAndReturnArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const company = await prisma.company.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Company.
     * @param {CompanyDeleteArgs} args - Arguments to delete one Company.
     * @example
     * // Delete one Company
     * const Company = await prisma.company.delete({
     *   where: {
     *     // ... filter to delete one Company
     *   }
     * })
     * 
     */
    delete<T extends CompanyDeleteArgs>(args: SelectSubset<T, CompanyDeleteArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company.
     * @param {CompanyUpdateArgs} args - Arguments to update one Company.
     * @example
     * // Update one Company
     * const company = await prisma.company.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUpdateArgs>(args: SelectSubset<T, CompanyUpdateArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {CompanyDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.company.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyDeleteManyArgs>(args?: SelectSubset<T, CompanyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUpdateManyArgs>(args: SelectSubset<T, CompanyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies and returns the data updated in the database.
     * @param {CompanyUpdateManyAndReturnArgs} args - Arguments to update many Companies.
     * @example
     * // Update many Companies
     * const company = await prisma.company.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Companies and only return the `id`
     * const companyWithIdOnly = await prisma.company.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Company.
     * @param {CompanyUpsertArgs} args - Arguments to update or create a Company.
     * @example
     * // Update or create a Company
     * const company = await prisma.company.upsert({
     *   create: {
     *     // ... data to create a Company
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUpsertArgs>(args: SelectSubset<T, CompanyUpsertArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.company.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends CompanyCountArgs>(
      args?: Subset<T, CompanyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyAggregateArgs>(args: Subset<T, CompanyAggregateArgs>): Prisma.PrismaPromise<GetCompanyAggregateType<T>>

    /**
     * Group by Company.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyGroupByArgs['orderBy'] }
        : { orderBy?: CompanyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Company model
   */
  readonly fields: CompanyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Company.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicles<T extends Company$vehiclesArgs<ExtArgs> = {}>(args?: Subset<T, Company$vehiclesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    drivers<T extends Company$driversArgs<ExtArgs> = {}>(args?: Subset<T, Company$driversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tariffs<T extends Company$tariffsArgs<ExtArgs> = {}>(args?: Subset<T, Company$tariffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends Company$usersArgs<ExtArgs> = {}>(args?: Subset<T, Company$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    subscriptions<T extends Company$subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Company$subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Company$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Company$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tripLogs<T extends Company$tripLogsArgs<ExtArgs> = {}>(args?: Subset<T, Company$tripLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Company model
   */
  interface CompanyFieldRefs {
    readonly id: FieldRef<"Company", 'String'>
    readonly name: FieldRef<"Company", 'String'>
    readonly address: FieldRef<"Company", 'String'>
    readonly taxNumber: FieldRef<"Company", 'String'>
    readonly taxiLicenseNumber: FieldRef<"Company", 'String'>
    readonly contactPersonName: FieldRef<"Company", 'String'>
    readonly contactPersonEmail: FieldRef<"Company", 'String'>
    readonly contactPersonPhone: FieldRef<"Company", 'String'>
    readonly email: FieldRef<"Company", 'String'>
    readonly phone: FieldRef<"Company", 'String'>
    readonly bankAccount: FieldRef<"Company", 'String'>
    readonly subscriptionType: FieldRef<"Company", 'SubscriptionType'>
    readonly logo: FieldRef<"Company", 'String'>
    readonly status: FieldRef<"Company", 'CompanyStatus'>
    readonly chironClientId: FieldRef<"Company", 'String'>
    readonly chironClientSecret: FieldRef<"Company", 'String'>
    readonly chironJwtTokenId: FieldRef<"Company", 'String'>
    readonly createdAt: FieldRef<"Company", 'DateTime'>
    readonly updatedAt: FieldRef<"Company", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Company findUnique
   */
  export type CompanyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findUniqueOrThrow
   */
  export type CompanyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company findFirst
   */
  export type CompanyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findFirstOrThrow
   */
  export type CompanyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Company to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Companies.
     */
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company findMany
   */
  export type CompanyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter, which Companies to fetch.
     */
    where?: CompanyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Companies to fetch.
     */
    orderBy?: CompanyOrderByWithRelationInput | CompanyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Companies.
     */
    cursor?: CompanyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Companies.
     */
    skip?: number
    distinct?: CompanyScalarFieldEnum | CompanyScalarFieldEnum[]
  }

  /**
   * Company create
   */
  export type CompanyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to create a Company.
     */
    data: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
  }

  /**
   * Company createMany
   */
  export type CompanyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
  }

  /**
   * Company createManyAndReturn
   */
  export type CompanyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to create many Companies.
     */
    data: CompanyCreateManyInput | CompanyCreateManyInput[]
  }

  /**
   * Company update
   */
  export type CompanyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The data needed to update a Company.
     */
    data: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
    /**
     * Choose, which Company to update.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company updateMany
   */
  export type CompanyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company updateManyAndReturn
   */
  export type CompanyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * The data used to update Companies.
     */
    data: XOR<CompanyUpdateManyMutationInput, CompanyUncheckedUpdateManyInput>
    /**
     * Filter which Companies to update
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to update.
     */
    limit?: number
  }

  /**
   * Company upsert
   */
  export type CompanyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * The filter to search for the Company to update in case it exists.
     */
    where: CompanyWhereUniqueInput
    /**
     * In case the Company found by the `where` argument doesn't exist, create a new Company with this data.
     */
    create: XOR<CompanyCreateInput, CompanyUncheckedCreateInput>
    /**
     * In case the Company was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUpdateInput, CompanyUncheckedUpdateInput>
  }

  /**
   * Company delete
   */
  export type CompanyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
    /**
     * Filter which Company to delete.
     */
    where: CompanyWhereUniqueInput
  }

  /**
   * Company deleteMany
   */
  export type CompanyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Companies to delete
     */
    where?: CompanyWhereInput
    /**
     * Limit how many Companies to delete.
     */
    limit?: number
  }

  /**
   * Company.vehicles
   */
  export type Company$vehiclesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    cursor?: VehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Company.drivers
   */
  export type Company$driversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    cursor?: DriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Company.tariffs
   */
  export type Company$tariffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    where?: TariffWhereInput
    orderBy?: TariffOrderByWithRelationInput | TariffOrderByWithRelationInput[]
    cursor?: TariffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TariffScalarFieldEnum | TariffScalarFieldEnum[]
  }

  /**
   * Company.users
   */
  export type Company$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    cursor?: CompanyUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * Company.subscriptions
   */
  export type Company$subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    cursor?: SubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Company.bookings
   */
  export type Company$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Company.tripLogs
   */
  export type Company$tripLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    where?: TripLogWhereInput
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    cursor?: TripLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripLogScalarFieldEnum | TripLogScalarFieldEnum[]
  }

  /**
   * Company without action
   */
  export type CompanyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company
     */
    select?: CompanySelect<ExtArgs> | null
    /**
     * Omit specific fields from the Company
     */
    omit?: CompanyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyInclude<ExtArgs> | null
  }


  /**
   * Model CompanyUser
   */

  export type AggregateCompanyUser = {
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  export type CompanyUserMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type CompanyUserMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    role: string | null
    createdAt: Date | null
  }

  export type CompanyUserCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    role: number
    createdAt: number
    _all: number
  }


  export type CompanyUserMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
  }

  export type CompanyUserMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
  }

  export type CompanyUserCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    role?: true
    createdAt?: true
    _all?: true
  }

  export type CompanyUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUser to aggregate.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CompanyUsers
    **/
    _count?: true | CompanyUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompanyUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompanyUserMaxAggregateInputType
  }

  export type GetCompanyUserAggregateType<T extends CompanyUserAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanyUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanyUser[P]>
      : GetScalarType<T[P], AggregateCompanyUser[P]>
  }




  export type CompanyUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CompanyUserWhereInput
    orderBy?: CompanyUserOrderByWithAggregationInput | CompanyUserOrderByWithAggregationInput[]
    by: CompanyUserScalarFieldEnum[] | CompanyUserScalarFieldEnum
    having?: CompanyUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompanyUserCountAggregateInputType | true
    _min?: CompanyUserMinAggregateInputType
    _max?: CompanyUserMaxAggregateInputType
  }

  export type CompanyUserGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    role: string
    createdAt: Date
    _count: CompanyUserCountAggregateOutputType | null
    _min: CompanyUserMinAggregateOutputType | null
    _max: CompanyUserMaxAggregateOutputType | null
  }

  type GetCompanyUserGroupByPayload<T extends CompanyUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompanyUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompanyUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
            : GetScalarType<T[P], CompanyUserGroupByOutputType[P]>
        }
      >
    >


  export type CompanyUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companyUser"]>

  export type CompanyUserSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    role?: boolean
    createdAt?: boolean
  }

  export type CompanyUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "role" | "createdAt", ExtArgs["result"]["companyUser"]>
  export type CompanyUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type CompanyUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $CompanyUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CompanyUser"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      role: string
      createdAt: Date
    }, ExtArgs["result"]["companyUser"]>
    composites: {}
  }

  type CompanyUserGetPayload<S extends boolean | null | undefined | CompanyUserDefaultArgs> = $Result.GetResult<Prisma.$CompanyUserPayload, S>

  type CompanyUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CompanyUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompanyUserCountAggregateInputType | true
    }

  export interface CompanyUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CompanyUser'], meta: { name: 'CompanyUser' } }
    /**
     * Find zero or one CompanyUser that matches the filter.
     * @param {CompanyUserFindUniqueArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CompanyUserFindUniqueArgs>(args: SelectSubset<T, CompanyUserFindUniqueArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CompanyUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CompanyUserFindUniqueOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CompanyUserFindUniqueOrThrowArgs>(args: SelectSubset<T, CompanyUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CompanyUserFindFirstArgs>(args?: SelectSubset<T, CompanyUserFindFirstArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CompanyUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindFirstOrThrowArgs} args - Arguments to find a CompanyUser
     * @example
     * // Get one CompanyUser
     * const companyUser = await prisma.companyUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CompanyUserFindFirstOrThrowArgs>(args?: SelectSubset<T, CompanyUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CompanyUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany()
     * 
     * // Get first 10 CompanyUsers
     * const companyUsers = await prisma.companyUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companyUserWithIdOnly = await prisma.companyUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CompanyUserFindManyArgs>(args?: SelectSubset<T, CompanyUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CompanyUser.
     * @param {CompanyUserCreateArgs} args - Arguments to create a CompanyUser.
     * @example
     * // Create one CompanyUser
     * const CompanyUser = await prisma.companyUser.create({
     *   data: {
     *     // ... data to create a CompanyUser
     *   }
     * })
     * 
     */
    create<T extends CompanyUserCreateArgs>(args: SelectSubset<T, CompanyUserCreateArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CompanyUsers.
     * @param {CompanyUserCreateManyArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CompanyUserCreateManyArgs>(args?: SelectSubset<T, CompanyUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CompanyUsers and returns the data saved in the database.
     * @param {CompanyUserCreateManyAndReturnArgs} args - Arguments to create many CompanyUsers.
     * @example
     * // Create many CompanyUsers
     * const companyUser = await prisma.companyUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CompanyUsers and only return the `id`
     * const companyUserWithIdOnly = await prisma.companyUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CompanyUserCreateManyAndReturnArgs>(args?: SelectSubset<T, CompanyUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CompanyUser.
     * @param {CompanyUserDeleteArgs} args - Arguments to delete one CompanyUser.
     * @example
     * // Delete one CompanyUser
     * const CompanyUser = await prisma.companyUser.delete({
     *   where: {
     *     // ... filter to delete one CompanyUser
     *   }
     * })
     * 
     */
    delete<T extends CompanyUserDeleteArgs>(args: SelectSubset<T, CompanyUserDeleteArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CompanyUser.
     * @param {CompanyUserUpdateArgs} args - Arguments to update one CompanyUser.
     * @example
     * // Update one CompanyUser
     * const companyUser = await prisma.companyUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CompanyUserUpdateArgs>(args: SelectSubset<T, CompanyUserUpdateArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CompanyUsers.
     * @param {CompanyUserDeleteManyArgs} args - Arguments to filter CompanyUsers to delete.
     * @example
     * // Delete a few CompanyUsers
     * const { count } = await prisma.companyUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CompanyUserDeleteManyArgs>(args?: SelectSubset<T, CompanyUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CompanyUsers
     * const companyUser = await prisma.companyUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CompanyUserUpdateManyArgs>(args: SelectSubset<T, CompanyUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CompanyUsers and returns the data updated in the database.
     * @param {CompanyUserUpdateManyAndReturnArgs} args - Arguments to update many CompanyUsers.
     * @example
     * // Update many CompanyUsers
     * const companyUser = await prisma.companyUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CompanyUsers and only return the `id`
     * const companyUserWithIdOnly = await prisma.companyUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CompanyUserUpdateManyAndReturnArgs>(args: SelectSubset<T, CompanyUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CompanyUser.
     * @param {CompanyUserUpsertArgs} args - Arguments to update or create a CompanyUser.
     * @example
     * // Update or create a CompanyUser
     * const companyUser = await prisma.companyUser.upsert({
     *   create: {
     *     // ... data to create a CompanyUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CompanyUser we want to update
     *   }
     * })
     */
    upsert<T extends CompanyUserUpsertArgs>(args: SelectSubset<T, CompanyUserUpsertArgs<ExtArgs>>): Prisma__CompanyUserClient<$Result.GetResult<Prisma.$CompanyUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CompanyUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserCountArgs} args - Arguments to filter CompanyUsers to count.
     * @example
     * // Count the number of CompanyUsers
     * const count = await prisma.companyUser.count({
     *   where: {
     *     // ... the filter for the CompanyUsers we want to count
     *   }
     * })
    **/
    count<T extends CompanyUserCountArgs>(
      args?: Subset<T, CompanyUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompanyUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompanyUserAggregateArgs>(args: Subset<T, CompanyUserAggregateArgs>): Prisma.PrismaPromise<GetCompanyUserAggregateType<T>>

    /**
     * Group by CompanyUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompanyUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CompanyUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CompanyUserGroupByArgs['orderBy'] }
        : { orderBy?: CompanyUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CompanyUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompanyUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CompanyUser model
   */
  readonly fields: CompanyUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CompanyUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CompanyUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CompanyUser model
   */
  interface CompanyUserFieldRefs {
    readonly id: FieldRef<"CompanyUser", 'String'>
    readonly userId: FieldRef<"CompanyUser", 'String'>
    readonly companyId: FieldRef<"CompanyUser", 'String'>
    readonly role: FieldRef<"CompanyUser", 'String'>
    readonly createdAt: FieldRef<"CompanyUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CompanyUser findUnique
   */
  export type CompanyUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findUniqueOrThrow
   */
  export type CompanyUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser findFirst
   */
  export type CompanyUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findFirstOrThrow
   */
  export type CompanyUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUser to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CompanyUsers.
     */
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser findMany
   */
  export type CompanyUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter, which CompanyUsers to fetch.
     */
    where?: CompanyUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CompanyUsers to fetch.
     */
    orderBy?: CompanyUserOrderByWithRelationInput | CompanyUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CompanyUsers.
     */
    cursor?: CompanyUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CompanyUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CompanyUsers.
     */
    skip?: number
    distinct?: CompanyUserScalarFieldEnum | CompanyUserScalarFieldEnum[]
  }

  /**
   * CompanyUser create
   */
  export type CompanyUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to create a CompanyUser.
     */
    data: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
  }

  /**
   * CompanyUser createMany
   */
  export type CompanyUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
  }

  /**
   * CompanyUser createManyAndReturn
   */
  export type CompanyUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * The data used to create many CompanyUsers.
     */
    data: CompanyUserCreateManyInput | CompanyUserCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyUser update
   */
  export type CompanyUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The data needed to update a CompanyUser.
     */
    data: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
    /**
     * Choose, which CompanyUser to update.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser updateMany
   */
  export type CompanyUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CompanyUsers.
     */
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyInput>
    /**
     * Filter which CompanyUsers to update
     */
    where?: CompanyUserWhereInput
    /**
     * Limit how many CompanyUsers to update.
     */
    limit?: number
  }

  /**
   * CompanyUser updateManyAndReturn
   */
  export type CompanyUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * The data used to update CompanyUsers.
     */
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyInput>
    /**
     * Filter which CompanyUsers to update
     */
    where?: CompanyUserWhereInput
    /**
     * Limit how many CompanyUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CompanyUser upsert
   */
  export type CompanyUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * The filter to search for the CompanyUser to update in case it exists.
     */
    where: CompanyUserWhereUniqueInput
    /**
     * In case the CompanyUser found by the `where` argument doesn't exist, create a new CompanyUser with this data.
     */
    create: XOR<CompanyUserCreateInput, CompanyUserUncheckedCreateInput>
    /**
     * In case the CompanyUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CompanyUserUpdateInput, CompanyUserUncheckedUpdateInput>
  }

  /**
   * CompanyUser delete
   */
  export type CompanyUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
    /**
     * Filter which CompanyUser to delete.
     */
    where: CompanyUserWhereUniqueInput
  }

  /**
   * CompanyUser deleteMany
   */
  export type CompanyUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CompanyUsers to delete
     */
    where?: CompanyUserWhereInput
    /**
     * Limit how many CompanyUsers to delete.
     */
    limit?: number
  }

  /**
   * CompanyUser without action
   */
  export type CompanyUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompanyUser
     */
    select?: CompanyUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CompanyUser
     */
    omit?: CompanyUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CompanyUserInclude<ExtArgs> | null
  }


  /**
   * Model Vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    year: number | null
  }

  export type VehicleSumAggregateOutputType = {
    year: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    licensePlate: string | null
    brand: string | null
    model: string | null
    year: number | null
    color: string | null
    taxiLicenseNumber: string | null
    insuranceExpiry: Date | null
    keuringExpiry: Date | null
    pictures: string | null
    status: $Enums.VehicleStatus | null
    taxiLightWebhookOnUrl: string | null
    taxiLightWebhookOffUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    licensePlate: string | null
    brand: string | null
    model: string | null
    year: number | null
    color: string | null
    taxiLicenseNumber: string | null
    insuranceExpiry: Date | null
    keuringExpiry: Date | null
    pictures: string | null
    status: $Enums.VehicleStatus | null
    taxiLightWebhookOnUrl: string | null
    taxiLightWebhookOffUrl: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    companyId: number
    licensePlate: number
    brand: number
    model: number
    year: number
    color: number
    taxiLicenseNumber: number
    insuranceExpiry: number
    keuringExpiry: number
    pictures: number
    status: number
    taxiLightWebhookOnUrl: number
    taxiLightWebhookOffUrl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    year?: true
  }

  export type VehicleSumAggregateInputType = {
    year?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    companyId?: true
    licensePlate?: true
    brand?: true
    model?: true
    year?: true
    color?: true
    taxiLicenseNumber?: true
    insuranceExpiry?: true
    keuringExpiry?: true
    pictures?: true
    status?: true
    taxiLightWebhookOnUrl?: true
    taxiLightWebhookOffUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    companyId?: true
    licensePlate?: true
    brand?: true
    model?: true
    year?: true
    color?: true
    taxiLicenseNumber?: true
    insuranceExpiry?: true
    keuringExpiry?: true
    pictures?: true
    status?: true
    taxiLightWebhookOnUrl?: true
    taxiLightWebhookOffUrl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    companyId?: true
    licensePlate?: true
    brand?: true
    model?: true
    year?: true
    color?: true
    taxiLicenseNumber?: true
    insuranceExpiry?: true
    keuringExpiry?: true
    pictures?: true
    status?: true
    taxiLightWebhookOnUrl?: true
    taxiLightWebhookOffUrl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicle to aggregate.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type VehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VehicleWhereInput
    orderBy?: VehicleOrderByWithAggregationInput | VehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: VehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    companyId: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date
    keuringExpiry: Date
    pictures: string
    status: $Enums.VehicleStatus
    taxiLightWebhookOnUrl: string | null
    taxiLightWebhookOffUrl: string | null
    createdAt: Date
    updatedAt: Date
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends VehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type VehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    licensePlate?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    color?: boolean
    taxiLicenseNumber?: boolean
    insuranceExpiry?: boolean
    keuringExpiry?: boolean
    pictures?: boolean
    status?: boolean
    taxiLightWebhookOnUrl?: boolean
    taxiLightWebhookOffUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    drivers?: boolean | Vehicle$driversArgs<ExtArgs>
    tariffs?: boolean | Vehicle$tariffsArgs<ExtArgs>
    bookings?: boolean | Vehicle$bookingsArgs<ExtArgs>
    tripLogs?: boolean | Vehicle$tripLogsArgs<ExtArgs>
    locationUpdates?: boolean | Vehicle$locationUpdatesArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    licensePlate?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    color?: boolean
    taxiLicenseNumber?: boolean
    insuranceExpiry?: boolean
    keuringExpiry?: boolean
    pictures?: boolean
    status?: boolean
    taxiLightWebhookOnUrl?: boolean
    taxiLightWebhookOffUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    licensePlate?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    color?: boolean
    taxiLicenseNumber?: boolean
    insuranceExpiry?: boolean
    keuringExpiry?: boolean
    pictures?: boolean
    status?: boolean
    taxiLightWebhookOnUrl?: boolean
    taxiLightWebhookOffUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>

  export type VehicleSelectScalar = {
    id?: boolean
    companyId?: boolean
    licensePlate?: boolean
    brand?: boolean
    model?: boolean
    year?: boolean
    color?: boolean
    taxiLicenseNumber?: boolean
    insuranceExpiry?: boolean
    keuringExpiry?: boolean
    pictures?: boolean
    status?: boolean
    taxiLightWebhookOnUrl?: boolean
    taxiLightWebhookOffUrl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "licensePlate" | "brand" | "model" | "year" | "color" | "taxiLicenseNumber" | "insuranceExpiry" | "keuringExpiry" | "pictures" | "status" | "taxiLightWebhookOnUrl" | "taxiLightWebhookOffUrl" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle"]>
  export type VehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    drivers?: boolean | Vehicle$driversArgs<ExtArgs>
    tariffs?: boolean | Vehicle$tariffsArgs<ExtArgs>
    bookings?: boolean | Vehicle$bookingsArgs<ExtArgs>
    tripLogs?: boolean | Vehicle$tripLogsArgs<ExtArgs>
    locationUpdates?: boolean | Vehicle$locationUpdatesArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type VehicleIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $VehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vehicle"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      drivers: Prisma.$DriverPayload<ExtArgs>[]
      tariffs: Prisma.$TariffPayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      tripLogs: Prisma.$TripLogPayload<ExtArgs>[]
      locationUpdates: Prisma.$LocationUpdatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      licensePlate: string
      brand: string
      model: string
      year: number
      color: string
      taxiLicenseNumber: string
      insuranceExpiry: Date
      keuringExpiry: Date
      pictures: string
      status: $Enums.VehicleStatus
      taxiLightWebhookOnUrl: string | null
      taxiLightWebhookOffUrl: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type VehicleGetPayload<S extends boolean | null | undefined | VehicleDefaultArgs> = $Result.GetResult<Prisma.$VehiclePayload, S>

  type VehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface VehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vehicle'], meta: { name: 'Vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {VehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VehicleFindUniqueArgs>(args: SelectSubset<T, VehicleFindUniqueArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, VehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VehicleFindFirstArgs>(args?: SelectSubset<T, VehicleFindFirstArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, VehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VehicleFindManyArgs>(args?: SelectSubset<T, VehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {VehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends VehicleCreateArgs>(args: SelectSubset<T, VehicleCreateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {VehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VehicleCreateManyArgs>(args?: SelectSubset<T, VehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vehicles and returns the data saved in the database.
     * @param {VehicleCreateManyAndReturnArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VehicleCreateManyAndReturnArgs>(args?: SelectSubset<T, VehicleCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vehicle.
     * @param {VehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends VehicleDeleteArgs>(args: SelectSubset<T, VehicleDeleteArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {VehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VehicleUpdateArgs>(args: SelectSubset<T, VehicleUpdateArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {VehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VehicleDeleteManyArgs>(args?: SelectSubset<T, VehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VehicleUpdateManyArgs>(args: SelectSubset<T, VehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles and returns the data updated in the database.
     * @param {VehicleUpdateManyAndReturnArgs} args - Arguments to update many Vehicles.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vehicles and only return the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VehicleUpdateManyAndReturnArgs>(args: SelectSubset<T, VehicleUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vehicle.
     * @param {VehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends VehicleUpsertArgs>(args: SelectSubset<T, VehicleUpsertArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends VehicleCountArgs>(
      args?: Subset<T, VehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VehicleGroupByArgs['orderBy'] }
        : { orderBy?: VehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vehicle model
   */
  readonly fields: VehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    drivers<T extends Vehicle$driversArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$driversArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tariffs<T extends Vehicle$tariffsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$tariffsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Vehicle$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tripLogs<T extends Vehicle$tripLogsArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$tripLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locationUpdates<T extends Vehicle$locationUpdatesArgs<ExtArgs> = {}>(args?: Subset<T, Vehicle$locationUpdatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vehicle model
   */
  interface VehicleFieldRefs {
    readonly id: FieldRef<"Vehicle", 'String'>
    readonly companyId: FieldRef<"Vehicle", 'String'>
    readonly licensePlate: FieldRef<"Vehicle", 'String'>
    readonly brand: FieldRef<"Vehicle", 'String'>
    readonly model: FieldRef<"Vehicle", 'String'>
    readonly year: FieldRef<"Vehicle", 'Int'>
    readonly color: FieldRef<"Vehicle", 'String'>
    readonly taxiLicenseNumber: FieldRef<"Vehicle", 'String'>
    readonly insuranceExpiry: FieldRef<"Vehicle", 'DateTime'>
    readonly keuringExpiry: FieldRef<"Vehicle", 'DateTime'>
    readonly pictures: FieldRef<"Vehicle", 'String'>
    readonly status: FieldRef<"Vehicle", 'VehicleStatus'>
    readonly taxiLightWebhookOnUrl: FieldRef<"Vehicle", 'String'>
    readonly taxiLightWebhookOffUrl: FieldRef<"Vehicle", 'String'>
    readonly createdAt: FieldRef<"Vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"Vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vehicle findUnique
   */
  export type VehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findUniqueOrThrow
   */
  export type VehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle findFirst
   */
  export type VehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findFirstOrThrow
   */
  export type VehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicle to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle findMany
   */
  export type VehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter, which Vehicles to fetch.
     */
    where?: VehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vehicles to fetch.
     */
    orderBy?: VehicleOrderByWithRelationInput | VehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vehicles.
     */
    cursor?: VehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * Vehicle create
   */
  export type VehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a Vehicle.
     */
    data: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
  }

  /**
   * Vehicle createMany
   */
  export type VehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
  }

  /**
   * Vehicle createManyAndReturn
   */
  export type VehicleCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to create many Vehicles.
     */
    data: VehicleCreateManyInput | VehicleCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle update
   */
  export type VehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a Vehicle.
     */
    data: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
    /**
     * Choose, which Vehicle to update.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle updateMany
   */
  export type VehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
  }

  /**
   * Vehicle updateManyAndReturn
   */
  export type VehicleUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * The data used to update Vehicles.
     */
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyInput>
    /**
     * Filter which Vehicles to update
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Vehicle upsert
   */
  export type VehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the Vehicle to update in case it exists.
     */
    where: VehicleWhereUniqueInput
    /**
     * In case the Vehicle found by the `where` argument doesn't exist, create a new Vehicle with this data.
     */
    create: XOR<VehicleCreateInput, VehicleUncheckedCreateInput>
    /**
     * In case the Vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VehicleUpdateInput, VehicleUncheckedUpdateInput>
  }

  /**
   * Vehicle delete
   */
  export type VehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    /**
     * Filter which Vehicle to delete.
     */
    where: VehicleWhereUniqueInput
  }

  /**
   * Vehicle deleteMany
   */
  export type VehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vehicles to delete
     */
    where?: VehicleWhereInput
    /**
     * Limit how many Vehicles to delete.
     */
    limit?: number
  }

  /**
   * Vehicle.drivers
   */
  export type Vehicle$driversArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    cursor?: DriverWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Vehicle.tariffs
   */
  export type Vehicle$tariffsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    where?: TariffWhereInput
    orderBy?: TariffOrderByWithRelationInput | TariffOrderByWithRelationInput[]
    cursor?: TariffWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TariffScalarFieldEnum | TariffScalarFieldEnum[]
  }

  /**
   * Vehicle.bookings
   */
  export type Vehicle$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Vehicle.tripLogs
   */
  export type Vehicle$tripLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    where?: TripLogWhereInput
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    cursor?: TripLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripLogScalarFieldEnum | TripLogScalarFieldEnum[]
  }

  /**
   * Vehicle.locationUpdates
   */
  export type Vehicle$locationUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    where?: LocationUpdateWhereInput
    orderBy?: LocationUpdateOrderByWithRelationInput | LocationUpdateOrderByWithRelationInput[]
    cursor?: LocationUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationUpdateScalarFieldEnum | LocationUpdateScalarFieldEnum[]
  }

  /**
   * Vehicle without action
   */
  export type VehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
  }


  /**
   * Model Driver
   */

  export type AggregateDriver = {
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  export type DriverAvgAggregateOutputType = {
    currentLatitude: number | null
    currentLongitude: number | null
  }

  export type DriverSumAggregateOutputType = {
    currentLatitude: number | null
    currentLongitude: number | null
  }

  export type DriverMinAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    vehicleId: string | null
    firstName: string | null
    lastName: string | null
    taxiDriverLicense: string | null
    licenseExpiry: Date | null
    address: string | null
    phone: string | null
    email: string | null
    picture: string | null
    status: $Enums.DriverStatus | null
    isOnline: boolean | null
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    companyId: string | null
    vehicleId: string | null
    firstName: string | null
    lastName: string | null
    taxiDriverLicense: string | null
    licenseExpiry: Date | null
    address: string | null
    phone: string | null
    email: string | null
    picture: string | null
    status: $Enums.DriverStatus | null
    isOnline: boolean | null
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DriverCountAggregateOutputType = {
    id: number
    userId: number
    companyId: number
    vehicleId: number
    firstName: number
    lastName: number
    taxiDriverLicense: number
    licenseExpiry: number
    address: number
    phone: number
    email: number
    picture: number
    status: number
    isOnline: number
    currentLatitude: number
    currentLongitude: number
    lastLocationUpdate: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DriverAvgAggregateInputType = {
    currentLatitude?: true
    currentLongitude?: true
  }

  export type DriverSumAggregateInputType = {
    currentLatitude?: true
    currentLongitude?: true
  }

  export type DriverMinAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    vehicleId?: true
    firstName?: true
    lastName?: true
    taxiDriverLicense?: true
    licenseExpiry?: true
    address?: true
    phone?: true
    email?: true
    picture?: true
    status?: true
    isOnline?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverMaxAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    vehicleId?: true
    firstName?: true
    lastName?: true
    taxiDriverLicense?: true
    licenseExpiry?: true
    address?: true
    phone?: true
    email?: true
    picture?: true
    status?: true
    isOnline?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DriverCountAggregateInputType = {
    id?: true
    userId?: true
    companyId?: true
    vehicleId?: true
    firstName?: true
    lastName?: true
    taxiDriverLicense?: true
    licenseExpiry?: true
    address?: true
    phone?: true
    email?: true
    picture?: true
    status?: true
    isOnline?: true
    currentLatitude?: true
    currentLongitude?: true
    lastLocationUpdate?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DriverAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Driver to aggregate.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Drivers
    **/
    _count?: true | DriverCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriverAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriverSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriverMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriverMaxAggregateInputType
  }

  export type GetDriverAggregateType<T extends DriverAggregateArgs> = {
        [P in keyof T & keyof AggregateDriver]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDriver[P]>
      : GetScalarType<T[P], AggregateDriver[P]>
  }




  export type DriverGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DriverWhereInput
    orderBy?: DriverOrderByWithAggregationInput | DriverOrderByWithAggregationInput[]
    by: DriverScalarFieldEnum[] | DriverScalarFieldEnum
    having?: DriverScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriverCountAggregateInputType | true
    _avg?: DriverAvgAggregateInputType
    _sum?: DriverSumAggregateInputType
    _min?: DriverMinAggregateInputType
    _max?: DriverMaxAggregateInputType
  }

  export type DriverGroupByOutputType = {
    id: string
    userId: string
    companyId: string
    vehicleId: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date
    address: string
    phone: string
    email: string
    picture: string | null
    status: $Enums.DriverStatus
    isOnline: boolean
    currentLatitude: number | null
    currentLongitude: number | null
    lastLocationUpdate: Date | null
    createdAt: Date
    updatedAt: Date
    _count: DriverCountAggregateOutputType | null
    _avg: DriverAvgAggregateOutputType | null
    _sum: DriverSumAggregateOutputType | null
    _min: DriverMinAggregateOutputType | null
    _max: DriverMaxAggregateOutputType | null
  }

  type GetDriverGroupByPayload<T extends DriverGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DriverGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriverGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriverGroupByOutputType[P]>
            : GetScalarType<T[P], DriverGroupByOutputType[P]>
        }
      >
    >


  export type DriverSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    vehicleId?: boolean
    firstName?: boolean
    lastName?: boolean
    taxiDriverLicense?: boolean
    licenseExpiry?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    picture?: boolean
    status?: boolean
    isOnline?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Driver$vehicleArgs<ExtArgs>
    bookings?: boolean | Driver$bookingsArgs<ExtArgs>
    tripLogs?: boolean | Driver$tripLogsArgs<ExtArgs>
    locationUpdates?: boolean | Driver$locationUpdatesArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    vehicleId?: boolean
    firstName?: boolean
    lastName?: boolean
    taxiDriverLicense?: boolean
    licenseExpiry?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    picture?: boolean
    status?: boolean
    isOnline?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Driver$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    companyId?: boolean
    vehicleId?: boolean
    firstName?: boolean
    lastName?: boolean
    taxiDriverLicense?: boolean
    licenseExpiry?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    picture?: boolean
    status?: boolean
    isOnline?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Driver$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["driver"]>

  export type DriverSelectScalar = {
    id?: boolean
    userId?: boolean
    companyId?: boolean
    vehicleId?: boolean
    firstName?: boolean
    lastName?: boolean
    taxiDriverLicense?: boolean
    licenseExpiry?: boolean
    address?: boolean
    phone?: boolean
    email?: boolean
    picture?: boolean
    status?: boolean
    isOnline?: boolean
    currentLatitude?: boolean
    currentLongitude?: boolean
    lastLocationUpdate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DriverOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "companyId" | "vehicleId" | "firstName" | "lastName" | "taxiDriverLicense" | "licenseExpiry" | "address" | "phone" | "email" | "picture" | "status" | "isOnline" | "currentLatitude" | "currentLongitude" | "lastLocationUpdate" | "createdAt" | "updatedAt", ExtArgs["result"]["driver"]>
  export type DriverInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Driver$vehicleArgs<ExtArgs>
    bookings?: boolean | Driver$bookingsArgs<ExtArgs>
    tripLogs?: boolean | Driver$tripLogsArgs<ExtArgs>
    locationUpdates?: boolean | Driver$locationUpdatesArgs<ExtArgs>
    _count?: boolean | DriverCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DriverIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Driver$vehicleArgs<ExtArgs>
  }
  export type DriverIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Driver$vehicleArgs<ExtArgs>
  }

  export type $DriverPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Driver"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
      bookings: Prisma.$BookingPayload<ExtArgs>[]
      tripLogs: Prisma.$TripLogPayload<ExtArgs>[]
      locationUpdates: Prisma.$LocationUpdatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      companyId: string
      vehicleId: string | null
      firstName: string
      lastName: string
      taxiDriverLicense: string
      licenseExpiry: Date
      address: string
      phone: string
      email: string
      picture: string | null
      status: $Enums.DriverStatus
      isOnline: boolean
      currentLatitude: number | null
      currentLongitude: number | null
      lastLocationUpdate: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["driver"]>
    composites: {}
  }

  type DriverGetPayload<S extends boolean | null | undefined | DriverDefaultArgs> = $Result.GetResult<Prisma.$DriverPayload, S>

  type DriverCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DriverFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DriverCountAggregateInputType | true
    }

  export interface DriverDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Driver'], meta: { name: 'Driver' } }
    /**
     * Find zero or one Driver that matches the filter.
     * @param {DriverFindUniqueArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DriverFindUniqueArgs>(args: SelectSubset<T, DriverFindUniqueArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Driver that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DriverFindUniqueOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DriverFindUniqueOrThrowArgs>(args: SelectSubset<T, DriverFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DriverFindFirstArgs>(args?: SelectSubset<T, DriverFindFirstArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Driver that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindFirstOrThrowArgs} args - Arguments to find a Driver
     * @example
     * // Get one Driver
     * const driver = await prisma.driver.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DriverFindFirstOrThrowArgs>(args?: SelectSubset<T, DriverFindFirstOrThrowArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Drivers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drivers
     * const drivers = await prisma.driver.findMany()
     * 
     * // Get first 10 Drivers
     * const drivers = await prisma.driver.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driverWithIdOnly = await prisma.driver.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DriverFindManyArgs>(args?: SelectSubset<T, DriverFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Driver.
     * @param {DriverCreateArgs} args - Arguments to create a Driver.
     * @example
     * // Create one Driver
     * const Driver = await prisma.driver.create({
     *   data: {
     *     // ... data to create a Driver
     *   }
     * })
     * 
     */
    create<T extends DriverCreateArgs>(args: SelectSubset<T, DriverCreateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Drivers.
     * @param {DriverCreateManyArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DriverCreateManyArgs>(args?: SelectSubset<T, DriverCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Drivers and returns the data saved in the database.
     * @param {DriverCreateManyAndReturnArgs} args - Arguments to create many Drivers.
     * @example
     * // Create many Drivers
     * const driver = await prisma.driver.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DriverCreateManyAndReturnArgs>(args?: SelectSubset<T, DriverCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Driver.
     * @param {DriverDeleteArgs} args - Arguments to delete one Driver.
     * @example
     * // Delete one Driver
     * const Driver = await prisma.driver.delete({
     *   where: {
     *     // ... filter to delete one Driver
     *   }
     * })
     * 
     */
    delete<T extends DriverDeleteArgs>(args: SelectSubset<T, DriverDeleteArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Driver.
     * @param {DriverUpdateArgs} args - Arguments to update one Driver.
     * @example
     * // Update one Driver
     * const driver = await prisma.driver.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DriverUpdateArgs>(args: SelectSubset<T, DriverUpdateArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Drivers.
     * @param {DriverDeleteManyArgs} args - Arguments to filter Drivers to delete.
     * @example
     * // Delete a few Drivers
     * const { count } = await prisma.driver.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DriverDeleteManyArgs>(args?: SelectSubset<T, DriverDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DriverUpdateManyArgs>(args: SelectSubset<T, DriverUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drivers and returns the data updated in the database.
     * @param {DriverUpdateManyAndReturnArgs} args - Arguments to update many Drivers.
     * @example
     * // Update many Drivers
     * const driver = await prisma.driver.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Drivers and only return the `id`
     * const driverWithIdOnly = await prisma.driver.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DriverUpdateManyAndReturnArgs>(args: SelectSubset<T, DriverUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Driver.
     * @param {DriverUpsertArgs} args - Arguments to update or create a Driver.
     * @example
     * // Update or create a Driver
     * const driver = await prisma.driver.upsert({
     *   create: {
     *     // ... data to create a Driver
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Driver we want to update
     *   }
     * })
     */
    upsert<T extends DriverUpsertArgs>(args: SelectSubset<T, DriverUpsertArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Drivers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverCountArgs} args - Arguments to filter Drivers to count.
     * @example
     * // Count the number of Drivers
     * const count = await prisma.driver.count({
     *   where: {
     *     // ... the filter for the Drivers we want to count
     *   }
     * })
    **/
    count<T extends DriverCountArgs>(
      args?: Subset<T, DriverCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriverCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriverAggregateArgs>(args: Subset<T, DriverAggregateArgs>): Prisma.PrismaPromise<GetDriverAggregateType<T>>

    /**
     * Group by Driver.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriverGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriverGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriverGroupByArgs['orderBy'] }
        : { orderBy?: DriverGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriverGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriverGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Driver model
   */
  readonly fields: DriverFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Driver.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DriverClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends Driver$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, Driver$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Driver$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tripLogs<T extends Driver$tripLogsArgs<ExtArgs> = {}>(args?: Subset<T, Driver$tripLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    locationUpdates<T extends Driver$locationUpdatesArgs<ExtArgs> = {}>(args?: Subset<T, Driver$locationUpdatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Driver model
   */
  interface DriverFieldRefs {
    readonly id: FieldRef<"Driver", 'String'>
    readonly userId: FieldRef<"Driver", 'String'>
    readonly companyId: FieldRef<"Driver", 'String'>
    readonly vehicleId: FieldRef<"Driver", 'String'>
    readonly firstName: FieldRef<"Driver", 'String'>
    readonly lastName: FieldRef<"Driver", 'String'>
    readonly taxiDriverLicense: FieldRef<"Driver", 'String'>
    readonly licenseExpiry: FieldRef<"Driver", 'DateTime'>
    readonly address: FieldRef<"Driver", 'String'>
    readonly phone: FieldRef<"Driver", 'String'>
    readonly email: FieldRef<"Driver", 'String'>
    readonly picture: FieldRef<"Driver", 'String'>
    readonly status: FieldRef<"Driver", 'DriverStatus'>
    readonly isOnline: FieldRef<"Driver", 'Boolean'>
    readonly currentLatitude: FieldRef<"Driver", 'Float'>
    readonly currentLongitude: FieldRef<"Driver", 'Float'>
    readonly lastLocationUpdate: FieldRef<"Driver", 'DateTime'>
    readonly createdAt: FieldRef<"Driver", 'DateTime'>
    readonly updatedAt: FieldRef<"Driver", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Driver findUnique
   */
  export type DriverFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findUniqueOrThrow
   */
  export type DriverFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver findFirst
   */
  export type DriverFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findFirstOrThrow
   */
  export type DriverFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Driver to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Drivers.
     */
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver findMany
   */
  export type DriverFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter, which Drivers to fetch.
     */
    where?: DriverWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Drivers to fetch.
     */
    orderBy?: DriverOrderByWithRelationInput | DriverOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Drivers.
     */
    cursor?: DriverWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Drivers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Drivers.
     */
    skip?: number
    distinct?: DriverScalarFieldEnum | DriverScalarFieldEnum[]
  }

  /**
   * Driver create
   */
  export type DriverCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to create a Driver.
     */
    data: XOR<DriverCreateInput, DriverUncheckedCreateInput>
  }

  /**
   * Driver createMany
   */
  export type DriverCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
  }

  /**
   * Driver createManyAndReturn
   */
  export type DriverCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to create many Drivers.
     */
    data: DriverCreateManyInput | DriverCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver update
   */
  export type DriverUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The data needed to update a Driver.
     */
    data: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
    /**
     * Choose, which Driver to update.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver updateMany
   */
  export type DriverUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
  }

  /**
   * Driver updateManyAndReturn
   */
  export type DriverUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * The data used to update Drivers.
     */
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyInput>
    /**
     * Filter which Drivers to update
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Driver upsert
   */
  export type DriverUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * The filter to search for the Driver to update in case it exists.
     */
    where: DriverWhereUniqueInput
    /**
     * In case the Driver found by the `where` argument doesn't exist, create a new Driver with this data.
     */
    create: XOR<DriverCreateInput, DriverUncheckedCreateInput>
    /**
     * In case the Driver was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DriverUpdateInput, DriverUncheckedUpdateInput>
  }

  /**
   * Driver delete
   */
  export type DriverDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    /**
     * Filter which Driver to delete.
     */
    where: DriverWhereUniqueInput
  }

  /**
   * Driver deleteMany
   */
  export type DriverDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Drivers to delete
     */
    where?: DriverWhereInput
    /**
     * Limit how many Drivers to delete.
     */
    limit?: number
  }

  /**
   * Driver.vehicle
   */
  export type Driver$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * Driver.bookings
   */
  export type Driver$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Driver.tripLogs
   */
  export type Driver$tripLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    where?: TripLogWhereInput
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    cursor?: TripLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripLogScalarFieldEnum | TripLogScalarFieldEnum[]
  }

  /**
   * Driver.locationUpdates
   */
  export type Driver$locationUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    where?: LocationUpdateWhereInput
    orderBy?: LocationUpdateOrderByWithRelationInput | LocationUpdateOrderByWithRelationInput[]
    cursor?: LocationUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LocationUpdateScalarFieldEnum | LocationUpdateScalarFieldEnum[]
  }

  /**
   * Driver without action
   */
  export type DriverDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
  }


  /**
   * Model Tariff
   */

  export type AggregateTariff = {
    _count: TariffCountAggregateOutputType | null
    _avg: TariffAvgAggregateOutputType | null
    _sum: TariffSumAggregateOutputType | null
    _min: TariffMinAggregateOutputType | null
    _max: TariffMaxAggregateOutputType | null
  }

  export type TariffAvgAggregateOutputType = {
    startPrice: number | null
    pricePerKm: number | null
    pricePerMinute: number | null
    nightSurcharge: number | null
    weekendSurcharge: number | null
  }

  export type TariffSumAggregateOutputType = {
    startPrice: number | null
    pricePerKm: number | null
    pricePerMinute: number | null
    nightSurcharge: number | null
    weekendSurcharge: number | null
  }

  export type TariffMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    vehicleId: string | null
    name: string | null
    code: string | null
    type: $Enums.TariffType | null
    startPrice: number | null
    pricePerKm: number | null
    pricePerMinute: number | null
    nightSurcharge: number | null
    weekendSurcharge: number | null
    isActive: boolean | null
    nightStartTime: string | null
    nightEndTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    vehicleId: string | null
    name: string | null
    code: string | null
    type: $Enums.TariffType | null
    startPrice: number | null
    pricePerKm: number | null
    pricePerMinute: number | null
    nightSurcharge: number | null
    weekendSurcharge: number | null
    isActive: boolean | null
    nightStartTime: string | null
    nightEndTime: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TariffCountAggregateOutputType = {
    id: number
    companyId: number
    vehicleId: number
    name: number
    code: number
    type: number
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge: number
    weekendSurcharge: number
    isActive: number
    nightStartTime: number
    nightEndTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TariffAvgAggregateInputType = {
    startPrice?: true
    pricePerKm?: true
    pricePerMinute?: true
    nightSurcharge?: true
    weekendSurcharge?: true
  }

  export type TariffSumAggregateInputType = {
    startPrice?: true
    pricePerKm?: true
    pricePerMinute?: true
    nightSurcharge?: true
    weekendSurcharge?: true
  }

  export type TariffMinAggregateInputType = {
    id?: true
    companyId?: true
    vehicleId?: true
    name?: true
    code?: true
    type?: true
    startPrice?: true
    pricePerKm?: true
    pricePerMinute?: true
    nightSurcharge?: true
    weekendSurcharge?: true
    isActive?: true
    nightStartTime?: true
    nightEndTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffMaxAggregateInputType = {
    id?: true
    companyId?: true
    vehicleId?: true
    name?: true
    code?: true
    type?: true
    startPrice?: true
    pricePerKm?: true
    pricePerMinute?: true
    nightSurcharge?: true
    weekendSurcharge?: true
    isActive?: true
    nightStartTime?: true
    nightEndTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TariffCountAggregateInputType = {
    id?: true
    companyId?: true
    vehicleId?: true
    name?: true
    code?: true
    type?: true
    startPrice?: true
    pricePerKm?: true
    pricePerMinute?: true
    nightSurcharge?: true
    weekendSurcharge?: true
    isActive?: true
    nightStartTime?: true
    nightEndTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TariffAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tariff to aggregate.
     */
    where?: TariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tariffs to fetch.
     */
    orderBy?: TariffOrderByWithRelationInput | TariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tariffs
    **/
    _count?: true | TariffCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TariffAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TariffSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TariffMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TariffMaxAggregateInputType
  }

  export type GetTariffAggregateType<T extends TariffAggregateArgs> = {
        [P in keyof T & keyof AggregateTariff]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTariff[P]>
      : GetScalarType<T[P], AggregateTariff[P]>
  }




  export type TariffGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TariffWhereInput
    orderBy?: TariffOrderByWithAggregationInput | TariffOrderByWithAggregationInput[]
    by: TariffScalarFieldEnum[] | TariffScalarFieldEnum
    having?: TariffScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TariffCountAggregateInputType | true
    _avg?: TariffAvgAggregateInputType
    _sum?: TariffSumAggregateInputType
    _min?: TariffMinAggregateInputType
    _max?: TariffMaxAggregateInputType
  }

  export type TariffGroupByOutputType = {
    id: string
    companyId: string
    vehicleId: string | null
    name: string
    code: string
    type: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge: number
    weekendSurcharge: number
    isActive: boolean
    nightStartTime: string | null
    nightEndTime: string | null
    createdAt: Date
    updatedAt: Date
    _count: TariffCountAggregateOutputType | null
    _avg: TariffAvgAggregateOutputType | null
    _sum: TariffSumAggregateOutputType | null
    _min: TariffMinAggregateOutputType | null
    _max: TariffMaxAggregateOutputType | null
  }

  type GetTariffGroupByPayload<T extends TariffGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TariffGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TariffGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TariffGroupByOutputType[P]>
            : GetScalarType<T[P], TariffGroupByOutputType[P]>
        }
      >
    >


  export type TariffSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    vehicleId?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    startPrice?: boolean
    pricePerKm?: boolean
    pricePerMinute?: boolean
    nightSurcharge?: boolean
    weekendSurcharge?: boolean
    isActive?: boolean
    nightStartTime?: boolean
    nightEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Tariff$vehicleArgs<ExtArgs>
    bookings?: boolean | Tariff$bookingsArgs<ExtArgs>
    _count?: boolean | TariffCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tariff"]>

  export type TariffSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    vehicleId?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    startPrice?: boolean
    pricePerKm?: boolean
    pricePerMinute?: boolean
    nightSurcharge?: boolean
    weekendSurcharge?: boolean
    isActive?: boolean
    nightStartTime?: boolean
    nightEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Tariff$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["tariff"]>

  export type TariffSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    vehicleId?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    startPrice?: boolean
    pricePerKm?: boolean
    pricePerMinute?: boolean
    nightSurcharge?: boolean
    weekendSurcharge?: boolean
    isActive?: boolean
    nightStartTime?: boolean
    nightEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Tariff$vehicleArgs<ExtArgs>
  }, ExtArgs["result"]["tariff"]>

  export type TariffSelectScalar = {
    id?: boolean
    companyId?: boolean
    vehicleId?: boolean
    name?: boolean
    code?: boolean
    type?: boolean
    startPrice?: boolean
    pricePerKm?: boolean
    pricePerMinute?: boolean
    nightSurcharge?: boolean
    weekendSurcharge?: boolean
    isActive?: boolean
    nightStartTime?: boolean
    nightEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TariffOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "vehicleId" | "name" | "code" | "type" | "startPrice" | "pricePerKm" | "pricePerMinute" | "nightSurcharge" | "weekendSurcharge" | "isActive" | "nightStartTime" | "nightEndTime" | "createdAt" | "updatedAt", ExtArgs["result"]["tariff"]>
  export type TariffInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Tariff$vehicleArgs<ExtArgs>
    bookings?: boolean | Tariff$bookingsArgs<ExtArgs>
    _count?: boolean | TariffCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TariffIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Tariff$vehicleArgs<ExtArgs>
  }
  export type TariffIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | Tariff$vehicleArgs<ExtArgs>
  }

  export type $TariffPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tariff"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      vehicleId: string | null
      name: string
      code: string
      type: $Enums.TariffType
      startPrice: number
      pricePerKm: number
      pricePerMinute: number
      nightSurcharge: number
      weekendSurcharge: number
      isActive: boolean
      nightStartTime: string | null
      nightEndTime: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tariff"]>
    composites: {}
  }

  type TariffGetPayload<S extends boolean | null | undefined | TariffDefaultArgs> = $Result.GetResult<Prisma.$TariffPayload, S>

  type TariffCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TariffFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TariffCountAggregateInputType | true
    }

  export interface TariffDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tariff'], meta: { name: 'Tariff' } }
    /**
     * Find zero or one Tariff that matches the filter.
     * @param {TariffFindUniqueArgs} args - Arguments to find a Tariff
     * @example
     * // Get one Tariff
     * const tariff = await prisma.tariff.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TariffFindUniqueArgs>(args: SelectSubset<T, TariffFindUniqueArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tariff that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TariffFindUniqueOrThrowArgs} args - Arguments to find a Tariff
     * @example
     * // Get one Tariff
     * const tariff = await prisma.tariff.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TariffFindUniqueOrThrowArgs>(args: SelectSubset<T, TariffFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tariff that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffFindFirstArgs} args - Arguments to find a Tariff
     * @example
     * // Get one Tariff
     * const tariff = await prisma.tariff.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TariffFindFirstArgs>(args?: SelectSubset<T, TariffFindFirstArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tariff that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffFindFirstOrThrowArgs} args - Arguments to find a Tariff
     * @example
     * // Get one Tariff
     * const tariff = await prisma.tariff.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TariffFindFirstOrThrowArgs>(args?: SelectSubset<T, TariffFindFirstOrThrowArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tariffs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tariffs
     * const tariffs = await prisma.tariff.findMany()
     * 
     * // Get first 10 Tariffs
     * const tariffs = await prisma.tariff.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tariffWithIdOnly = await prisma.tariff.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TariffFindManyArgs>(args?: SelectSubset<T, TariffFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tariff.
     * @param {TariffCreateArgs} args - Arguments to create a Tariff.
     * @example
     * // Create one Tariff
     * const Tariff = await prisma.tariff.create({
     *   data: {
     *     // ... data to create a Tariff
     *   }
     * })
     * 
     */
    create<T extends TariffCreateArgs>(args: SelectSubset<T, TariffCreateArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tariffs.
     * @param {TariffCreateManyArgs} args - Arguments to create many Tariffs.
     * @example
     * // Create many Tariffs
     * const tariff = await prisma.tariff.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TariffCreateManyArgs>(args?: SelectSubset<T, TariffCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tariffs and returns the data saved in the database.
     * @param {TariffCreateManyAndReturnArgs} args - Arguments to create many Tariffs.
     * @example
     * // Create many Tariffs
     * const tariff = await prisma.tariff.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tariffs and only return the `id`
     * const tariffWithIdOnly = await prisma.tariff.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TariffCreateManyAndReturnArgs>(args?: SelectSubset<T, TariffCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tariff.
     * @param {TariffDeleteArgs} args - Arguments to delete one Tariff.
     * @example
     * // Delete one Tariff
     * const Tariff = await prisma.tariff.delete({
     *   where: {
     *     // ... filter to delete one Tariff
     *   }
     * })
     * 
     */
    delete<T extends TariffDeleteArgs>(args: SelectSubset<T, TariffDeleteArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tariff.
     * @param {TariffUpdateArgs} args - Arguments to update one Tariff.
     * @example
     * // Update one Tariff
     * const tariff = await prisma.tariff.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TariffUpdateArgs>(args: SelectSubset<T, TariffUpdateArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tariffs.
     * @param {TariffDeleteManyArgs} args - Arguments to filter Tariffs to delete.
     * @example
     * // Delete a few Tariffs
     * const { count } = await prisma.tariff.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TariffDeleteManyArgs>(args?: SelectSubset<T, TariffDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tariffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tariffs
     * const tariff = await prisma.tariff.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TariffUpdateManyArgs>(args: SelectSubset<T, TariffUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tariffs and returns the data updated in the database.
     * @param {TariffUpdateManyAndReturnArgs} args - Arguments to update many Tariffs.
     * @example
     * // Update many Tariffs
     * const tariff = await prisma.tariff.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tariffs and only return the `id`
     * const tariffWithIdOnly = await prisma.tariff.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TariffUpdateManyAndReturnArgs>(args: SelectSubset<T, TariffUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tariff.
     * @param {TariffUpsertArgs} args - Arguments to update or create a Tariff.
     * @example
     * // Update or create a Tariff
     * const tariff = await prisma.tariff.upsert({
     *   create: {
     *     // ... data to create a Tariff
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tariff we want to update
     *   }
     * })
     */
    upsert<T extends TariffUpsertArgs>(args: SelectSubset<T, TariffUpsertArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tariffs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffCountArgs} args - Arguments to filter Tariffs to count.
     * @example
     * // Count the number of Tariffs
     * const count = await prisma.tariff.count({
     *   where: {
     *     // ... the filter for the Tariffs we want to count
     *   }
     * })
    **/
    count<T extends TariffCountArgs>(
      args?: Subset<T, TariffCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TariffCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tariff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TariffAggregateArgs>(args: Subset<T, TariffAggregateArgs>): Prisma.PrismaPromise<GetTariffAggregateType<T>>

    /**
     * Group by Tariff.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TariffGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TariffGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TariffGroupByArgs['orderBy'] }
        : { orderBy?: TariffGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TariffGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTariffGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tariff model
   */
  readonly fields: TariffFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tariff.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TariffClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends Tariff$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, Tariff$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bookings<T extends Tariff$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Tariff$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tariff model
   */
  interface TariffFieldRefs {
    readonly id: FieldRef<"Tariff", 'String'>
    readonly companyId: FieldRef<"Tariff", 'String'>
    readonly vehicleId: FieldRef<"Tariff", 'String'>
    readonly name: FieldRef<"Tariff", 'String'>
    readonly code: FieldRef<"Tariff", 'String'>
    readonly type: FieldRef<"Tariff", 'TariffType'>
    readonly startPrice: FieldRef<"Tariff", 'Float'>
    readonly pricePerKm: FieldRef<"Tariff", 'Float'>
    readonly pricePerMinute: FieldRef<"Tariff", 'Float'>
    readonly nightSurcharge: FieldRef<"Tariff", 'Float'>
    readonly weekendSurcharge: FieldRef<"Tariff", 'Float'>
    readonly isActive: FieldRef<"Tariff", 'Boolean'>
    readonly nightStartTime: FieldRef<"Tariff", 'String'>
    readonly nightEndTime: FieldRef<"Tariff", 'String'>
    readonly createdAt: FieldRef<"Tariff", 'DateTime'>
    readonly updatedAt: FieldRef<"Tariff", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tariff findUnique
   */
  export type TariffFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * Filter, which Tariff to fetch.
     */
    where: TariffWhereUniqueInput
  }

  /**
   * Tariff findUniqueOrThrow
   */
  export type TariffFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * Filter, which Tariff to fetch.
     */
    where: TariffWhereUniqueInput
  }

  /**
   * Tariff findFirst
   */
  export type TariffFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * Filter, which Tariff to fetch.
     */
    where?: TariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tariffs to fetch.
     */
    orderBy?: TariffOrderByWithRelationInput | TariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tariffs.
     */
    cursor?: TariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tariffs.
     */
    distinct?: TariffScalarFieldEnum | TariffScalarFieldEnum[]
  }

  /**
   * Tariff findFirstOrThrow
   */
  export type TariffFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * Filter, which Tariff to fetch.
     */
    where?: TariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tariffs to fetch.
     */
    orderBy?: TariffOrderByWithRelationInput | TariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tariffs.
     */
    cursor?: TariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tariffs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tariffs.
     */
    distinct?: TariffScalarFieldEnum | TariffScalarFieldEnum[]
  }

  /**
   * Tariff findMany
   */
  export type TariffFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * Filter, which Tariffs to fetch.
     */
    where?: TariffWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tariffs to fetch.
     */
    orderBy?: TariffOrderByWithRelationInput | TariffOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tariffs.
     */
    cursor?: TariffWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tariffs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tariffs.
     */
    skip?: number
    distinct?: TariffScalarFieldEnum | TariffScalarFieldEnum[]
  }

  /**
   * Tariff create
   */
  export type TariffCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * The data needed to create a Tariff.
     */
    data: XOR<TariffCreateInput, TariffUncheckedCreateInput>
  }

  /**
   * Tariff createMany
   */
  export type TariffCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tariffs.
     */
    data: TariffCreateManyInput | TariffCreateManyInput[]
  }

  /**
   * Tariff createManyAndReturn
   */
  export type TariffCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * The data used to create many Tariffs.
     */
    data: TariffCreateManyInput | TariffCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tariff update
   */
  export type TariffUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * The data needed to update a Tariff.
     */
    data: XOR<TariffUpdateInput, TariffUncheckedUpdateInput>
    /**
     * Choose, which Tariff to update.
     */
    where: TariffWhereUniqueInput
  }

  /**
   * Tariff updateMany
   */
  export type TariffUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tariffs.
     */
    data: XOR<TariffUpdateManyMutationInput, TariffUncheckedUpdateManyInput>
    /**
     * Filter which Tariffs to update
     */
    where?: TariffWhereInput
    /**
     * Limit how many Tariffs to update.
     */
    limit?: number
  }

  /**
   * Tariff updateManyAndReturn
   */
  export type TariffUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * The data used to update Tariffs.
     */
    data: XOR<TariffUpdateManyMutationInput, TariffUncheckedUpdateManyInput>
    /**
     * Filter which Tariffs to update
     */
    where?: TariffWhereInput
    /**
     * Limit how many Tariffs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Tariff upsert
   */
  export type TariffUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * The filter to search for the Tariff to update in case it exists.
     */
    where: TariffWhereUniqueInput
    /**
     * In case the Tariff found by the `where` argument doesn't exist, create a new Tariff with this data.
     */
    create: XOR<TariffCreateInput, TariffUncheckedCreateInput>
    /**
     * In case the Tariff was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TariffUpdateInput, TariffUncheckedUpdateInput>
  }

  /**
   * Tariff delete
   */
  export type TariffDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
    /**
     * Filter which Tariff to delete.
     */
    where: TariffWhereUniqueInput
  }

  /**
   * Tariff deleteMany
   */
  export type TariffDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tariffs to delete
     */
    where?: TariffWhereInput
    /**
     * Limit how many Tariffs to delete.
     */
    limit?: number
  }

  /**
   * Tariff.vehicle
   */
  export type Tariff$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * Tariff.bookings
   */
  export type Tariff$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Tariff without action
   */
  export type TariffDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tariff
     */
    select?: TariffSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tariff
     */
    omit?: TariffOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TariffInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    pickupLatitude: number | null
    pickupLongitude: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    estimatedPrice: number | null
    finalPrice: number | null
    estimatedDuration: number | null
    actualDuration: number | null
    distance: number | null
  }

  export type BookingSumAggregateOutputType = {
    pickupLatitude: number | null
    pickupLongitude: number | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    estimatedPrice: number | null
    finalPrice: number | null
    estimatedDuration: number | null
    actualDuration: number | null
    distance: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    riderId: string | null
    companyId: string | null
    driverId: string | null
    vehicleId: string | null
    tariffId: string | null
    pickupLatitude: number | null
    pickupLongitude: number | null
    pickupAddress: string | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    destinationAddress: string | null
    estimatedPrice: number | null
    finalPrice: number | null
    estimatedDuration: number | null
    actualDuration: number | null
    distance: number | null
    riderName: string | null
    riderPhone: string | null
    notes: string | null
    scheduledTime: Date | null
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    cancelledAt: Date | null
    status: $Enums.BookingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    riderId: string | null
    companyId: string | null
    driverId: string | null
    vehicleId: string | null
    tariffId: string | null
    pickupLatitude: number | null
    pickupLongitude: number | null
    pickupAddress: string | null
    destinationLatitude: number | null
    destinationLongitude: number | null
    destinationAddress: string | null
    estimatedPrice: number | null
    finalPrice: number | null
    estimatedDuration: number | null
    actualDuration: number | null
    distance: number | null
    riderName: string | null
    riderPhone: string | null
    notes: string | null
    scheduledTime: Date | null
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    cancelledAt: Date | null
    status: $Enums.BookingStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    riderId: number
    companyId: number
    driverId: number
    vehicleId: number
    tariffId: number
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: number
    destinationLatitude: number
    destinationLongitude: number
    destinationAddress: number
    estimatedPrice: number
    finalPrice: number
    estimatedDuration: number
    actualDuration: number
    distance: number
    riderName: number
    riderPhone: number
    notes: number
    scheduledTime: number
    acceptedAt: number
    startedAt: number
    completedAt: number
    cancelledAt: number
    status: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    pickupLatitude?: true
    pickupLongitude?: true
    destinationLatitude?: true
    destinationLongitude?: true
    estimatedPrice?: true
    finalPrice?: true
    estimatedDuration?: true
    actualDuration?: true
    distance?: true
  }

  export type BookingSumAggregateInputType = {
    pickupLatitude?: true
    pickupLongitude?: true
    destinationLatitude?: true
    destinationLongitude?: true
    estimatedPrice?: true
    finalPrice?: true
    estimatedDuration?: true
    actualDuration?: true
    distance?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    riderId?: true
    companyId?: true
    driverId?: true
    vehicleId?: true
    tariffId?: true
    pickupLatitude?: true
    pickupLongitude?: true
    pickupAddress?: true
    destinationLatitude?: true
    destinationLongitude?: true
    destinationAddress?: true
    estimatedPrice?: true
    finalPrice?: true
    estimatedDuration?: true
    actualDuration?: true
    distance?: true
    riderName?: true
    riderPhone?: true
    notes?: true
    scheduledTime?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    cancelledAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    riderId?: true
    companyId?: true
    driverId?: true
    vehicleId?: true
    tariffId?: true
    pickupLatitude?: true
    pickupLongitude?: true
    pickupAddress?: true
    destinationLatitude?: true
    destinationLongitude?: true
    destinationAddress?: true
    estimatedPrice?: true
    finalPrice?: true
    estimatedDuration?: true
    actualDuration?: true
    distance?: true
    riderName?: true
    riderPhone?: true
    notes?: true
    scheduledTime?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    cancelledAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    riderId?: true
    companyId?: true
    driverId?: true
    vehicleId?: true
    tariffId?: true
    pickupLatitude?: true
    pickupLongitude?: true
    pickupAddress?: true
    destinationLatitude?: true
    destinationLongitude?: true
    destinationAddress?: true
    estimatedPrice?: true
    finalPrice?: true
    estimatedDuration?: true
    actualDuration?: true
    distance?: true
    riderName?: true
    riderPhone?: true
    notes?: true
    scheduledTime?: true
    acceptedAt?: true
    startedAt?: true
    completedAt?: true
    cancelledAt?: true
    status?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    riderId: string
    companyId: string
    driverId: string | null
    vehicleId: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude: number | null
    destinationLongitude: number | null
    destinationAddress: string | null
    estimatedPrice: number | null
    finalPrice: number | null
    estimatedDuration: number | null
    actualDuration: number | null
    distance: number | null
    riderName: string
    riderPhone: string
    notes: string | null
    scheduledTime: Date | null
    acceptedAt: Date | null
    startedAt: Date | null
    completedAt: Date | null
    cancelledAt: Date | null
    status: $Enums.BookingStatus
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riderId?: boolean
    companyId?: boolean
    driverId?: boolean
    vehicleId?: boolean
    tariffId?: boolean
    pickupLatitude?: boolean
    pickupLongitude?: boolean
    pickupAddress?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    destinationAddress?: boolean
    estimatedPrice?: boolean
    finalPrice?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    distance?: boolean
    riderName?: boolean
    riderPhone?: boolean
    notes?: boolean
    scheduledTime?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rider?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    driver?: boolean | Booking$driverArgs<ExtArgs>
    vehicle?: boolean | Booking$vehicleArgs<ExtArgs>
    tariff?: boolean | TariffDefaultArgs<ExtArgs>
    tripLog?: boolean | Booking$tripLogArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riderId?: boolean
    companyId?: boolean
    driverId?: boolean
    vehicleId?: boolean
    tariffId?: boolean
    pickupLatitude?: boolean
    pickupLongitude?: boolean
    pickupAddress?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    destinationAddress?: boolean
    estimatedPrice?: boolean
    finalPrice?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    distance?: boolean
    riderName?: boolean
    riderPhone?: boolean
    notes?: boolean
    scheduledTime?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rider?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    driver?: boolean | Booking$driverArgs<ExtArgs>
    vehicle?: boolean | Booking$vehicleArgs<ExtArgs>
    tariff?: boolean | TariffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    riderId?: boolean
    companyId?: boolean
    driverId?: boolean
    vehicleId?: boolean
    tariffId?: boolean
    pickupLatitude?: boolean
    pickupLongitude?: boolean
    pickupAddress?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    destinationAddress?: boolean
    estimatedPrice?: boolean
    finalPrice?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    distance?: boolean
    riderName?: boolean
    riderPhone?: boolean
    notes?: boolean
    scheduledTime?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    rider?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    driver?: boolean | Booking$driverArgs<ExtArgs>
    vehicle?: boolean | Booking$vehicleArgs<ExtArgs>
    tariff?: boolean | TariffDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    riderId?: boolean
    companyId?: boolean
    driverId?: boolean
    vehicleId?: boolean
    tariffId?: boolean
    pickupLatitude?: boolean
    pickupLongitude?: boolean
    pickupAddress?: boolean
    destinationLatitude?: boolean
    destinationLongitude?: boolean
    destinationAddress?: boolean
    estimatedPrice?: boolean
    finalPrice?: boolean
    estimatedDuration?: boolean
    actualDuration?: boolean
    distance?: boolean
    riderName?: boolean
    riderPhone?: boolean
    notes?: boolean
    scheduledTime?: boolean
    acceptedAt?: boolean
    startedAt?: boolean
    completedAt?: boolean
    cancelledAt?: boolean
    status?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "riderId" | "companyId" | "driverId" | "vehicleId" | "tariffId" | "pickupLatitude" | "pickupLongitude" | "pickupAddress" | "destinationLatitude" | "destinationLongitude" | "destinationAddress" | "estimatedPrice" | "finalPrice" | "estimatedDuration" | "actualDuration" | "distance" | "riderName" | "riderPhone" | "notes" | "scheduledTime" | "acceptedAt" | "startedAt" | "completedAt" | "cancelledAt" | "status" | "createdAt" | "updatedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rider?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    driver?: boolean | Booking$driverArgs<ExtArgs>
    vehicle?: boolean | Booking$vehicleArgs<ExtArgs>
    tariff?: boolean | TariffDefaultArgs<ExtArgs>
    tripLog?: boolean | Booking$tripLogArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rider?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    driver?: boolean | Booking$driverArgs<ExtArgs>
    vehicle?: boolean | Booking$vehicleArgs<ExtArgs>
    tariff?: boolean | TariffDefaultArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    rider?: boolean | UserDefaultArgs<ExtArgs>
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    driver?: boolean | Booking$driverArgs<ExtArgs>
    vehicle?: boolean | Booking$vehicleArgs<ExtArgs>
    tariff?: boolean | TariffDefaultArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      rider: Prisma.$UserPayload<ExtArgs>
      company: Prisma.$CompanyPayload<ExtArgs>
      driver: Prisma.$DriverPayload<ExtArgs> | null
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
      tariff: Prisma.$TariffPayload<ExtArgs>
      tripLog: Prisma.$TripLogPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      riderId: string
      companyId: string
      driverId: string | null
      vehicleId: string | null
      tariffId: string
      pickupLatitude: number
      pickupLongitude: number
      pickupAddress: string
      destinationLatitude: number | null
      destinationLongitude: number | null
      destinationAddress: string | null
      estimatedPrice: number | null
      finalPrice: number | null
      estimatedDuration: number | null
      actualDuration: number | null
      distance: number | null
      riderName: string
      riderPhone: string
      notes: string | null
      scheduledTime: Date | null
      acceptedAt: Date | null
      startedAt: Date | null
      completedAt: Date | null
      cancelledAt: Date | null
      status: $Enums.BookingStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    rider<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    driver<T extends Booking$driverArgs<ExtArgs> = {}>(args?: Subset<T, Booking$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends Booking$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, Booking$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    tariff<T extends TariffDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TariffDefaultArgs<ExtArgs>>): Prisma__TariffClient<$Result.GetResult<Prisma.$TariffPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tripLog<T extends Booking$tripLogArgs<ExtArgs> = {}>(args?: Subset<T, Booking$tripLogArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly riderId: FieldRef<"Booking", 'String'>
    readonly companyId: FieldRef<"Booking", 'String'>
    readonly driverId: FieldRef<"Booking", 'String'>
    readonly vehicleId: FieldRef<"Booking", 'String'>
    readonly tariffId: FieldRef<"Booking", 'String'>
    readonly pickupLatitude: FieldRef<"Booking", 'Float'>
    readonly pickupLongitude: FieldRef<"Booking", 'Float'>
    readonly pickupAddress: FieldRef<"Booking", 'String'>
    readonly destinationLatitude: FieldRef<"Booking", 'Float'>
    readonly destinationLongitude: FieldRef<"Booking", 'Float'>
    readonly destinationAddress: FieldRef<"Booking", 'String'>
    readonly estimatedPrice: FieldRef<"Booking", 'Float'>
    readonly finalPrice: FieldRef<"Booking", 'Float'>
    readonly estimatedDuration: FieldRef<"Booking", 'Int'>
    readonly actualDuration: FieldRef<"Booking", 'Int'>
    readonly distance: FieldRef<"Booking", 'Float'>
    readonly riderName: FieldRef<"Booking", 'String'>
    readonly riderPhone: FieldRef<"Booking", 'String'>
    readonly notes: FieldRef<"Booking", 'String'>
    readonly scheduledTime: FieldRef<"Booking", 'DateTime'>
    readonly acceptedAt: FieldRef<"Booking", 'DateTime'>
    readonly startedAt: FieldRef<"Booking", 'DateTime'>
    readonly completedAt: FieldRef<"Booking", 'DateTime'>
    readonly cancelledAt: FieldRef<"Booking", 'DateTime'>
    readonly status: FieldRef<"Booking", 'BookingStatus'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.driver
   */
  export type Booking$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * Booking.vehicle
   */
  export type Booking$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * Booking.tripLog
   */
  export type Booking$tripLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    where?: TripLogWhereInput
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model TripLog
   */

  export type AggregateTripLog = {
    _count: TripLogCountAggregateOutputType | null
    _avg: TripLogAvgAggregateOutputType | null
    _sum: TripLogSumAggregateOutputType | null
    _min: TripLogMinAggregateOutputType | null
    _max: TripLogMaxAggregateOutputType | null
  }

  export type TripLogAvgAggregateOutputType = {
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    distance: number | null
    duration: number | null
    finalPrice: number | null
  }

  export type TripLogSumAggregateOutputType = {
    startLatitude: number | null
    startLongitude: number | null
    endLatitude: number | null
    endLongitude: number | null
    distance: number | null
    duration: number | null
    finalPrice: number | null
  }

  export type TripLogMinAggregateOutputType = {
    id: string | null
    parentId: string | null
    logType: $Enums.LogType | null
    companyId: string | null
    vehicleId: string | null
    driverId: string | null
    userId: string | null
    bookingId: string | null
    startLatitude: number | null
    startLongitude: number | null
    startAddress: string | null
    endLatitude: number | null
    endLongitude: number | null
    endAddress: string | null
    distance: number | null
    duration: number | null
    finalPrice: number | null
    tariffUsed: string | null
    governmentTripId: string | null
    tripStartApiSent: boolean | null
    tripEndApiSent: boolean | null
    apiErrorLog: string | null
    tripStartTime: Date | null
    tripEndTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripLogMaxAggregateOutputType = {
    id: string | null
    parentId: string | null
    logType: $Enums.LogType | null
    companyId: string | null
    vehicleId: string | null
    driverId: string | null
    userId: string | null
    bookingId: string | null
    startLatitude: number | null
    startLongitude: number | null
    startAddress: string | null
    endLatitude: number | null
    endLongitude: number | null
    endAddress: string | null
    distance: number | null
    duration: number | null
    finalPrice: number | null
    tariffUsed: string | null
    governmentTripId: string | null
    tripStartApiSent: boolean | null
    tripEndApiSent: boolean | null
    apiErrorLog: string | null
    tripStartTime: Date | null
    tripEndTime: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TripLogCountAggregateOutputType = {
    id: number
    parentId: number
    logType: number
    companyId: number
    vehicleId: number
    driverId: number
    userId: number
    bookingId: number
    startLatitude: number
    startLongitude: number
    startAddress: number
    endLatitude: number
    endLongitude: number
    endAddress: number
    distance: number
    duration: number
    finalPrice: number
    tariffUsed: number
    governmentTripId: number
    tripStartApiSent: number
    tripEndApiSent: number
    apiErrorLog: number
    logDetails: number
    tripStartTime: number
    tripEndTime: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TripLogAvgAggregateInputType = {
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    distance?: true
    duration?: true
    finalPrice?: true
  }

  export type TripLogSumAggregateInputType = {
    startLatitude?: true
    startLongitude?: true
    endLatitude?: true
    endLongitude?: true
    distance?: true
    duration?: true
    finalPrice?: true
  }

  export type TripLogMinAggregateInputType = {
    id?: true
    parentId?: true
    logType?: true
    companyId?: true
    vehicleId?: true
    driverId?: true
    userId?: true
    bookingId?: true
    startLatitude?: true
    startLongitude?: true
    startAddress?: true
    endLatitude?: true
    endLongitude?: true
    endAddress?: true
    distance?: true
    duration?: true
    finalPrice?: true
    tariffUsed?: true
    governmentTripId?: true
    tripStartApiSent?: true
    tripEndApiSent?: true
    apiErrorLog?: true
    tripStartTime?: true
    tripEndTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripLogMaxAggregateInputType = {
    id?: true
    parentId?: true
    logType?: true
    companyId?: true
    vehicleId?: true
    driverId?: true
    userId?: true
    bookingId?: true
    startLatitude?: true
    startLongitude?: true
    startAddress?: true
    endLatitude?: true
    endLongitude?: true
    endAddress?: true
    distance?: true
    duration?: true
    finalPrice?: true
    tariffUsed?: true
    governmentTripId?: true
    tripStartApiSent?: true
    tripEndApiSent?: true
    apiErrorLog?: true
    tripStartTime?: true
    tripEndTime?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TripLogCountAggregateInputType = {
    id?: true
    parentId?: true
    logType?: true
    companyId?: true
    vehicleId?: true
    driverId?: true
    userId?: true
    bookingId?: true
    startLatitude?: true
    startLongitude?: true
    startAddress?: true
    endLatitude?: true
    endLongitude?: true
    endAddress?: true
    distance?: true
    duration?: true
    finalPrice?: true
    tariffUsed?: true
    governmentTripId?: true
    tripStartApiSent?: true
    tripEndApiSent?: true
    apiErrorLog?: true
    logDetails?: true
    tripStartTime?: true
    tripEndTime?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TripLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripLog to aggregate.
     */
    where?: TripLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripLogs to fetch.
     */
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TripLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TripLogs
    **/
    _count?: true | TripLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TripLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TripLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TripLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TripLogMaxAggregateInputType
  }

  export type GetTripLogAggregateType<T extends TripLogAggregateArgs> = {
        [P in keyof T & keyof AggregateTripLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTripLog[P]>
      : GetScalarType<T[P], AggregateTripLog[P]>
  }




  export type TripLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TripLogWhereInput
    orderBy?: TripLogOrderByWithAggregationInput | TripLogOrderByWithAggregationInput[]
    by: TripLogScalarFieldEnum[] | TripLogScalarFieldEnum
    having?: TripLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TripLogCountAggregateInputType | true
    _avg?: TripLogAvgAggregateInputType
    _sum?: TripLogSumAggregateInputType
    _min?: TripLogMinAggregateInputType
    _max?: TripLogMaxAggregateInputType
  }

  export type TripLogGroupByOutputType = {
    id: string
    parentId: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId: string | null
    driverId: string | null
    userId: string | null
    bookingId: string | null
    startLatitude: number | null
    startLongitude: number | null
    startAddress: string | null
    endLatitude: number | null
    endLongitude: number | null
    endAddress: string | null
    distance: number | null
    duration: number | null
    finalPrice: number | null
    tariffUsed: string | null
    governmentTripId: string | null
    tripStartApiSent: boolean
    tripEndApiSent: boolean
    apiErrorLog: string | null
    logDetails: JsonValue | null
    tripStartTime: Date | null
    tripEndTime: Date | null
    createdAt: Date
    updatedAt: Date
    _count: TripLogCountAggregateOutputType | null
    _avg: TripLogAvgAggregateOutputType | null
    _sum: TripLogSumAggregateOutputType | null
    _min: TripLogMinAggregateOutputType | null
    _max: TripLogMaxAggregateOutputType | null
  }

  type GetTripLogGroupByPayload<T extends TripLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TripLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TripLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TripLogGroupByOutputType[P]>
            : GetScalarType<T[P], TripLogGroupByOutputType[P]>
        }
      >
    >


  export type TripLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    logType?: boolean
    companyId?: boolean
    vehicleId?: boolean
    driverId?: boolean
    userId?: boolean
    bookingId?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    startAddress?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    endAddress?: boolean
    distance?: boolean
    duration?: boolean
    finalPrice?: boolean
    tariffUsed?: boolean
    governmentTripId?: boolean
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: boolean
    logDetails?: boolean
    tripStartTime?: boolean
    tripEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | TripLog$vehicleArgs<ExtArgs>
    driver?: boolean | TripLog$driverArgs<ExtArgs>
    user?: boolean | TripLog$userArgs<ExtArgs>
    booking?: boolean | TripLog$bookingArgs<ExtArgs>
    parent?: boolean | TripLog$parentArgs<ExtArgs>
    children?: boolean | TripLog$childrenArgs<ExtArgs>
    apiRequests?: boolean | TripLog$apiRequestsArgs<ExtArgs>
    _count?: boolean | TripLogCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tripLog"]>

  export type TripLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    logType?: boolean
    companyId?: boolean
    vehicleId?: boolean
    driverId?: boolean
    userId?: boolean
    bookingId?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    startAddress?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    endAddress?: boolean
    distance?: boolean
    duration?: boolean
    finalPrice?: boolean
    tariffUsed?: boolean
    governmentTripId?: boolean
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: boolean
    logDetails?: boolean
    tripStartTime?: boolean
    tripEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | TripLog$vehicleArgs<ExtArgs>
    driver?: boolean | TripLog$driverArgs<ExtArgs>
    user?: boolean | TripLog$userArgs<ExtArgs>
    booking?: boolean | TripLog$bookingArgs<ExtArgs>
    parent?: boolean | TripLog$parentArgs<ExtArgs>
  }, ExtArgs["result"]["tripLog"]>

  export type TripLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    parentId?: boolean
    logType?: boolean
    companyId?: boolean
    vehicleId?: boolean
    driverId?: boolean
    userId?: boolean
    bookingId?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    startAddress?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    endAddress?: boolean
    distance?: boolean
    duration?: boolean
    finalPrice?: boolean
    tariffUsed?: boolean
    governmentTripId?: boolean
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: boolean
    logDetails?: boolean
    tripStartTime?: boolean
    tripEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | TripLog$vehicleArgs<ExtArgs>
    driver?: boolean | TripLog$driverArgs<ExtArgs>
    user?: boolean | TripLog$userArgs<ExtArgs>
    booking?: boolean | TripLog$bookingArgs<ExtArgs>
    parent?: boolean | TripLog$parentArgs<ExtArgs>
  }, ExtArgs["result"]["tripLog"]>

  export type TripLogSelectScalar = {
    id?: boolean
    parentId?: boolean
    logType?: boolean
    companyId?: boolean
    vehicleId?: boolean
    driverId?: boolean
    userId?: boolean
    bookingId?: boolean
    startLatitude?: boolean
    startLongitude?: boolean
    startAddress?: boolean
    endLatitude?: boolean
    endLongitude?: boolean
    endAddress?: boolean
    distance?: boolean
    duration?: boolean
    finalPrice?: boolean
    tariffUsed?: boolean
    governmentTripId?: boolean
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: boolean
    logDetails?: boolean
    tripStartTime?: boolean
    tripEndTime?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TripLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "parentId" | "logType" | "companyId" | "vehicleId" | "driverId" | "userId" | "bookingId" | "startLatitude" | "startLongitude" | "startAddress" | "endLatitude" | "endLongitude" | "endAddress" | "distance" | "duration" | "finalPrice" | "tariffUsed" | "governmentTripId" | "tripStartApiSent" | "tripEndApiSent" | "apiErrorLog" | "logDetails" | "tripStartTime" | "tripEndTime" | "createdAt" | "updatedAt", ExtArgs["result"]["tripLog"]>
  export type TripLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | TripLog$vehicleArgs<ExtArgs>
    driver?: boolean | TripLog$driverArgs<ExtArgs>
    user?: boolean | TripLog$userArgs<ExtArgs>
    booking?: boolean | TripLog$bookingArgs<ExtArgs>
    parent?: boolean | TripLog$parentArgs<ExtArgs>
    children?: boolean | TripLog$childrenArgs<ExtArgs>
    apiRequests?: boolean | TripLog$apiRequestsArgs<ExtArgs>
    _count?: boolean | TripLogCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TripLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | TripLog$vehicleArgs<ExtArgs>
    driver?: boolean | TripLog$driverArgs<ExtArgs>
    user?: boolean | TripLog$userArgs<ExtArgs>
    booking?: boolean | TripLog$bookingArgs<ExtArgs>
    parent?: boolean | TripLog$parentArgs<ExtArgs>
  }
  export type TripLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    vehicle?: boolean | TripLog$vehicleArgs<ExtArgs>
    driver?: boolean | TripLog$driverArgs<ExtArgs>
    user?: boolean | TripLog$userArgs<ExtArgs>
    booking?: boolean | TripLog$bookingArgs<ExtArgs>
    parent?: boolean | TripLog$parentArgs<ExtArgs>
  }

  export type $TripLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TripLog"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs> | null
      driver: Prisma.$DriverPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      booking: Prisma.$BookingPayload<ExtArgs> | null
      parent: Prisma.$TripLogPayload<ExtArgs> | null
      children: Prisma.$TripLogPayload<ExtArgs>[]
      apiRequests: Prisma.$GovernmentApiRequestPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      parentId: string | null
      logType: $Enums.LogType
      companyId: string
      vehicleId: string | null
      driverId: string | null
      userId: string | null
      bookingId: string | null
      startLatitude: number | null
      startLongitude: number | null
      startAddress: string | null
      endLatitude: number | null
      endLongitude: number | null
      endAddress: string | null
      distance: number | null
      duration: number | null
      finalPrice: number | null
      tariffUsed: string | null
      governmentTripId: string | null
      tripStartApiSent: boolean
      tripEndApiSent: boolean
      apiErrorLog: string | null
      logDetails: Prisma.JsonValue | null
      tripStartTime: Date | null
      tripEndTime: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tripLog"]>
    composites: {}
  }

  type TripLogGetPayload<S extends boolean | null | undefined | TripLogDefaultArgs> = $Result.GetResult<Prisma.$TripLogPayload, S>

  type TripLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TripLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TripLogCountAggregateInputType | true
    }

  export interface TripLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TripLog'], meta: { name: 'TripLog' } }
    /**
     * Find zero or one TripLog that matches the filter.
     * @param {TripLogFindUniqueArgs} args - Arguments to find a TripLog
     * @example
     * // Get one TripLog
     * const tripLog = await prisma.tripLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TripLogFindUniqueArgs>(args: SelectSubset<T, TripLogFindUniqueArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TripLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TripLogFindUniqueOrThrowArgs} args - Arguments to find a TripLog
     * @example
     * // Get one TripLog
     * const tripLog = await prisma.tripLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TripLogFindUniqueOrThrowArgs>(args: SelectSubset<T, TripLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripLogFindFirstArgs} args - Arguments to find a TripLog
     * @example
     * // Get one TripLog
     * const tripLog = await prisma.tripLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TripLogFindFirstArgs>(args?: SelectSubset<T, TripLogFindFirstArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TripLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripLogFindFirstOrThrowArgs} args - Arguments to find a TripLog
     * @example
     * // Get one TripLog
     * const tripLog = await prisma.tripLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TripLogFindFirstOrThrowArgs>(args?: SelectSubset<T, TripLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TripLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TripLogs
     * const tripLogs = await prisma.tripLog.findMany()
     * 
     * // Get first 10 TripLogs
     * const tripLogs = await prisma.tripLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tripLogWithIdOnly = await prisma.tripLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TripLogFindManyArgs>(args?: SelectSubset<T, TripLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TripLog.
     * @param {TripLogCreateArgs} args - Arguments to create a TripLog.
     * @example
     * // Create one TripLog
     * const TripLog = await prisma.tripLog.create({
     *   data: {
     *     // ... data to create a TripLog
     *   }
     * })
     * 
     */
    create<T extends TripLogCreateArgs>(args: SelectSubset<T, TripLogCreateArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TripLogs.
     * @param {TripLogCreateManyArgs} args - Arguments to create many TripLogs.
     * @example
     * // Create many TripLogs
     * const tripLog = await prisma.tripLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TripLogCreateManyArgs>(args?: SelectSubset<T, TripLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TripLogs and returns the data saved in the database.
     * @param {TripLogCreateManyAndReturnArgs} args - Arguments to create many TripLogs.
     * @example
     * // Create many TripLogs
     * const tripLog = await prisma.tripLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TripLogs and only return the `id`
     * const tripLogWithIdOnly = await prisma.tripLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TripLogCreateManyAndReturnArgs>(args?: SelectSubset<T, TripLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TripLog.
     * @param {TripLogDeleteArgs} args - Arguments to delete one TripLog.
     * @example
     * // Delete one TripLog
     * const TripLog = await prisma.tripLog.delete({
     *   where: {
     *     // ... filter to delete one TripLog
     *   }
     * })
     * 
     */
    delete<T extends TripLogDeleteArgs>(args: SelectSubset<T, TripLogDeleteArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TripLog.
     * @param {TripLogUpdateArgs} args - Arguments to update one TripLog.
     * @example
     * // Update one TripLog
     * const tripLog = await prisma.tripLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TripLogUpdateArgs>(args: SelectSubset<T, TripLogUpdateArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TripLogs.
     * @param {TripLogDeleteManyArgs} args - Arguments to filter TripLogs to delete.
     * @example
     * // Delete a few TripLogs
     * const { count } = await prisma.tripLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TripLogDeleteManyArgs>(args?: SelectSubset<T, TripLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TripLogs
     * const tripLog = await prisma.tripLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TripLogUpdateManyArgs>(args: SelectSubset<T, TripLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TripLogs and returns the data updated in the database.
     * @param {TripLogUpdateManyAndReturnArgs} args - Arguments to update many TripLogs.
     * @example
     * // Update many TripLogs
     * const tripLog = await prisma.tripLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TripLogs and only return the `id`
     * const tripLogWithIdOnly = await prisma.tripLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TripLogUpdateManyAndReturnArgs>(args: SelectSubset<T, TripLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TripLog.
     * @param {TripLogUpsertArgs} args - Arguments to update or create a TripLog.
     * @example
     * // Update or create a TripLog
     * const tripLog = await prisma.tripLog.upsert({
     *   create: {
     *     // ... data to create a TripLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TripLog we want to update
     *   }
     * })
     */
    upsert<T extends TripLogUpsertArgs>(args: SelectSubset<T, TripLogUpsertArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TripLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripLogCountArgs} args - Arguments to filter TripLogs to count.
     * @example
     * // Count the number of TripLogs
     * const count = await prisma.tripLog.count({
     *   where: {
     *     // ... the filter for the TripLogs we want to count
     *   }
     * })
    **/
    count<T extends TripLogCountArgs>(
      args?: Subset<T, TripLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TripLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TripLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TripLogAggregateArgs>(args: Subset<T, TripLogAggregateArgs>): Prisma.PrismaPromise<GetTripLogAggregateType<T>>

    /**
     * Group by TripLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TripLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TripLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TripLogGroupByArgs['orderBy'] }
        : { orderBy?: TripLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TripLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTripLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TripLog model
   */
  readonly fields: TripLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TripLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TripLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends TripLog$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, TripLog$vehicleArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    driver<T extends TripLog$driverArgs<ExtArgs> = {}>(args?: Subset<T, TripLog$driverArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends TripLog$userArgs<ExtArgs> = {}>(args?: Subset<T, TripLog$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    booking<T extends TripLog$bookingArgs<ExtArgs> = {}>(args?: Subset<T, TripLog$bookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    parent<T extends TripLog$parentArgs<ExtArgs> = {}>(args?: Subset<T, TripLog$parentArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends TripLog$childrenArgs<ExtArgs> = {}>(args?: Subset<T, TripLog$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    apiRequests<T extends TripLog$apiRequestsArgs<ExtArgs> = {}>(args?: Subset<T, TripLog$apiRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TripLog model
   */
  interface TripLogFieldRefs {
    readonly id: FieldRef<"TripLog", 'String'>
    readonly parentId: FieldRef<"TripLog", 'String'>
    readonly logType: FieldRef<"TripLog", 'LogType'>
    readonly companyId: FieldRef<"TripLog", 'String'>
    readonly vehicleId: FieldRef<"TripLog", 'String'>
    readonly driverId: FieldRef<"TripLog", 'String'>
    readonly userId: FieldRef<"TripLog", 'String'>
    readonly bookingId: FieldRef<"TripLog", 'String'>
    readonly startLatitude: FieldRef<"TripLog", 'Float'>
    readonly startLongitude: FieldRef<"TripLog", 'Float'>
    readonly startAddress: FieldRef<"TripLog", 'String'>
    readonly endLatitude: FieldRef<"TripLog", 'Float'>
    readonly endLongitude: FieldRef<"TripLog", 'Float'>
    readonly endAddress: FieldRef<"TripLog", 'String'>
    readonly distance: FieldRef<"TripLog", 'Float'>
    readonly duration: FieldRef<"TripLog", 'Int'>
    readonly finalPrice: FieldRef<"TripLog", 'Float'>
    readonly tariffUsed: FieldRef<"TripLog", 'String'>
    readonly governmentTripId: FieldRef<"TripLog", 'String'>
    readonly tripStartApiSent: FieldRef<"TripLog", 'Boolean'>
    readonly tripEndApiSent: FieldRef<"TripLog", 'Boolean'>
    readonly apiErrorLog: FieldRef<"TripLog", 'String'>
    readonly logDetails: FieldRef<"TripLog", 'Json'>
    readonly tripStartTime: FieldRef<"TripLog", 'DateTime'>
    readonly tripEndTime: FieldRef<"TripLog", 'DateTime'>
    readonly createdAt: FieldRef<"TripLog", 'DateTime'>
    readonly updatedAt: FieldRef<"TripLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TripLog findUnique
   */
  export type TripLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * Filter, which TripLog to fetch.
     */
    where: TripLogWhereUniqueInput
  }

  /**
   * TripLog findUniqueOrThrow
   */
  export type TripLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * Filter, which TripLog to fetch.
     */
    where: TripLogWhereUniqueInput
  }

  /**
   * TripLog findFirst
   */
  export type TripLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * Filter, which TripLog to fetch.
     */
    where?: TripLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripLogs to fetch.
     */
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripLogs.
     */
    cursor?: TripLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripLogs.
     */
    distinct?: TripLogScalarFieldEnum | TripLogScalarFieldEnum[]
  }

  /**
   * TripLog findFirstOrThrow
   */
  export type TripLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * Filter, which TripLog to fetch.
     */
    where?: TripLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripLogs to fetch.
     */
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TripLogs.
     */
    cursor?: TripLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TripLogs.
     */
    distinct?: TripLogScalarFieldEnum | TripLogScalarFieldEnum[]
  }

  /**
   * TripLog findMany
   */
  export type TripLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * Filter, which TripLogs to fetch.
     */
    where?: TripLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TripLogs to fetch.
     */
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TripLogs.
     */
    cursor?: TripLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TripLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TripLogs.
     */
    skip?: number
    distinct?: TripLogScalarFieldEnum | TripLogScalarFieldEnum[]
  }

  /**
   * TripLog create
   */
  export type TripLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * The data needed to create a TripLog.
     */
    data: XOR<TripLogCreateInput, TripLogUncheckedCreateInput>
  }

  /**
   * TripLog createMany
   */
  export type TripLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TripLogs.
     */
    data: TripLogCreateManyInput | TripLogCreateManyInput[]
  }

  /**
   * TripLog createManyAndReturn
   */
  export type TripLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * The data used to create many TripLogs.
     */
    data: TripLogCreateManyInput | TripLogCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripLog update
   */
  export type TripLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * The data needed to update a TripLog.
     */
    data: XOR<TripLogUpdateInput, TripLogUncheckedUpdateInput>
    /**
     * Choose, which TripLog to update.
     */
    where: TripLogWhereUniqueInput
  }

  /**
   * TripLog updateMany
   */
  export type TripLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TripLogs.
     */
    data: XOR<TripLogUpdateManyMutationInput, TripLogUncheckedUpdateManyInput>
    /**
     * Filter which TripLogs to update
     */
    where?: TripLogWhereInput
    /**
     * Limit how many TripLogs to update.
     */
    limit?: number
  }

  /**
   * TripLog updateManyAndReturn
   */
  export type TripLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * The data used to update TripLogs.
     */
    data: XOR<TripLogUpdateManyMutationInput, TripLogUncheckedUpdateManyInput>
    /**
     * Filter which TripLogs to update
     */
    where?: TripLogWhereInput
    /**
     * Limit how many TripLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TripLog upsert
   */
  export type TripLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * The filter to search for the TripLog to update in case it exists.
     */
    where: TripLogWhereUniqueInput
    /**
     * In case the TripLog found by the `where` argument doesn't exist, create a new TripLog with this data.
     */
    create: XOR<TripLogCreateInput, TripLogUncheckedCreateInput>
    /**
     * In case the TripLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TripLogUpdateInput, TripLogUncheckedUpdateInput>
  }

  /**
   * TripLog delete
   */
  export type TripLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    /**
     * Filter which TripLog to delete.
     */
    where: TripLogWhereUniqueInput
  }

  /**
   * TripLog deleteMany
   */
  export type TripLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TripLogs to delete
     */
    where?: TripLogWhereInput
    /**
     * Limit how many TripLogs to delete.
     */
    limit?: number
  }

  /**
   * TripLog.vehicle
   */
  export type TripLog$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle
     */
    select?: VehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vehicle
     */
    omit?: VehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VehicleInclude<ExtArgs> | null
    where?: VehicleWhereInput
  }

  /**
   * TripLog.driver
   */
  export type TripLog$driverArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Driver
     */
    select?: DriverSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Driver
     */
    omit?: DriverOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DriverInclude<ExtArgs> | null
    where?: DriverWhereInput
  }

  /**
   * TripLog.user
   */
  export type TripLog$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TripLog.booking
   */
  export type TripLog$bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * TripLog.parent
   */
  export type TripLog$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    where?: TripLogWhereInput
  }

  /**
   * TripLog.children
   */
  export type TripLog$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
    where?: TripLogWhereInput
    orderBy?: TripLogOrderByWithRelationInput | TripLogOrderByWithRelationInput[]
    cursor?: TripLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TripLogScalarFieldEnum | TripLogScalarFieldEnum[]
  }

  /**
   * TripLog.apiRequests
   */
  export type TripLog$apiRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    where?: GovernmentApiRequestWhereInput
    orderBy?: GovernmentApiRequestOrderByWithRelationInput | GovernmentApiRequestOrderByWithRelationInput[]
    cursor?: GovernmentApiRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GovernmentApiRequestScalarFieldEnum | GovernmentApiRequestScalarFieldEnum[]
  }

  /**
   * TripLog without action
   */
  export type TripLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TripLog
     */
    select?: TripLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TripLog
     */
    omit?: TripLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TripLogInclude<ExtArgs> | null
  }


  /**
   * Model GovernmentApiRequest
   */

  export type AggregateGovernmentApiRequest = {
    _count: GovernmentApiRequestCountAggregateOutputType | null
    _avg: GovernmentApiRequestAvgAggregateOutputType | null
    _sum: GovernmentApiRequestSumAggregateOutputType | null
    _min: GovernmentApiRequestMinAggregateOutputType | null
    _max: GovernmentApiRequestMaxAggregateOutputType | null
  }

  export type GovernmentApiRequestAvgAggregateOutputType = {
    statusCode: number | null
    retryCount: number | null
  }

  export type GovernmentApiRequestSumAggregateOutputType = {
    statusCode: number | null
    retryCount: number | null
  }

  export type GovernmentApiRequestMinAggregateOutputType = {
    id: string | null
    tripLogId: string | null
    requestType: $Enums.ApiRequestType | null
    endpoint: string | null
    statusCode: number | null
    success: boolean | null
    errorMessage: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GovernmentApiRequestMaxAggregateOutputType = {
    id: string | null
    tripLogId: string | null
    requestType: $Enums.ApiRequestType | null
    endpoint: string | null
    statusCode: number | null
    success: boolean | null
    errorMessage: string | null
    retryCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type GovernmentApiRequestCountAggregateOutputType = {
    id: number
    tripLogId: number
    requestType: number
    endpoint: number
    payload: number
    response: number
    statusCode: number
    success: number
    errorMessage: number
    retryCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type GovernmentApiRequestAvgAggregateInputType = {
    statusCode?: true
    retryCount?: true
  }

  export type GovernmentApiRequestSumAggregateInputType = {
    statusCode?: true
    retryCount?: true
  }

  export type GovernmentApiRequestMinAggregateInputType = {
    id?: true
    tripLogId?: true
    requestType?: true
    endpoint?: true
    statusCode?: true
    success?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GovernmentApiRequestMaxAggregateInputType = {
    id?: true
    tripLogId?: true
    requestType?: true
    endpoint?: true
    statusCode?: true
    success?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type GovernmentApiRequestCountAggregateInputType = {
    id?: true
    tripLogId?: true
    requestType?: true
    endpoint?: true
    payload?: true
    response?: true
    statusCode?: true
    success?: true
    errorMessage?: true
    retryCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type GovernmentApiRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GovernmentApiRequest to aggregate.
     */
    where?: GovernmentApiRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernmentApiRequests to fetch.
     */
    orderBy?: GovernmentApiRequestOrderByWithRelationInput | GovernmentApiRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GovernmentApiRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernmentApiRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernmentApiRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GovernmentApiRequests
    **/
    _count?: true | GovernmentApiRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GovernmentApiRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GovernmentApiRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GovernmentApiRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GovernmentApiRequestMaxAggregateInputType
  }

  export type GetGovernmentApiRequestAggregateType<T extends GovernmentApiRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateGovernmentApiRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGovernmentApiRequest[P]>
      : GetScalarType<T[P], AggregateGovernmentApiRequest[P]>
  }




  export type GovernmentApiRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GovernmentApiRequestWhereInput
    orderBy?: GovernmentApiRequestOrderByWithAggregationInput | GovernmentApiRequestOrderByWithAggregationInput[]
    by: GovernmentApiRequestScalarFieldEnum[] | GovernmentApiRequestScalarFieldEnum
    having?: GovernmentApiRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GovernmentApiRequestCountAggregateInputType | true
    _avg?: GovernmentApiRequestAvgAggregateInputType
    _sum?: GovernmentApiRequestSumAggregateInputType
    _min?: GovernmentApiRequestMinAggregateInputType
    _max?: GovernmentApiRequestMaxAggregateInputType
  }

  export type GovernmentApiRequestGroupByOutputType = {
    id: string
    tripLogId: string
    requestType: $Enums.ApiRequestType
    endpoint: string
    payload: JsonValue
    response: JsonValue | null
    statusCode: number | null
    success: boolean
    errorMessage: string | null
    retryCount: number
    createdAt: Date
    updatedAt: Date
    _count: GovernmentApiRequestCountAggregateOutputType | null
    _avg: GovernmentApiRequestAvgAggregateOutputType | null
    _sum: GovernmentApiRequestSumAggregateOutputType | null
    _min: GovernmentApiRequestMinAggregateOutputType | null
    _max: GovernmentApiRequestMaxAggregateOutputType | null
  }

  type GetGovernmentApiRequestGroupByPayload<T extends GovernmentApiRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GovernmentApiRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GovernmentApiRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GovernmentApiRequestGroupByOutputType[P]>
            : GetScalarType<T[P], GovernmentApiRequestGroupByOutputType[P]>
        }
      >
    >


  export type GovernmentApiRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripLogId?: boolean
    requestType?: boolean
    endpoint?: boolean
    payload?: boolean
    response?: boolean
    statusCode?: boolean
    success?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tripLog?: boolean | TripLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governmentApiRequest"]>

  export type GovernmentApiRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripLogId?: boolean
    requestType?: boolean
    endpoint?: boolean
    payload?: boolean
    response?: boolean
    statusCode?: boolean
    success?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tripLog?: boolean | TripLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governmentApiRequest"]>

  export type GovernmentApiRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tripLogId?: boolean
    requestType?: boolean
    endpoint?: boolean
    payload?: boolean
    response?: boolean
    statusCode?: boolean
    success?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tripLog?: boolean | TripLogDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["governmentApiRequest"]>

  export type GovernmentApiRequestSelectScalar = {
    id?: boolean
    tripLogId?: boolean
    requestType?: boolean
    endpoint?: boolean
    payload?: boolean
    response?: boolean
    statusCode?: boolean
    success?: boolean
    errorMessage?: boolean
    retryCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type GovernmentApiRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tripLogId" | "requestType" | "endpoint" | "payload" | "response" | "statusCode" | "success" | "errorMessage" | "retryCount" | "createdAt" | "updatedAt", ExtArgs["result"]["governmentApiRequest"]>
  export type GovernmentApiRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripLog?: boolean | TripLogDefaultArgs<ExtArgs>
  }
  export type GovernmentApiRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripLog?: boolean | TripLogDefaultArgs<ExtArgs>
  }
  export type GovernmentApiRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tripLog?: boolean | TripLogDefaultArgs<ExtArgs>
  }

  export type $GovernmentApiRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GovernmentApiRequest"
    objects: {
      tripLog: Prisma.$TripLogPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tripLogId: string
      requestType: $Enums.ApiRequestType
      endpoint: string
      payload: Prisma.JsonValue
      response: Prisma.JsonValue | null
      statusCode: number | null
      success: boolean
      errorMessage: string | null
      retryCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["governmentApiRequest"]>
    composites: {}
  }

  type GovernmentApiRequestGetPayload<S extends boolean | null | undefined | GovernmentApiRequestDefaultArgs> = $Result.GetResult<Prisma.$GovernmentApiRequestPayload, S>

  type GovernmentApiRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GovernmentApiRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GovernmentApiRequestCountAggregateInputType | true
    }

  export interface GovernmentApiRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GovernmentApiRequest'], meta: { name: 'GovernmentApiRequest' } }
    /**
     * Find zero or one GovernmentApiRequest that matches the filter.
     * @param {GovernmentApiRequestFindUniqueArgs} args - Arguments to find a GovernmentApiRequest
     * @example
     * // Get one GovernmentApiRequest
     * const governmentApiRequest = await prisma.governmentApiRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GovernmentApiRequestFindUniqueArgs>(args: SelectSubset<T, GovernmentApiRequestFindUniqueArgs<ExtArgs>>): Prisma__GovernmentApiRequestClient<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GovernmentApiRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GovernmentApiRequestFindUniqueOrThrowArgs} args - Arguments to find a GovernmentApiRequest
     * @example
     * // Get one GovernmentApiRequest
     * const governmentApiRequest = await prisma.governmentApiRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GovernmentApiRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, GovernmentApiRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GovernmentApiRequestClient<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GovernmentApiRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernmentApiRequestFindFirstArgs} args - Arguments to find a GovernmentApiRequest
     * @example
     * // Get one GovernmentApiRequest
     * const governmentApiRequest = await prisma.governmentApiRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GovernmentApiRequestFindFirstArgs>(args?: SelectSubset<T, GovernmentApiRequestFindFirstArgs<ExtArgs>>): Prisma__GovernmentApiRequestClient<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GovernmentApiRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernmentApiRequestFindFirstOrThrowArgs} args - Arguments to find a GovernmentApiRequest
     * @example
     * // Get one GovernmentApiRequest
     * const governmentApiRequest = await prisma.governmentApiRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GovernmentApiRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, GovernmentApiRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__GovernmentApiRequestClient<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GovernmentApiRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernmentApiRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GovernmentApiRequests
     * const governmentApiRequests = await prisma.governmentApiRequest.findMany()
     * 
     * // Get first 10 GovernmentApiRequests
     * const governmentApiRequests = await prisma.governmentApiRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const governmentApiRequestWithIdOnly = await prisma.governmentApiRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GovernmentApiRequestFindManyArgs>(args?: SelectSubset<T, GovernmentApiRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GovernmentApiRequest.
     * @param {GovernmentApiRequestCreateArgs} args - Arguments to create a GovernmentApiRequest.
     * @example
     * // Create one GovernmentApiRequest
     * const GovernmentApiRequest = await prisma.governmentApiRequest.create({
     *   data: {
     *     // ... data to create a GovernmentApiRequest
     *   }
     * })
     * 
     */
    create<T extends GovernmentApiRequestCreateArgs>(args: SelectSubset<T, GovernmentApiRequestCreateArgs<ExtArgs>>): Prisma__GovernmentApiRequestClient<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GovernmentApiRequests.
     * @param {GovernmentApiRequestCreateManyArgs} args - Arguments to create many GovernmentApiRequests.
     * @example
     * // Create many GovernmentApiRequests
     * const governmentApiRequest = await prisma.governmentApiRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GovernmentApiRequestCreateManyArgs>(args?: SelectSubset<T, GovernmentApiRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GovernmentApiRequests and returns the data saved in the database.
     * @param {GovernmentApiRequestCreateManyAndReturnArgs} args - Arguments to create many GovernmentApiRequests.
     * @example
     * // Create many GovernmentApiRequests
     * const governmentApiRequest = await prisma.governmentApiRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GovernmentApiRequests and only return the `id`
     * const governmentApiRequestWithIdOnly = await prisma.governmentApiRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GovernmentApiRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, GovernmentApiRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GovernmentApiRequest.
     * @param {GovernmentApiRequestDeleteArgs} args - Arguments to delete one GovernmentApiRequest.
     * @example
     * // Delete one GovernmentApiRequest
     * const GovernmentApiRequest = await prisma.governmentApiRequest.delete({
     *   where: {
     *     // ... filter to delete one GovernmentApiRequest
     *   }
     * })
     * 
     */
    delete<T extends GovernmentApiRequestDeleteArgs>(args: SelectSubset<T, GovernmentApiRequestDeleteArgs<ExtArgs>>): Prisma__GovernmentApiRequestClient<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GovernmentApiRequest.
     * @param {GovernmentApiRequestUpdateArgs} args - Arguments to update one GovernmentApiRequest.
     * @example
     * // Update one GovernmentApiRequest
     * const governmentApiRequest = await prisma.governmentApiRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GovernmentApiRequestUpdateArgs>(args: SelectSubset<T, GovernmentApiRequestUpdateArgs<ExtArgs>>): Prisma__GovernmentApiRequestClient<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GovernmentApiRequests.
     * @param {GovernmentApiRequestDeleteManyArgs} args - Arguments to filter GovernmentApiRequests to delete.
     * @example
     * // Delete a few GovernmentApiRequests
     * const { count } = await prisma.governmentApiRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GovernmentApiRequestDeleteManyArgs>(args?: SelectSubset<T, GovernmentApiRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GovernmentApiRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernmentApiRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GovernmentApiRequests
     * const governmentApiRequest = await prisma.governmentApiRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GovernmentApiRequestUpdateManyArgs>(args: SelectSubset<T, GovernmentApiRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GovernmentApiRequests and returns the data updated in the database.
     * @param {GovernmentApiRequestUpdateManyAndReturnArgs} args - Arguments to update many GovernmentApiRequests.
     * @example
     * // Update many GovernmentApiRequests
     * const governmentApiRequest = await prisma.governmentApiRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GovernmentApiRequests and only return the `id`
     * const governmentApiRequestWithIdOnly = await prisma.governmentApiRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GovernmentApiRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, GovernmentApiRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GovernmentApiRequest.
     * @param {GovernmentApiRequestUpsertArgs} args - Arguments to update or create a GovernmentApiRequest.
     * @example
     * // Update or create a GovernmentApiRequest
     * const governmentApiRequest = await prisma.governmentApiRequest.upsert({
     *   create: {
     *     // ... data to create a GovernmentApiRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GovernmentApiRequest we want to update
     *   }
     * })
     */
    upsert<T extends GovernmentApiRequestUpsertArgs>(args: SelectSubset<T, GovernmentApiRequestUpsertArgs<ExtArgs>>): Prisma__GovernmentApiRequestClient<$Result.GetResult<Prisma.$GovernmentApiRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GovernmentApiRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernmentApiRequestCountArgs} args - Arguments to filter GovernmentApiRequests to count.
     * @example
     * // Count the number of GovernmentApiRequests
     * const count = await prisma.governmentApiRequest.count({
     *   where: {
     *     // ... the filter for the GovernmentApiRequests we want to count
     *   }
     * })
    **/
    count<T extends GovernmentApiRequestCountArgs>(
      args?: Subset<T, GovernmentApiRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GovernmentApiRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GovernmentApiRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernmentApiRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GovernmentApiRequestAggregateArgs>(args: Subset<T, GovernmentApiRequestAggregateArgs>): Prisma.PrismaPromise<GetGovernmentApiRequestAggregateType<T>>

    /**
     * Group by GovernmentApiRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GovernmentApiRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GovernmentApiRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GovernmentApiRequestGroupByArgs['orderBy'] }
        : { orderBy?: GovernmentApiRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GovernmentApiRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGovernmentApiRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GovernmentApiRequest model
   */
  readonly fields: GovernmentApiRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GovernmentApiRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GovernmentApiRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tripLog<T extends TripLogDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TripLogDefaultArgs<ExtArgs>>): Prisma__TripLogClient<$Result.GetResult<Prisma.$TripLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GovernmentApiRequest model
   */
  interface GovernmentApiRequestFieldRefs {
    readonly id: FieldRef<"GovernmentApiRequest", 'String'>
    readonly tripLogId: FieldRef<"GovernmentApiRequest", 'String'>
    readonly requestType: FieldRef<"GovernmentApiRequest", 'ApiRequestType'>
    readonly endpoint: FieldRef<"GovernmentApiRequest", 'String'>
    readonly payload: FieldRef<"GovernmentApiRequest", 'Json'>
    readonly response: FieldRef<"GovernmentApiRequest", 'Json'>
    readonly statusCode: FieldRef<"GovernmentApiRequest", 'Int'>
    readonly success: FieldRef<"GovernmentApiRequest", 'Boolean'>
    readonly errorMessage: FieldRef<"GovernmentApiRequest", 'String'>
    readonly retryCount: FieldRef<"GovernmentApiRequest", 'Int'>
    readonly createdAt: FieldRef<"GovernmentApiRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"GovernmentApiRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GovernmentApiRequest findUnique
   */
  export type GovernmentApiRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * Filter, which GovernmentApiRequest to fetch.
     */
    where: GovernmentApiRequestWhereUniqueInput
  }

  /**
   * GovernmentApiRequest findUniqueOrThrow
   */
  export type GovernmentApiRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * Filter, which GovernmentApiRequest to fetch.
     */
    where: GovernmentApiRequestWhereUniqueInput
  }

  /**
   * GovernmentApiRequest findFirst
   */
  export type GovernmentApiRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * Filter, which GovernmentApiRequest to fetch.
     */
    where?: GovernmentApiRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernmentApiRequests to fetch.
     */
    orderBy?: GovernmentApiRequestOrderByWithRelationInput | GovernmentApiRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GovernmentApiRequests.
     */
    cursor?: GovernmentApiRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernmentApiRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernmentApiRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GovernmentApiRequests.
     */
    distinct?: GovernmentApiRequestScalarFieldEnum | GovernmentApiRequestScalarFieldEnum[]
  }

  /**
   * GovernmentApiRequest findFirstOrThrow
   */
  export type GovernmentApiRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * Filter, which GovernmentApiRequest to fetch.
     */
    where?: GovernmentApiRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernmentApiRequests to fetch.
     */
    orderBy?: GovernmentApiRequestOrderByWithRelationInput | GovernmentApiRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GovernmentApiRequests.
     */
    cursor?: GovernmentApiRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernmentApiRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernmentApiRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GovernmentApiRequests.
     */
    distinct?: GovernmentApiRequestScalarFieldEnum | GovernmentApiRequestScalarFieldEnum[]
  }

  /**
   * GovernmentApiRequest findMany
   */
  export type GovernmentApiRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * Filter, which GovernmentApiRequests to fetch.
     */
    where?: GovernmentApiRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GovernmentApiRequests to fetch.
     */
    orderBy?: GovernmentApiRequestOrderByWithRelationInput | GovernmentApiRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GovernmentApiRequests.
     */
    cursor?: GovernmentApiRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GovernmentApiRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GovernmentApiRequests.
     */
    skip?: number
    distinct?: GovernmentApiRequestScalarFieldEnum | GovernmentApiRequestScalarFieldEnum[]
  }

  /**
   * GovernmentApiRequest create
   */
  export type GovernmentApiRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a GovernmentApiRequest.
     */
    data: XOR<GovernmentApiRequestCreateInput, GovernmentApiRequestUncheckedCreateInput>
  }

  /**
   * GovernmentApiRequest createMany
   */
  export type GovernmentApiRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GovernmentApiRequests.
     */
    data: GovernmentApiRequestCreateManyInput | GovernmentApiRequestCreateManyInput[]
  }

  /**
   * GovernmentApiRequest createManyAndReturn
   */
  export type GovernmentApiRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * The data used to create many GovernmentApiRequests.
     */
    data: GovernmentApiRequestCreateManyInput | GovernmentApiRequestCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GovernmentApiRequest update
   */
  export type GovernmentApiRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a GovernmentApiRequest.
     */
    data: XOR<GovernmentApiRequestUpdateInput, GovernmentApiRequestUncheckedUpdateInput>
    /**
     * Choose, which GovernmentApiRequest to update.
     */
    where: GovernmentApiRequestWhereUniqueInput
  }

  /**
   * GovernmentApiRequest updateMany
   */
  export type GovernmentApiRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GovernmentApiRequests.
     */
    data: XOR<GovernmentApiRequestUpdateManyMutationInput, GovernmentApiRequestUncheckedUpdateManyInput>
    /**
     * Filter which GovernmentApiRequests to update
     */
    where?: GovernmentApiRequestWhereInput
    /**
     * Limit how many GovernmentApiRequests to update.
     */
    limit?: number
  }

  /**
   * GovernmentApiRequest updateManyAndReturn
   */
  export type GovernmentApiRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * The data used to update GovernmentApiRequests.
     */
    data: XOR<GovernmentApiRequestUpdateManyMutationInput, GovernmentApiRequestUncheckedUpdateManyInput>
    /**
     * Filter which GovernmentApiRequests to update
     */
    where?: GovernmentApiRequestWhereInput
    /**
     * Limit how many GovernmentApiRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GovernmentApiRequest upsert
   */
  export type GovernmentApiRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the GovernmentApiRequest to update in case it exists.
     */
    where: GovernmentApiRequestWhereUniqueInput
    /**
     * In case the GovernmentApiRequest found by the `where` argument doesn't exist, create a new GovernmentApiRequest with this data.
     */
    create: XOR<GovernmentApiRequestCreateInput, GovernmentApiRequestUncheckedCreateInput>
    /**
     * In case the GovernmentApiRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GovernmentApiRequestUpdateInput, GovernmentApiRequestUncheckedUpdateInput>
  }

  /**
   * GovernmentApiRequest delete
   */
  export type GovernmentApiRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
    /**
     * Filter which GovernmentApiRequest to delete.
     */
    where: GovernmentApiRequestWhereUniqueInput
  }

  /**
   * GovernmentApiRequest deleteMany
   */
  export type GovernmentApiRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GovernmentApiRequests to delete
     */
    where?: GovernmentApiRequestWhereInput
    /**
     * Limit how many GovernmentApiRequests to delete.
     */
    limit?: number
  }

  /**
   * GovernmentApiRequest without action
   */
  export type GovernmentApiRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GovernmentApiRequest
     */
    select?: GovernmentApiRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GovernmentApiRequest
     */
    omit?: GovernmentApiRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GovernmentApiRequestInclude<ExtArgs> | null
  }


  /**
   * Model LocationUpdate
   */

  export type AggregateLocationUpdate = {
    _count: LocationUpdateCountAggregateOutputType | null
    _avg: LocationUpdateAvgAggregateOutputType | null
    _sum: LocationUpdateSumAggregateOutputType | null
    _min: LocationUpdateMinAggregateOutputType | null
    _max: LocationUpdateMaxAggregateOutputType | null
  }

  export type LocationUpdateAvgAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    speed: number | null
    heading: number | null
    altitude: number | null
  }

  export type LocationUpdateSumAggregateOutputType = {
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    speed: number | null
    heading: number | null
    altitude: number | null
  }

  export type LocationUpdateMinAggregateOutputType = {
    id: string | null
    driverId: string | null
    vehicleId: string | null
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    speed: number | null
    heading: number | null
    altitude: number | null
    createdAt: Date | null
  }

  export type LocationUpdateMaxAggregateOutputType = {
    id: string | null
    driverId: string | null
    vehicleId: string | null
    latitude: number | null
    longitude: number | null
    accuracy: number | null
    speed: number | null
    heading: number | null
    altitude: number | null
    createdAt: Date | null
  }

  export type LocationUpdateCountAggregateOutputType = {
    id: number
    driverId: number
    vehicleId: number
    latitude: number
    longitude: number
    accuracy: number
    speed: number
    heading: number
    altitude: number
    createdAt: number
    _all: number
  }


  export type LocationUpdateAvgAggregateInputType = {
    latitude?: true
    longitude?: true
    accuracy?: true
    speed?: true
    heading?: true
    altitude?: true
  }

  export type LocationUpdateSumAggregateInputType = {
    latitude?: true
    longitude?: true
    accuracy?: true
    speed?: true
    heading?: true
    altitude?: true
  }

  export type LocationUpdateMinAggregateInputType = {
    id?: true
    driverId?: true
    vehicleId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    speed?: true
    heading?: true
    altitude?: true
    createdAt?: true
  }

  export type LocationUpdateMaxAggregateInputType = {
    id?: true
    driverId?: true
    vehicleId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    speed?: true
    heading?: true
    altitude?: true
    createdAt?: true
  }

  export type LocationUpdateCountAggregateInputType = {
    id?: true
    driverId?: true
    vehicleId?: true
    latitude?: true
    longitude?: true
    accuracy?: true
    speed?: true
    heading?: true
    altitude?: true
    createdAt?: true
    _all?: true
  }

  export type LocationUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationUpdate to aggregate.
     */
    where?: LocationUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationUpdates to fetch.
     */
    orderBy?: LocationUpdateOrderByWithRelationInput | LocationUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LocationUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LocationUpdates
    **/
    _count?: true | LocationUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LocationUpdateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LocationUpdateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LocationUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LocationUpdateMaxAggregateInputType
  }

  export type GetLocationUpdateAggregateType<T extends LocationUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateLocationUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLocationUpdate[P]>
      : GetScalarType<T[P], AggregateLocationUpdate[P]>
  }




  export type LocationUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LocationUpdateWhereInput
    orderBy?: LocationUpdateOrderByWithAggregationInput | LocationUpdateOrderByWithAggregationInput[]
    by: LocationUpdateScalarFieldEnum[] | LocationUpdateScalarFieldEnum
    having?: LocationUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LocationUpdateCountAggregateInputType | true
    _avg?: LocationUpdateAvgAggregateInputType
    _sum?: LocationUpdateSumAggregateInputType
    _min?: LocationUpdateMinAggregateInputType
    _max?: LocationUpdateMaxAggregateInputType
  }

  export type LocationUpdateGroupByOutputType = {
    id: string
    driverId: string
    vehicleId: string
    latitude: number
    longitude: number
    accuracy: number | null
    speed: number | null
    heading: number | null
    altitude: number | null
    createdAt: Date
    _count: LocationUpdateCountAggregateOutputType | null
    _avg: LocationUpdateAvgAggregateOutputType | null
    _sum: LocationUpdateSumAggregateOutputType | null
    _min: LocationUpdateMinAggregateOutputType | null
    _max: LocationUpdateMaxAggregateOutputType | null
  }

  type GetLocationUpdateGroupByPayload<T extends LocationUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LocationUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LocationUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LocationUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], LocationUpdateGroupByOutputType[P]>
        }
      >
    >


  export type LocationUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    vehicleId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    speed?: boolean
    heading?: boolean
    altitude?: boolean
    createdAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationUpdate"]>

  export type LocationUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    vehicleId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    speed?: boolean
    heading?: boolean
    altitude?: boolean
    createdAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationUpdate"]>

  export type LocationUpdateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    driverId?: boolean
    vehicleId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    speed?: boolean
    heading?: boolean
    altitude?: boolean
    createdAt?: boolean
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["locationUpdate"]>

  export type LocationUpdateSelectScalar = {
    id?: boolean
    driverId?: boolean
    vehicleId?: boolean
    latitude?: boolean
    longitude?: boolean
    accuracy?: boolean
    speed?: boolean
    heading?: boolean
    altitude?: boolean
    createdAt?: boolean
  }

  export type LocationUpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "driverId" | "vehicleId" | "latitude" | "longitude" | "accuracy" | "speed" | "heading" | "altitude" | "createdAt", ExtArgs["result"]["locationUpdate"]>
  export type LocationUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type LocationUpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }
  export type LocationUpdateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    driver?: boolean | DriverDefaultArgs<ExtArgs>
    vehicle?: boolean | VehicleDefaultArgs<ExtArgs>
  }

  export type $LocationUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LocationUpdate"
    objects: {
      driver: Prisma.$DriverPayload<ExtArgs>
      vehicle: Prisma.$VehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      driverId: string
      vehicleId: string
      latitude: number
      longitude: number
      accuracy: number | null
      speed: number | null
      heading: number | null
      altitude: number | null
      createdAt: Date
    }, ExtArgs["result"]["locationUpdate"]>
    composites: {}
  }

  type LocationUpdateGetPayload<S extends boolean | null | undefined | LocationUpdateDefaultArgs> = $Result.GetResult<Prisma.$LocationUpdatePayload, S>

  type LocationUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LocationUpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LocationUpdateCountAggregateInputType | true
    }

  export interface LocationUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LocationUpdate'], meta: { name: 'LocationUpdate' } }
    /**
     * Find zero or one LocationUpdate that matches the filter.
     * @param {LocationUpdateFindUniqueArgs} args - Arguments to find a LocationUpdate
     * @example
     * // Get one LocationUpdate
     * const locationUpdate = await prisma.locationUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LocationUpdateFindUniqueArgs>(args: SelectSubset<T, LocationUpdateFindUniqueArgs<ExtArgs>>): Prisma__LocationUpdateClient<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LocationUpdate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LocationUpdateFindUniqueOrThrowArgs} args - Arguments to find a LocationUpdate
     * @example
     * // Get one LocationUpdate
     * const locationUpdate = await prisma.locationUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LocationUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, LocationUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LocationUpdateClient<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateFindFirstArgs} args - Arguments to find a LocationUpdate
     * @example
     * // Get one LocationUpdate
     * const locationUpdate = await prisma.locationUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LocationUpdateFindFirstArgs>(args?: SelectSubset<T, LocationUpdateFindFirstArgs<ExtArgs>>): Prisma__LocationUpdateClient<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LocationUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateFindFirstOrThrowArgs} args - Arguments to find a LocationUpdate
     * @example
     * // Get one LocationUpdate
     * const locationUpdate = await prisma.locationUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LocationUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, LocationUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__LocationUpdateClient<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LocationUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LocationUpdates
     * const locationUpdates = await prisma.locationUpdate.findMany()
     * 
     * // Get first 10 LocationUpdates
     * const locationUpdates = await prisma.locationUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const locationUpdateWithIdOnly = await prisma.locationUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LocationUpdateFindManyArgs>(args?: SelectSubset<T, LocationUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LocationUpdate.
     * @param {LocationUpdateCreateArgs} args - Arguments to create a LocationUpdate.
     * @example
     * // Create one LocationUpdate
     * const LocationUpdate = await prisma.locationUpdate.create({
     *   data: {
     *     // ... data to create a LocationUpdate
     *   }
     * })
     * 
     */
    create<T extends LocationUpdateCreateArgs>(args: SelectSubset<T, LocationUpdateCreateArgs<ExtArgs>>): Prisma__LocationUpdateClient<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LocationUpdates.
     * @param {LocationUpdateCreateManyArgs} args - Arguments to create many LocationUpdates.
     * @example
     * // Create many LocationUpdates
     * const locationUpdate = await prisma.locationUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LocationUpdateCreateManyArgs>(args?: SelectSubset<T, LocationUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LocationUpdates and returns the data saved in the database.
     * @param {LocationUpdateCreateManyAndReturnArgs} args - Arguments to create many LocationUpdates.
     * @example
     * // Create many LocationUpdates
     * const locationUpdate = await prisma.locationUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LocationUpdates and only return the `id`
     * const locationUpdateWithIdOnly = await prisma.locationUpdate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LocationUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, LocationUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LocationUpdate.
     * @param {LocationUpdateDeleteArgs} args - Arguments to delete one LocationUpdate.
     * @example
     * // Delete one LocationUpdate
     * const LocationUpdate = await prisma.locationUpdate.delete({
     *   where: {
     *     // ... filter to delete one LocationUpdate
     *   }
     * })
     * 
     */
    delete<T extends LocationUpdateDeleteArgs>(args: SelectSubset<T, LocationUpdateDeleteArgs<ExtArgs>>): Prisma__LocationUpdateClient<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LocationUpdate.
     * @param {LocationUpdateUpdateArgs} args - Arguments to update one LocationUpdate.
     * @example
     * // Update one LocationUpdate
     * const locationUpdate = await prisma.locationUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LocationUpdateUpdateArgs>(args: SelectSubset<T, LocationUpdateUpdateArgs<ExtArgs>>): Prisma__LocationUpdateClient<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LocationUpdates.
     * @param {LocationUpdateDeleteManyArgs} args - Arguments to filter LocationUpdates to delete.
     * @example
     * // Delete a few LocationUpdates
     * const { count } = await prisma.locationUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LocationUpdateDeleteManyArgs>(args?: SelectSubset<T, LocationUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LocationUpdates
     * const locationUpdate = await prisma.locationUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LocationUpdateUpdateManyArgs>(args: SelectSubset<T, LocationUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LocationUpdates and returns the data updated in the database.
     * @param {LocationUpdateUpdateManyAndReturnArgs} args - Arguments to update many LocationUpdates.
     * @example
     * // Update many LocationUpdates
     * const locationUpdate = await prisma.locationUpdate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LocationUpdates and only return the `id`
     * const locationUpdateWithIdOnly = await prisma.locationUpdate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LocationUpdateUpdateManyAndReturnArgs>(args: SelectSubset<T, LocationUpdateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LocationUpdate.
     * @param {LocationUpdateUpsertArgs} args - Arguments to update or create a LocationUpdate.
     * @example
     * // Update or create a LocationUpdate
     * const locationUpdate = await prisma.locationUpdate.upsert({
     *   create: {
     *     // ... data to create a LocationUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LocationUpdate we want to update
     *   }
     * })
     */
    upsert<T extends LocationUpdateUpsertArgs>(args: SelectSubset<T, LocationUpdateUpsertArgs<ExtArgs>>): Prisma__LocationUpdateClient<$Result.GetResult<Prisma.$LocationUpdatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LocationUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateCountArgs} args - Arguments to filter LocationUpdates to count.
     * @example
     * // Count the number of LocationUpdates
     * const count = await prisma.locationUpdate.count({
     *   where: {
     *     // ... the filter for the LocationUpdates we want to count
     *   }
     * })
    **/
    count<T extends LocationUpdateCountArgs>(
      args?: Subset<T, LocationUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LocationUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LocationUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LocationUpdateAggregateArgs>(args: Subset<T, LocationUpdateAggregateArgs>): Prisma.PrismaPromise<GetLocationUpdateAggregateType<T>>

    /**
     * Group by LocationUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LocationUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LocationUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LocationUpdateGroupByArgs['orderBy'] }
        : { orderBy?: LocationUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LocationUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLocationUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LocationUpdate model
   */
  readonly fields: LocationUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LocationUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LocationUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    driver<T extends DriverDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DriverDefaultArgs<ExtArgs>>): Prisma__DriverClient<$Result.GetResult<Prisma.$DriverPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends VehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VehicleDefaultArgs<ExtArgs>>): Prisma__VehicleClient<$Result.GetResult<Prisma.$VehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LocationUpdate model
   */
  interface LocationUpdateFieldRefs {
    readonly id: FieldRef<"LocationUpdate", 'String'>
    readonly driverId: FieldRef<"LocationUpdate", 'String'>
    readonly vehicleId: FieldRef<"LocationUpdate", 'String'>
    readonly latitude: FieldRef<"LocationUpdate", 'Float'>
    readonly longitude: FieldRef<"LocationUpdate", 'Float'>
    readonly accuracy: FieldRef<"LocationUpdate", 'Float'>
    readonly speed: FieldRef<"LocationUpdate", 'Float'>
    readonly heading: FieldRef<"LocationUpdate", 'Float'>
    readonly altitude: FieldRef<"LocationUpdate", 'Float'>
    readonly createdAt: FieldRef<"LocationUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LocationUpdate findUnique
   */
  export type LocationUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * Filter, which LocationUpdate to fetch.
     */
    where: LocationUpdateWhereUniqueInput
  }

  /**
   * LocationUpdate findUniqueOrThrow
   */
  export type LocationUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * Filter, which LocationUpdate to fetch.
     */
    where: LocationUpdateWhereUniqueInput
  }

  /**
   * LocationUpdate findFirst
   */
  export type LocationUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * Filter, which LocationUpdate to fetch.
     */
    where?: LocationUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationUpdates to fetch.
     */
    orderBy?: LocationUpdateOrderByWithRelationInput | LocationUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationUpdates.
     */
    cursor?: LocationUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationUpdates.
     */
    distinct?: LocationUpdateScalarFieldEnum | LocationUpdateScalarFieldEnum[]
  }

  /**
   * LocationUpdate findFirstOrThrow
   */
  export type LocationUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * Filter, which LocationUpdate to fetch.
     */
    where?: LocationUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationUpdates to fetch.
     */
    orderBy?: LocationUpdateOrderByWithRelationInput | LocationUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LocationUpdates.
     */
    cursor?: LocationUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LocationUpdates.
     */
    distinct?: LocationUpdateScalarFieldEnum | LocationUpdateScalarFieldEnum[]
  }

  /**
   * LocationUpdate findMany
   */
  export type LocationUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * Filter, which LocationUpdates to fetch.
     */
    where?: LocationUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LocationUpdates to fetch.
     */
    orderBy?: LocationUpdateOrderByWithRelationInput | LocationUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LocationUpdates.
     */
    cursor?: LocationUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LocationUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LocationUpdates.
     */
    skip?: number
    distinct?: LocationUpdateScalarFieldEnum | LocationUpdateScalarFieldEnum[]
  }

  /**
   * LocationUpdate create
   */
  export type LocationUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a LocationUpdate.
     */
    data: XOR<LocationUpdateCreateInput, LocationUpdateUncheckedCreateInput>
  }

  /**
   * LocationUpdate createMany
   */
  export type LocationUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LocationUpdates.
     */
    data: LocationUpdateCreateManyInput | LocationUpdateCreateManyInput[]
  }

  /**
   * LocationUpdate createManyAndReturn
   */
  export type LocationUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * The data used to create many LocationUpdates.
     */
    data: LocationUpdateCreateManyInput | LocationUpdateCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationUpdate update
   */
  export type LocationUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a LocationUpdate.
     */
    data: XOR<LocationUpdateUpdateInput, LocationUpdateUncheckedUpdateInput>
    /**
     * Choose, which LocationUpdate to update.
     */
    where: LocationUpdateWhereUniqueInput
  }

  /**
   * LocationUpdate updateMany
   */
  export type LocationUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LocationUpdates.
     */
    data: XOR<LocationUpdateUpdateManyMutationInput, LocationUpdateUncheckedUpdateManyInput>
    /**
     * Filter which LocationUpdates to update
     */
    where?: LocationUpdateWhereInput
    /**
     * Limit how many LocationUpdates to update.
     */
    limit?: number
  }

  /**
   * LocationUpdate updateManyAndReturn
   */
  export type LocationUpdateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * The data used to update LocationUpdates.
     */
    data: XOR<LocationUpdateUpdateManyMutationInput, LocationUpdateUncheckedUpdateManyInput>
    /**
     * Filter which LocationUpdates to update
     */
    where?: LocationUpdateWhereInput
    /**
     * Limit how many LocationUpdates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LocationUpdate upsert
   */
  export type LocationUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the LocationUpdate to update in case it exists.
     */
    where: LocationUpdateWhereUniqueInput
    /**
     * In case the LocationUpdate found by the `where` argument doesn't exist, create a new LocationUpdate with this data.
     */
    create: XOR<LocationUpdateCreateInput, LocationUpdateUncheckedCreateInput>
    /**
     * In case the LocationUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LocationUpdateUpdateInput, LocationUpdateUncheckedUpdateInput>
  }

  /**
   * LocationUpdate delete
   */
  export type LocationUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
    /**
     * Filter which LocationUpdate to delete.
     */
    where: LocationUpdateWhereUniqueInput
  }

  /**
   * LocationUpdate deleteMany
   */
  export type LocationUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LocationUpdates to delete
     */
    where?: LocationUpdateWhereInput
    /**
     * Limit how many LocationUpdates to delete.
     */
    limit?: number
  }

  /**
   * LocationUpdate without action
   */
  export type LocationUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LocationUpdate
     */
    select?: LocationUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LocationUpdate
     */
    omit?: LocationUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LocationUpdateInclude<ExtArgs> | null
  }


  /**
   * Model Subscription
   */

  export type AggregateSubscription = {
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  export type SubscriptionAvgAggregateOutputType = {
    pricePerMonth: number | null
  }

  export type SubscriptionSumAggregateOutputType = {
    pricePerMonth: number | null
  }

  export type SubscriptionMinAggregateOutputType = {
    id: string | null
    companyId: string | null
    subscriptionType: $Enums.SubscriptionType | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    endDate: Date | null
    pricePerMonth: number | null
    paymentProvider: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionMaxAggregateOutputType = {
    id: string | null
    companyId: string | null
    subscriptionType: $Enums.SubscriptionType | null
    status: $Enums.SubscriptionStatus | null
    startDate: Date | null
    endDate: Date | null
    pricePerMonth: number | null
    paymentProvider: string | null
    externalId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SubscriptionCountAggregateOutputType = {
    id: number
    companyId: number
    subscriptionType: number
    status: number
    startDate: number
    endDate: number
    pricePerMonth: number
    paymentProvider: number
    externalId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SubscriptionAvgAggregateInputType = {
    pricePerMonth?: true
  }

  export type SubscriptionSumAggregateInputType = {
    pricePerMonth?: true
  }

  export type SubscriptionMinAggregateInputType = {
    id?: true
    companyId?: true
    subscriptionType?: true
    status?: true
    startDate?: true
    endDate?: true
    pricePerMonth?: true
    paymentProvider?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionMaxAggregateInputType = {
    id?: true
    companyId?: true
    subscriptionType?: true
    status?: true
    startDate?: true
    endDate?: true
    pricePerMonth?: true
    paymentProvider?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SubscriptionCountAggregateInputType = {
    id?: true
    companyId?: true
    subscriptionType?: true
    status?: true
    startDate?: true
    endDate?: true
    pricePerMonth?: true
    paymentProvider?: true
    externalId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscription to aggregate.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Subscriptions
    **/
    _count?: true | SubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionMaxAggregateInputType
  }

  export type GetSubscriptionAggregateType<T extends SubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscription[P]>
      : GetScalarType<T[P], AggregateSubscription[P]>
  }




  export type SubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubscriptionWhereInput
    orderBy?: SubscriptionOrderByWithAggregationInput | SubscriptionOrderByWithAggregationInput[]
    by: SubscriptionScalarFieldEnum[] | SubscriptionScalarFieldEnum
    having?: SubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionCountAggregateInputType | true
    _avg?: SubscriptionAvgAggregateInputType
    _sum?: SubscriptionSumAggregateInputType
    _min?: SubscriptionMinAggregateInputType
    _max?: SubscriptionMaxAggregateInputType
  }

  export type SubscriptionGroupByOutputType = {
    id: string
    companyId: string
    subscriptionType: $Enums.SubscriptionType
    status: $Enums.SubscriptionStatus
    startDate: Date
    endDate: Date | null
    pricePerMonth: number
    paymentProvider: string | null
    externalId: string | null
    createdAt: Date
    updatedAt: Date
    _count: SubscriptionCountAggregateOutputType | null
    _avg: SubscriptionAvgAggregateOutputType | null
    _sum: SubscriptionSumAggregateOutputType | null
    _min: SubscriptionMinAggregateOutputType | null
    _max: SubscriptionMaxAggregateOutputType | null
  }

  type GetSubscriptionGroupByPayload<T extends SubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type SubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    subscriptionType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    pricePerMonth?: boolean
    paymentProvider?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    subscriptionType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    pricePerMonth?: boolean
    paymentProvider?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    companyId?: boolean
    subscriptionType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    pricePerMonth?: boolean
    paymentProvider?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscription"]>

  export type SubscriptionSelectScalar = {
    id?: boolean
    companyId?: boolean
    subscriptionType?: boolean
    status?: boolean
    startDate?: boolean
    endDate?: boolean
    pricePerMonth?: boolean
    paymentProvider?: boolean
    externalId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "companyId" | "subscriptionType" | "status" | "startDate" | "endDate" | "pricePerMonth" | "paymentProvider" | "externalId" | "createdAt" | "updatedAt", ExtArgs["result"]["subscription"]>
  export type SubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
    payments?: boolean | Subscription$paymentsArgs<ExtArgs>
    _count?: boolean | SubscriptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }
  export type SubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company?: boolean | CompanyDefaultArgs<ExtArgs>
  }

  export type $SubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Subscription"
    objects: {
      company: Prisma.$CompanyPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      companyId: string
      subscriptionType: $Enums.SubscriptionType
      status: $Enums.SubscriptionStatus
      startDate: Date
      endDate: Date | null
      pricePerMonth: number
      paymentProvider: string | null
      externalId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["subscription"]>
    composites: {}
  }

  type SubscriptionGetPayload<S extends boolean | null | undefined | SubscriptionDefaultArgs> = $Result.GetResult<Prisma.$SubscriptionPayload, S>

  type SubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionCountAggregateInputType | true
    }

  export interface SubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Subscription'], meta: { name: 'Subscription' } }
    /**
     * Find zero or one Subscription that matches the filter.
     * @param {SubscriptionFindUniqueArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubscriptionFindUniqueArgs>(args: SelectSubset<T, SubscriptionFindUniqueArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SubscriptionFindUniqueOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, SubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubscriptionFindFirstArgs>(args?: SelectSubset<T, SubscriptionFindFirstArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindFirstOrThrowArgs} args - Arguments to find a Subscription
     * @example
     * // Get one Subscription
     * const subscription = await prisma.subscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, SubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscription.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubscriptionFindManyArgs>(args?: SelectSubset<T, SubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscription.
     * @param {SubscriptionCreateArgs} args - Arguments to create a Subscription.
     * @example
     * // Create one Subscription
     * const Subscription = await prisma.subscription.create({
     *   data: {
     *     // ... data to create a Subscription
     *   }
     * })
     * 
     */
    create<T extends SubscriptionCreateArgs>(args: SelectSubset<T, SubscriptionCreateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {SubscriptionCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubscriptionCreateManyArgs>(args?: SelectSubset<T, SubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Subscriptions and returns the data saved in the database.
     * @param {SubscriptionCreateManyAndReturnArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscription = await prisma.subscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, SubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Subscription.
     * @param {SubscriptionDeleteArgs} args - Arguments to delete one Subscription.
     * @example
     * // Delete one Subscription
     * const Subscription = await prisma.subscription.delete({
     *   where: {
     *     // ... filter to delete one Subscription
     *   }
     * })
     * 
     */
    delete<T extends SubscriptionDeleteArgs>(args: SelectSubset<T, SubscriptionDeleteArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscription.
     * @param {SubscriptionUpdateArgs} args - Arguments to update one Subscription.
     * @example
     * // Update one Subscription
     * const subscription = await prisma.subscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubscriptionUpdateArgs>(args: SelectSubset<T, SubscriptionUpdateArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {SubscriptionDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubscriptionDeleteManyArgs>(args?: SelectSubset<T, SubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubscriptionUpdateManyArgs>(args: SelectSubset<T, SubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions and returns the data updated in the database.
     * @param {SubscriptionUpdateManyAndReturnArgs} args - Arguments to update many Subscriptions.
     * @example
     * // Update many Subscriptions
     * const subscription = await prisma.subscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Subscriptions and only return the `id`
     * const subscriptionWithIdOnly = await prisma.subscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, SubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Subscription.
     * @param {SubscriptionUpsertArgs} args - Arguments to update or create a Subscription.
     * @example
     * // Update or create a Subscription
     * const subscription = await prisma.subscription.upsert({
     *   create: {
     *     // ... data to create a Subscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscription we want to update
     *   }
     * })
     */
    upsert<T extends SubscriptionUpsertArgs>(args: SelectSubset<T, SubscriptionUpsertArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscription.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends SubscriptionCountArgs>(
      args?: Subset<T, SubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionAggregateArgs>(args: Subset<T, SubscriptionAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionAggregateType<T>>

    /**
     * Group by Subscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: SubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Subscription model
   */
  readonly fields: SubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Subscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company<T extends CompanyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CompanyDefaultArgs<ExtArgs>>): Prisma__CompanyClient<$Result.GetResult<Prisma.$CompanyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Subscription$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Subscription$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Subscription model
   */
  interface SubscriptionFieldRefs {
    readonly id: FieldRef<"Subscription", 'String'>
    readonly companyId: FieldRef<"Subscription", 'String'>
    readonly subscriptionType: FieldRef<"Subscription", 'SubscriptionType'>
    readonly status: FieldRef<"Subscription", 'SubscriptionStatus'>
    readonly startDate: FieldRef<"Subscription", 'DateTime'>
    readonly endDate: FieldRef<"Subscription", 'DateTime'>
    readonly pricePerMonth: FieldRef<"Subscription", 'Float'>
    readonly paymentProvider: FieldRef<"Subscription", 'String'>
    readonly externalId: FieldRef<"Subscription", 'String'>
    readonly createdAt: FieldRef<"Subscription", 'DateTime'>
    readonly updatedAt: FieldRef<"Subscription", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Subscription findUnique
   */
  export type SubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findUniqueOrThrow
   */
  export type SubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription findFirst
   */
  export type SubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findFirstOrThrow
   */
  export type SubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscription to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Subscriptions.
     */
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription findMany
   */
  export type SubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which Subscriptions to fetch.
     */
    where?: SubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Subscriptions to fetch.
     */
    orderBy?: SubscriptionOrderByWithRelationInput | SubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Subscriptions.
     */
    cursor?: SubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Subscriptions.
     */
    skip?: number
    distinct?: SubscriptionScalarFieldEnum | SubscriptionScalarFieldEnum[]
  }

  /**
   * Subscription create
   */
  export type SubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a Subscription.
     */
    data: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
  }

  /**
   * Subscription createMany
   */
  export type SubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
  }

  /**
   * Subscription createManyAndReturn
   */
  export type SubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many Subscriptions.
     */
    data: SubscriptionCreateManyInput | SubscriptionCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription update
   */
  export type SubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a Subscription.
     */
    data: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
    /**
     * Choose, which Subscription to update.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription updateMany
   */
  export type SubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
  }

  /**
   * Subscription updateManyAndReturn
   */
  export type SubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update Subscriptions.
     */
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which Subscriptions to update
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Subscription upsert
   */
  export type SubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the Subscription to update in case it exists.
     */
    where: SubscriptionWhereUniqueInput
    /**
     * In case the Subscription found by the `where` argument doesn't exist, create a new Subscription with this data.
     */
    create: XOR<SubscriptionCreateInput, SubscriptionUncheckedCreateInput>
    /**
     * In case the Subscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubscriptionUpdateInput, SubscriptionUncheckedUpdateInput>
  }

  /**
   * Subscription delete
   */
  export type SubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
    /**
     * Filter which Subscription to delete.
     */
    where: SubscriptionWhereUniqueInput
  }

  /**
   * Subscription deleteMany
   */
  export type SubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Subscriptions to delete
     */
    where?: SubscriptionWhereInput
    /**
     * Limit how many Subscriptions to delete.
     */
    limit?: number
  }

  /**
   * Subscription.payments
   */
  export type Subscription$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Subscription without action
   */
  export type SubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Subscription
     */
    select?: SubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Subscription
     */
    omit?: SubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    provider: string | null
    externalId: string | null
    paymentMethod: string | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    subscriptionId: string | null
    amount: number | null
    currency: string | null
    status: $Enums.PaymentStatus | null
    provider: string | null
    externalId: string | null
    paymentMethod: string | null
    periodStart: Date | null
    periodEnd: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    subscriptionId: number
    amount: number
    currency: number
    status: number
    provider: number
    externalId: number
    paymentMethod: number
    periodStart: number
    periodEnd: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    provider?: true
    externalId?: true
    paymentMethod?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    provider?: true
    externalId?: true
    paymentMethod?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    subscriptionId?: true
    amount?: true
    currency?: true
    status?: true
    provider?: true
    externalId?: true
    paymentMethod?: true
    periodStart?: true
    periodEnd?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    subscriptionId: string
    amount: number
    currency: string
    status: $Enums.PaymentStatus
    provider: string
    externalId: string | null
    paymentMethod: string | null
    periodStart: Date
    periodEnd: Date
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    provider?: boolean
    externalId?: boolean
    paymentMethod?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    provider?: boolean
    externalId?: boolean
    paymentMethod?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    provider?: boolean
    externalId?: boolean
    paymentMethod?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    subscriptionId?: boolean
    amount?: boolean
    currency?: boolean
    status?: boolean
    provider?: boolean
    externalId?: boolean
    paymentMethod?: boolean
    periodStart?: boolean
    periodEnd?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "subscriptionId" | "amount" | "currency" | "status" | "provider" | "externalId" | "paymentMethod" | "periodStart" | "periodEnd" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subscription?: boolean | SubscriptionDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      subscription: Prisma.$SubscriptionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      subscriptionId: string
      amount: number
      currency: string
      status: $Enums.PaymentStatus
      provider: string
      externalId: string | null
      paymentMethod: string | null
      periodStart: Date
      periodEnd: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    subscription<T extends SubscriptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SubscriptionDefaultArgs<ExtArgs>>): Prisma__SubscriptionClient<$Result.GetResult<Prisma.$SubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly subscriptionId: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly currency: FieldRef<"Payment", 'String'>
    readonly status: FieldRef<"Payment", 'PaymentStatus'>
    readonly provider: FieldRef<"Payment", 'String'>
    readonly externalId: FieldRef<"Payment", 'String'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly periodStart: FieldRef<"Payment", 'DateTime'>
    readonly periodEnd: FieldRef<"Payment", 'DateTime'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    password: 'password',
    role: 'role',
    phone: 'phone',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const CompanyScalarFieldEnum: {
    id: 'id',
    name: 'name',
    address: 'address',
    taxNumber: 'taxNumber',
    taxiLicenseNumber: 'taxiLicenseNumber',
    contactPersonName: 'contactPersonName',
    contactPersonEmail: 'contactPersonEmail',
    contactPersonPhone: 'contactPersonPhone',
    email: 'email',
    phone: 'phone',
    bankAccount: 'bankAccount',
    subscriptionType: 'subscriptionType',
    logo: 'logo',
    status: 'status',
    chironClientId: 'chironClientId',
    chironClientSecret: 'chironClientSecret',
    chironJwtTokenId: 'chironJwtTokenId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CompanyScalarFieldEnum = (typeof CompanyScalarFieldEnum)[keyof typeof CompanyScalarFieldEnum]


  export const CompanyUserScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    role: 'role',
    createdAt: 'createdAt'
  };

  export type CompanyUserScalarFieldEnum = (typeof CompanyUserScalarFieldEnum)[keyof typeof CompanyUserScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    licensePlate: 'licensePlate',
    brand: 'brand',
    model: 'model',
    year: 'year',
    color: 'color',
    taxiLicenseNumber: 'taxiLicenseNumber',
    insuranceExpiry: 'insuranceExpiry',
    keuringExpiry: 'keuringExpiry',
    pictures: 'pictures',
    status: 'status',
    taxiLightWebhookOnUrl: 'taxiLightWebhookOnUrl',
    taxiLightWebhookOffUrl: 'taxiLightWebhookOffUrl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const DriverScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    companyId: 'companyId',
    vehicleId: 'vehicleId',
    firstName: 'firstName',
    lastName: 'lastName',
    taxiDriverLicense: 'taxiDriverLicense',
    licenseExpiry: 'licenseExpiry',
    address: 'address',
    phone: 'phone',
    email: 'email',
    picture: 'picture',
    status: 'status',
    isOnline: 'isOnline',
    currentLatitude: 'currentLatitude',
    currentLongitude: 'currentLongitude',
    lastLocationUpdate: 'lastLocationUpdate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DriverScalarFieldEnum = (typeof DriverScalarFieldEnum)[keyof typeof DriverScalarFieldEnum]


  export const TariffScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    vehicleId: 'vehicleId',
    name: 'name',
    code: 'code',
    type: 'type',
    startPrice: 'startPrice',
    pricePerKm: 'pricePerKm',
    pricePerMinute: 'pricePerMinute',
    nightSurcharge: 'nightSurcharge',
    weekendSurcharge: 'weekendSurcharge',
    isActive: 'isActive',
    nightStartTime: 'nightStartTime',
    nightEndTime: 'nightEndTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TariffScalarFieldEnum = (typeof TariffScalarFieldEnum)[keyof typeof TariffScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    riderId: 'riderId',
    companyId: 'companyId',
    driverId: 'driverId',
    vehicleId: 'vehicleId',
    tariffId: 'tariffId',
    pickupLatitude: 'pickupLatitude',
    pickupLongitude: 'pickupLongitude',
    pickupAddress: 'pickupAddress',
    destinationLatitude: 'destinationLatitude',
    destinationLongitude: 'destinationLongitude',
    destinationAddress: 'destinationAddress',
    estimatedPrice: 'estimatedPrice',
    finalPrice: 'finalPrice',
    estimatedDuration: 'estimatedDuration',
    actualDuration: 'actualDuration',
    distance: 'distance',
    riderName: 'riderName',
    riderPhone: 'riderPhone',
    notes: 'notes',
    scheduledTime: 'scheduledTime',
    acceptedAt: 'acceptedAt',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    cancelledAt: 'cancelledAt',
    status: 'status',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const TripLogScalarFieldEnum: {
    id: 'id',
    parentId: 'parentId',
    logType: 'logType',
    companyId: 'companyId',
    vehicleId: 'vehicleId',
    driverId: 'driverId',
    userId: 'userId',
    bookingId: 'bookingId',
    startLatitude: 'startLatitude',
    startLongitude: 'startLongitude',
    startAddress: 'startAddress',
    endLatitude: 'endLatitude',
    endLongitude: 'endLongitude',
    endAddress: 'endAddress',
    distance: 'distance',
    duration: 'duration',
    finalPrice: 'finalPrice',
    tariffUsed: 'tariffUsed',
    governmentTripId: 'governmentTripId',
    tripStartApiSent: 'tripStartApiSent',
    tripEndApiSent: 'tripEndApiSent',
    apiErrorLog: 'apiErrorLog',
    logDetails: 'logDetails',
    tripStartTime: 'tripStartTime',
    tripEndTime: 'tripEndTime',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TripLogScalarFieldEnum = (typeof TripLogScalarFieldEnum)[keyof typeof TripLogScalarFieldEnum]


  export const GovernmentApiRequestScalarFieldEnum: {
    id: 'id',
    tripLogId: 'tripLogId',
    requestType: 'requestType',
    endpoint: 'endpoint',
    payload: 'payload',
    response: 'response',
    statusCode: 'statusCode',
    success: 'success',
    errorMessage: 'errorMessage',
    retryCount: 'retryCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type GovernmentApiRequestScalarFieldEnum = (typeof GovernmentApiRequestScalarFieldEnum)[keyof typeof GovernmentApiRequestScalarFieldEnum]


  export const LocationUpdateScalarFieldEnum: {
    id: 'id',
    driverId: 'driverId',
    vehicleId: 'vehicleId',
    latitude: 'latitude',
    longitude: 'longitude',
    accuracy: 'accuracy',
    speed: 'speed',
    heading: 'heading',
    altitude: 'altitude',
    createdAt: 'createdAt'
  };

  export type LocationUpdateScalarFieldEnum = (typeof LocationUpdateScalarFieldEnum)[keyof typeof LocationUpdateScalarFieldEnum]


  export const SubscriptionScalarFieldEnum: {
    id: 'id',
    companyId: 'companyId',
    subscriptionType: 'subscriptionType',
    status: 'status',
    startDate: 'startDate',
    endDate: 'endDate',
    pricePerMonth: 'pricePerMonth',
    paymentProvider: 'paymentProvider',
    externalId: 'externalId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SubscriptionScalarFieldEnum = (typeof SubscriptionScalarFieldEnum)[keyof typeof SubscriptionScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    subscriptionId: 'subscriptionId',
    amount: 'amount',
    currency: 'currency',
    status: 'status',
    provider: 'provider',
    externalId: 'externalId',
    paymentMethod: 'paymentMethod',
    periodStart: 'periodStart',
    periodEnd: 'periodEnd',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'SubscriptionType'
   */
  export type EnumSubscriptionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionType'>
    


  /**
   * Reference to a field of type 'CompanyStatus'
   */
  export type EnumCompanyStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'CompanyStatus'>
    


  /**
   * Reference to a field of type 'VehicleStatus'
   */
  export type EnumVehicleStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VehicleStatus'>
    


  /**
   * Reference to a field of type 'DriverStatus'
   */
  export type EnumDriverStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DriverStatus'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'TariffType'
   */
  export type EnumTariffTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TariffType'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'LogType'
   */
  export type EnumLogTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LogType'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ApiRequestType'
   */
  export type EnumApiRequestTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ApiRequestType'>
    


  /**
   * Reference to a field of type 'SubscriptionStatus'
   */
  export type EnumSubscriptionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SubscriptionStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    email?: StringFilter<"User"> | string
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    companyUser?: CompanyUserListRelationFilter
    driverProfile?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    riderBookings?: BookingListRelationFilter
    tripLogs?: TripLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    companyUser?: CompanyUserOrderByRelationAggregateInput
    driverProfile?: DriverOrderByWithRelationInput
    riderBookings?: BookingOrderByRelationAggregateInput
    tripLogs?: TripLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    password?: StringNullableFilter<"User"> | string | null
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    phone?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    companyUser?: CompanyUserListRelationFilter
    driverProfile?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    riderBookings?: BookingListRelationFilter
    tripLogs?: TripLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    email?: SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    password?: SortOrderInput | SortOrder
    role?: SortOrder
    phone?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringWithAggregatesFilter<"User"> | string
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type CompanyWhereInput = {
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    id?: StringFilter<"Company"> | string
    name?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    taxNumber?: StringFilter<"Company"> | string
    taxiLicenseNumber?: StringFilter<"Company"> | string
    contactPersonName?: StringFilter<"Company"> | string
    contactPersonEmail?: StringFilter<"Company"> | string
    contactPersonPhone?: StringFilter<"Company"> | string
    email?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    bankAccount?: StringNullableFilter<"Company"> | string | null
    subscriptionType?: EnumSubscriptionTypeFilter<"Company"> | $Enums.SubscriptionType
    logo?: StringNullableFilter<"Company"> | string | null
    status?: EnumCompanyStatusFilter<"Company"> | $Enums.CompanyStatus
    chironClientId?: StringNullableFilter<"Company"> | string | null
    chironClientSecret?: StringNullableFilter<"Company"> | string | null
    chironJwtTokenId?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    vehicles?: VehicleListRelationFilter
    drivers?: DriverListRelationFilter
    tariffs?: TariffListRelationFilter
    users?: CompanyUserListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    bookings?: BookingListRelationFilter
    tripLogs?: TripLogListRelationFilter
  }

  export type CompanyOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    taxNumber?: SortOrder
    taxiLicenseNumber?: SortOrder
    contactPersonName?: SortOrder
    contactPersonEmail?: SortOrder
    contactPersonPhone?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    bankAccount?: SortOrderInput | SortOrder
    subscriptionType?: SortOrder
    logo?: SortOrderInput | SortOrder
    status?: SortOrder
    chironClientId?: SortOrderInput | SortOrder
    chironClientSecret?: SortOrderInput | SortOrder
    chironJwtTokenId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicles?: VehicleOrderByRelationAggregateInput
    drivers?: DriverOrderByRelationAggregateInput
    tariffs?: TariffOrderByRelationAggregateInput
    users?: CompanyUserOrderByRelationAggregateInput
    subscriptions?: SubscriptionOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    tripLogs?: TripLogOrderByRelationAggregateInput
  }

  export type CompanyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    taxNumber?: string
    taxiLicenseNumber?: string
    AND?: CompanyWhereInput | CompanyWhereInput[]
    OR?: CompanyWhereInput[]
    NOT?: CompanyWhereInput | CompanyWhereInput[]
    name?: StringFilter<"Company"> | string
    address?: StringFilter<"Company"> | string
    contactPersonName?: StringFilter<"Company"> | string
    contactPersonEmail?: StringFilter<"Company"> | string
    contactPersonPhone?: StringFilter<"Company"> | string
    email?: StringFilter<"Company"> | string
    phone?: StringFilter<"Company"> | string
    bankAccount?: StringNullableFilter<"Company"> | string | null
    subscriptionType?: EnumSubscriptionTypeFilter<"Company"> | $Enums.SubscriptionType
    logo?: StringNullableFilter<"Company"> | string | null
    status?: EnumCompanyStatusFilter<"Company"> | $Enums.CompanyStatus
    chironClientId?: StringNullableFilter<"Company"> | string | null
    chironClientSecret?: StringNullableFilter<"Company"> | string | null
    chironJwtTokenId?: StringNullableFilter<"Company"> | string | null
    createdAt?: DateTimeFilter<"Company"> | Date | string
    updatedAt?: DateTimeFilter<"Company"> | Date | string
    vehicles?: VehicleListRelationFilter
    drivers?: DriverListRelationFilter
    tariffs?: TariffListRelationFilter
    users?: CompanyUserListRelationFilter
    subscriptions?: SubscriptionListRelationFilter
    bookings?: BookingListRelationFilter
    tripLogs?: TripLogListRelationFilter
  }, "id" | "taxNumber" | "taxiLicenseNumber">

  export type CompanyOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    taxNumber?: SortOrder
    taxiLicenseNumber?: SortOrder
    contactPersonName?: SortOrder
    contactPersonEmail?: SortOrder
    contactPersonPhone?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    bankAccount?: SortOrderInput | SortOrder
    subscriptionType?: SortOrder
    logo?: SortOrderInput | SortOrder
    status?: SortOrder
    chironClientId?: SortOrderInput | SortOrder
    chironClientSecret?: SortOrderInput | SortOrder
    chironJwtTokenId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CompanyCountOrderByAggregateInput
    _max?: CompanyMaxOrderByAggregateInput
    _min?: CompanyMinOrderByAggregateInput
  }

  export type CompanyScalarWhereWithAggregatesInput = {
    AND?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    OR?: CompanyScalarWhereWithAggregatesInput[]
    NOT?: CompanyScalarWhereWithAggregatesInput | CompanyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Company"> | string
    name?: StringWithAggregatesFilter<"Company"> | string
    address?: StringWithAggregatesFilter<"Company"> | string
    taxNumber?: StringWithAggregatesFilter<"Company"> | string
    taxiLicenseNumber?: StringWithAggregatesFilter<"Company"> | string
    contactPersonName?: StringWithAggregatesFilter<"Company"> | string
    contactPersonEmail?: StringWithAggregatesFilter<"Company"> | string
    contactPersonPhone?: StringWithAggregatesFilter<"Company"> | string
    email?: StringWithAggregatesFilter<"Company"> | string
    phone?: StringWithAggregatesFilter<"Company"> | string
    bankAccount?: StringNullableWithAggregatesFilter<"Company"> | string | null
    subscriptionType?: EnumSubscriptionTypeWithAggregatesFilter<"Company"> | $Enums.SubscriptionType
    logo?: StringNullableWithAggregatesFilter<"Company"> | string | null
    status?: EnumCompanyStatusWithAggregatesFilter<"Company"> | $Enums.CompanyStatus
    chironClientId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    chironClientSecret?: StringNullableWithAggregatesFilter<"Company"> | string | null
    chironJwtTokenId?: StringNullableWithAggregatesFilter<"Company"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Company"> | Date | string
  }

  export type CompanyUserWhereInput = {
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    id?: StringFilter<"CompanyUser"> | string
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: StringFilter<"CompanyUser"> | string
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }

  export type CompanyUserOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
  }

  export type CompanyUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_companyId?: CompanyUserUserIdCompanyIdCompoundUniqueInput
    AND?: CompanyUserWhereInput | CompanyUserWhereInput[]
    OR?: CompanyUserWhereInput[]
    NOT?: CompanyUserWhereInput | CompanyUserWhereInput[]
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: StringFilter<"CompanyUser"> | string
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
  }, "id" | "userId_companyId">

  export type CompanyUserOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    _count?: CompanyUserCountOrderByAggregateInput
    _max?: CompanyUserMaxOrderByAggregateInput
    _min?: CompanyUserMinOrderByAggregateInput
  }

  export type CompanyUserScalarWhereWithAggregatesInput = {
    AND?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    OR?: CompanyUserScalarWhereWithAggregatesInput[]
    NOT?: CompanyUserScalarWhereWithAggregatesInput | CompanyUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CompanyUser"> | string
    userId?: StringWithAggregatesFilter<"CompanyUser"> | string
    companyId?: StringWithAggregatesFilter<"CompanyUser"> | string
    role?: StringWithAggregatesFilter<"CompanyUser"> | string
    createdAt?: DateTimeWithAggregatesFilter<"CompanyUser"> | Date | string
  }

  export type VehicleWhereInput = {
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    companyId?: StringFilter<"Vehicle"> | string
    licensePlate?: StringFilter<"Vehicle"> | string
    brand?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    color?: StringFilter<"Vehicle"> | string
    taxiLicenseNumber?: StringFilter<"Vehicle"> | string
    insuranceExpiry?: DateTimeFilter<"Vehicle"> | Date | string
    keuringExpiry?: DateTimeFilter<"Vehicle"> | Date | string
    pictures?: StringFilter<"Vehicle"> | string
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: StringNullableFilter<"Vehicle"> | string | null
    taxiLightWebhookOffUrl?: StringNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    drivers?: DriverListRelationFilter
    tariffs?: TariffListRelationFilter
    bookings?: BookingListRelationFilter
    tripLogs?: TripLogListRelationFilter
    locationUpdates?: LocationUpdateListRelationFilter
  }

  export type VehicleOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    taxiLicenseNumber?: SortOrder
    insuranceExpiry?: SortOrder
    keuringExpiry?: SortOrder
    pictures?: SortOrder
    status?: SortOrder
    taxiLightWebhookOnUrl?: SortOrderInput | SortOrder
    taxiLightWebhookOffUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    drivers?: DriverOrderByRelationAggregateInput
    tariffs?: TariffOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
    tripLogs?: TripLogOrderByRelationAggregateInput
    locationUpdates?: LocationUpdateOrderByRelationAggregateInput
  }

  export type VehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    licensePlate?: string
    AND?: VehicleWhereInput | VehicleWhereInput[]
    OR?: VehicleWhereInput[]
    NOT?: VehicleWhereInput | VehicleWhereInput[]
    companyId?: StringFilter<"Vehicle"> | string
    brand?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    color?: StringFilter<"Vehicle"> | string
    taxiLicenseNumber?: StringFilter<"Vehicle"> | string
    insuranceExpiry?: DateTimeFilter<"Vehicle"> | Date | string
    keuringExpiry?: DateTimeFilter<"Vehicle"> | Date | string
    pictures?: StringFilter<"Vehicle"> | string
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: StringNullableFilter<"Vehicle"> | string | null
    taxiLightWebhookOffUrl?: StringNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    drivers?: DriverListRelationFilter
    tariffs?: TariffListRelationFilter
    bookings?: BookingListRelationFilter
    tripLogs?: TripLogListRelationFilter
    locationUpdates?: LocationUpdateListRelationFilter
  }, "id" | "licensePlate">

  export type VehicleOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    taxiLicenseNumber?: SortOrder
    insuranceExpiry?: SortOrder
    keuringExpiry?: SortOrder
    pictures?: SortOrder
    status?: SortOrder
    taxiLightWebhookOnUrl?: SortOrderInput | SortOrder
    taxiLightWebhookOffUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VehicleCountOrderByAggregateInput
    _avg?: VehicleAvgOrderByAggregateInput
    _max?: VehicleMaxOrderByAggregateInput
    _min?: VehicleMinOrderByAggregateInput
    _sum?: VehicleSumOrderByAggregateInput
  }

  export type VehicleScalarWhereWithAggregatesInput = {
    AND?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    OR?: VehicleScalarWhereWithAggregatesInput[]
    NOT?: VehicleScalarWhereWithAggregatesInput | VehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vehicle"> | string
    companyId?: StringWithAggregatesFilter<"Vehicle"> | string
    licensePlate?: StringWithAggregatesFilter<"Vehicle"> | string
    brand?: StringWithAggregatesFilter<"Vehicle"> | string
    model?: StringWithAggregatesFilter<"Vehicle"> | string
    year?: IntWithAggregatesFilter<"Vehicle"> | number
    color?: StringWithAggregatesFilter<"Vehicle"> | string
    taxiLicenseNumber?: StringWithAggregatesFilter<"Vehicle"> | string
    insuranceExpiry?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    keuringExpiry?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    pictures?: StringWithAggregatesFilter<"Vehicle"> | string
    status?: EnumVehicleStatusWithAggregatesFilter<"Vehicle"> | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    taxiLightWebhookOffUrl?: StringNullableWithAggregatesFilter<"Vehicle"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Vehicle"> | Date | string
  }

  export type DriverWhereInput = {
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    id?: StringFilter<"Driver"> | string
    userId?: StringFilter<"Driver"> | string
    companyId?: StringFilter<"Driver"> | string
    vehicleId?: StringNullableFilter<"Driver"> | string | null
    firstName?: StringFilter<"Driver"> | string
    lastName?: StringFilter<"Driver"> | string
    taxiDriverLicense?: StringFilter<"Driver"> | string
    licenseExpiry?: DateTimeFilter<"Driver"> | Date | string
    address?: StringFilter<"Driver"> | string
    phone?: StringFilter<"Driver"> | string
    email?: StringFilter<"Driver"> | string
    picture?: StringNullableFilter<"Driver"> | string | null
    status?: EnumDriverStatusFilter<"Driver"> | $Enums.DriverStatus
    isOnline?: BoolFilter<"Driver"> | boolean
    currentLatitude?: FloatNullableFilter<"Driver"> | number | null
    currentLongitude?: FloatNullableFilter<"Driver"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Driver"> | Date | string | null
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    bookings?: BookingListRelationFilter
    tripLogs?: TripLogListRelationFilter
    locationUpdates?: LocationUpdateListRelationFilter
  }

  export type DriverOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    taxiDriverLicense?: SortOrder
    licenseExpiry?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    picture?: SortOrderInput | SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    currentLatitude?: SortOrderInput | SortOrder
    currentLongitude?: SortOrderInput | SortOrder
    lastLocationUpdate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
    tripLogs?: TripLogOrderByRelationAggregateInput
    locationUpdates?: LocationUpdateOrderByRelationAggregateInput
  }

  export type DriverWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    taxiDriverLicense?: string
    AND?: DriverWhereInput | DriverWhereInput[]
    OR?: DriverWhereInput[]
    NOT?: DriverWhereInput | DriverWhereInput[]
    companyId?: StringFilter<"Driver"> | string
    vehicleId?: StringNullableFilter<"Driver"> | string | null
    firstName?: StringFilter<"Driver"> | string
    lastName?: StringFilter<"Driver"> | string
    licenseExpiry?: DateTimeFilter<"Driver"> | Date | string
    address?: StringFilter<"Driver"> | string
    phone?: StringFilter<"Driver"> | string
    email?: StringFilter<"Driver"> | string
    picture?: StringNullableFilter<"Driver"> | string | null
    status?: EnumDriverStatusFilter<"Driver"> | $Enums.DriverStatus
    isOnline?: BoolFilter<"Driver"> | boolean
    currentLatitude?: FloatNullableFilter<"Driver"> | number | null
    currentLongitude?: FloatNullableFilter<"Driver"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Driver"> | Date | string | null
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    bookings?: BookingListRelationFilter
    tripLogs?: TripLogListRelationFilter
    locationUpdates?: LocationUpdateListRelationFilter
  }, "id" | "userId" | "taxiDriverLicense">

  export type DriverOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    taxiDriverLicense?: SortOrder
    licenseExpiry?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    picture?: SortOrderInput | SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    currentLatitude?: SortOrderInput | SortOrder
    currentLongitude?: SortOrderInput | SortOrder
    lastLocationUpdate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DriverCountOrderByAggregateInput
    _avg?: DriverAvgOrderByAggregateInput
    _max?: DriverMaxOrderByAggregateInput
    _min?: DriverMinOrderByAggregateInput
    _sum?: DriverSumOrderByAggregateInput
  }

  export type DriverScalarWhereWithAggregatesInput = {
    AND?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    OR?: DriverScalarWhereWithAggregatesInput[]
    NOT?: DriverScalarWhereWithAggregatesInput | DriverScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Driver"> | string
    userId?: StringWithAggregatesFilter<"Driver"> | string
    companyId?: StringWithAggregatesFilter<"Driver"> | string
    vehicleId?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    firstName?: StringWithAggregatesFilter<"Driver"> | string
    lastName?: StringWithAggregatesFilter<"Driver"> | string
    taxiDriverLicense?: StringWithAggregatesFilter<"Driver"> | string
    licenseExpiry?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    address?: StringWithAggregatesFilter<"Driver"> | string
    phone?: StringWithAggregatesFilter<"Driver"> | string
    email?: StringWithAggregatesFilter<"Driver"> | string
    picture?: StringNullableWithAggregatesFilter<"Driver"> | string | null
    status?: EnumDriverStatusWithAggregatesFilter<"Driver"> | $Enums.DriverStatus
    isOnline?: BoolWithAggregatesFilter<"Driver"> | boolean
    currentLatitude?: FloatNullableWithAggregatesFilter<"Driver"> | number | null
    currentLongitude?: FloatNullableWithAggregatesFilter<"Driver"> | number | null
    lastLocationUpdate?: DateTimeNullableWithAggregatesFilter<"Driver"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Driver"> | Date | string
  }

  export type TariffWhereInput = {
    AND?: TariffWhereInput | TariffWhereInput[]
    OR?: TariffWhereInput[]
    NOT?: TariffWhereInput | TariffWhereInput[]
    id?: StringFilter<"Tariff"> | string
    companyId?: StringFilter<"Tariff"> | string
    vehicleId?: StringNullableFilter<"Tariff"> | string | null
    name?: StringFilter<"Tariff"> | string
    code?: StringFilter<"Tariff"> | string
    type?: EnumTariffTypeFilter<"Tariff"> | $Enums.TariffType
    startPrice?: FloatFilter<"Tariff"> | number
    pricePerKm?: FloatFilter<"Tariff"> | number
    pricePerMinute?: FloatFilter<"Tariff"> | number
    nightSurcharge?: FloatFilter<"Tariff"> | number
    weekendSurcharge?: FloatFilter<"Tariff"> | number
    isActive?: BoolFilter<"Tariff"> | boolean
    nightStartTime?: StringNullableFilter<"Tariff"> | string | null
    nightEndTime?: StringNullableFilter<"Tariff"> | string | null
    createdAt?: DateTimeFilter<"Tariff"> | Date | string
    updatedAt?: DateTimeFilter<"Tariff"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    bookings?: BookingListRelationFilter
  }

  export type TariffOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    pricePerKm?: SortOrder
    pricePerMinute?: SortOrder
    nightSurcharge?: SortOrder
    weekendSurcharge?: SortOrder
    isActive?: SortOrder
    nightStartTime?: SortOrderInput | SortOrder
    nightEndTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type TariffWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TariffWhereInput | TariffWhereInput[]
    OR?: TariffWhereInput[]
    NOT?: TariffWhereInput | TariffWhereInput[]
    companyId?: StringFilter<"Tariff"> | string
    vehicleId?: StringNullableFilter<"Tariff"> | string | null
    name?: StringFilter<"Tariff"> | string
    code?: StringFilter<"Tariff"> | string
    type?: EnumTariffTypeFilter<"Tariff"> | $Enums.TariffType
    startPrice?: FloatFilter<"Tariff"> | number
    pricePerKm?: FloatFilter<"Tariff"> | number
    pricePerMinute?: FloatFilter<"Tariff"> | number
    nightSurcharge?: FloatFilter<"Tariff"> | number
    weekendSurcharge?: FloatFilter<"Tariff"> | number
    isActive?: BoolFilter<"Tariff"> | boolean
    nightStartTime?: StringNullableFilter<"Tariff"> | string | null
    nightEndTime?: StringNullableFilter<"Tariff"> | string | null
    createdAt?: DateTimeFilter<"Tariff"> | Date | string
    updatedAt?: DateTimeFilter<"Tariff"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    bookings?: BookingListRelationFilter
  }, "id">

  export type TariffOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    pricePerKm?: SortOrder
    pricePerMinute?: SortOrder
    nightSurcharge?: SortOrder
    weekendSurcharge?: SortOrder
    isActive?: SortOrder
    nightStartTime?: SortOrderInput | SortOrder
    nightEndTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TariffCountOrderByAggregateInput
    _avg?: TariffAvgOrderByAggregateInput
    _max?: TariffMaxOrderByAggregateInput
    _min?: TariffMinOrderByAggregateInput
    _sum?: TariffSumOrderByAggregateInput
  }

  export type TariffScalarWhereWithAggregatesInput = {
    AND?: TariffScalarWhereWithAggregatesInput | TariffScalarWhereWithAggregatesInput[]
    OR?: TariffScalarWhereWithAggregatesInput[]
    NOT?: TariffScalarWhereWithAggregatesInput | TariffScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tariff"> | string
    companyId?: StringWithAggregatesFilter<"Tariff"> | string
    vehicleId?: StringNullableWithAggregatesFilter<"Tariff"> | string | null
    name?: StringWithAggregatesFilter<"Tariff"> | string
    code?: StringWithAggregatesFilter<"Tariff"> | string
    type?: EnumTariffTypeWithAggregatesFilter<"Tariff"> | $Enums.TariffType
    startPrice?: FloatWithAggregatesFilter<"Tariff"> | number
    pricePerKm?: FloatWithAggregatesFilter<"Tariff"> | number
    pricePerMinute?: FloatWithAggregatesFilter<"Tariff"> | number
    nightSurcharge?: FloatWithAggregatesFilter<"Tariff"> | number
    weekendSurcharge?: FloatWithAggregatesFilter<"Tariff"> | number
    isActive?: BoolWithAggregatesFilter<"Tariff"> | boolean
    nightStartTime?: StringNullableWithAggregatesFilter<"Tariff"> | string | null
    nightEndTime?: StringNullableWithAggregatesFilter<"Tariff"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Tariff"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tariff"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    riderId?: StringFilter<"Booking"> | string
    companyId?: StringFilter<"Booking"> | string
    driverId?: StringNullableFilter<"Booking"> | string | null
    vehicleId?: StringNullableFilter<"Booking"> | string | null
    tariffId?: StringFilter<"Booking"> | string
    pickupLatitude?: FloatFilter<"Booking"> | number
    pickupLongitude?: FloatFilter<"Booking"> | number
    pickupAddress?: StringFilter<"Booking"> | string
    destinationLatitude?: FloatNullableFilter<"Booking"> | number | null
    destinationLongitude?: FloatNullableFilter<"Booking"> | number | null
    destinationAddress?: StringNullableFilter<"Booking"> | string | null
    estimatedPrice?: FloatNullableFilter<"Booking"> | number | null
    finalPrice?: FloatNullableFilter<"Booking"> | number | null
    estimatedDuration?: IntNullableFilter<"Booking"> | number | null
    actualDuration?: IntNullableFilter<"Booking"> | number | null
    distance?: FloatNullableFilter<"Booking"> | number | null
    riderName?: StringFilter<"Booking"> | string
    riderPhone?: StringFilter<"Booking"> | string
    notes?: StringNullableFilter<"Booking"> | string | null
    scheduledTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    rider?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    tariff?: XOR<TariffScalarRelationFilter, TariffWhereInput>
    tripLog?: XOR<TripLogNullableScalarRelationFilter, TripLogWhereInput> | null
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    riderId?: SortOrder
    companyId?: SortOrder
    driverId?: SortOrderInput | SortOrder
    vehicleId?: SortOrderInput | SortOrder
    tariffId?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    pickupAddress?: SortOrder
    destinationLatitude?: SortOrderInput | SortOrder
    destinationLongitude?: SortOrderInput | SortOrder
    destinationAddress?: SortOrderInput | SortOrder
    estimatedPrice?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    riderName?: SortOrder
    riderPhone?: SortOrder
    notes?: SortOrderInput | SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    rider?: UserOrderByWithRelationInput
    company?: CompanyOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    tariff?: TariffOrderByWithRelationInput
    tripLog?: TripLogOrderByWithRelationInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    riderId?: StringFilter<"Booking"> | string
    companyId?: StringFilter<"Booking"> | string
    driverId?: StringNullableFilter<"Booking"> | string | null
    vehicleId?: StringNullableFilter<"Booking"> | string | null
    tariffId?: StringFilter<"Booking"> | string
    pickupLatitude?: FloatFilter<"Booking"> | number
    pickupLongitude?: FloatFilter<"Booking"> | number
    pickupAddress?: StringFilter<"Booking"> | string
    destinationLatitude?: FloatNullableFilter<"Booking"> | number | null
    destinationLongitude?: FloatNullableFilter<"Booking"> | number | null
    destinationAddress?: StringNullableFilter<"Booking"> | string | null
    estimatedPrice?: FloatNullableFilter<"Booking"> | number | null
    finalPrice?: FloatNullableFilter<"Booking"> | number | null
    estimatedDuration?: IntNullableFilter<"Booking"> | number | null
    actualDuration?: IntNullableFilter<"Booking"> | number | null
    distance?: FloatNullableFilter<"Booking"> | number | null
    riderName?: StringFilter<"Booking"> | string
    riderPhone?: StringFilter<"Booking"> | string
    notes?: StringNullableFilter<"Booking"> | string | null
    scheduledTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    rider?: XOR<UserScalarRelationFilter, UserWhereInput>
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    tariff?: XOR<TariffScalarRelationFilter, TariffWhereInput>
    tripLog?: XOR<TripLogNullableScalarRelationFilter, TripLogWhereInput> | null
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    riderId?: SortOrder
    companyId?: SortOrder
    driverId?: SortOrderInput | SortOrder
    vehicleId?: SortOrderInput | SortOrder
    tariffId?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    pickupAddress?: SortOrder
    destinationLatitude?: SortOrderInput | SortOrder
    destinationLongitude?: SortOrderInput | SortOrder
    destinationAddress?: SortOrderInput | SortOrder
    estimatedPrice?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    estimatedDuration?: SortOrderInput | SortOrder
    actualDuration?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    riderName?: SortOrder
    riderPhone?: SortOrder
    notes?: SortOrderInput | SortOrder
    scheduledTime?: SortOrderInput | SortOrder
    acceptedAt?: SortOrderInput | SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    riderId?: StringWithAggregatesFilter<"Booking"> | string
    companyId?: StringWithAggregatesFilter<"Booking"> | string
    driverId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    vehicleId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    tariffId?: StringWithAggregatesFilter<"Booking"> | string
    pickupLatitude?: FloatWithAggregatesFilter<"Booking"> | number
    pickupLongitude?: FloatWithAggregatesFilter<"Booking"> | number
    pickupAddress?: StringWithAggregatesFilter<"Booking"> | string
    destinationLatitude?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    destinationLongitude?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    destinationAddress?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    estimatedPrice?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    finalPrice?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    estimatedDuration?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    actualDuration?: IntNullableWithAggregatesFilter<"Booking"> | number | null
    distance?: FloatNullableWithAggregatesFilter<"Booking"> | number | null
    riderName?: StringWithAggregatesFilter<"Booking"> | string
    riderPhone?: StringWithAggregatesFilter<"Booking"> | string
    notes?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    scheduledTime?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    acceptedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    startedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"Booking"> | Date | string | null
    status?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type TripLogWhereInput = {
    AND?: TripLogWhereInput | TripLogWhereInput[]
    OR?: TripLogWhereInput[]
    NOT?: TripLogWhereInput | TripLogWhereInput[]
    id?: StringFilter<"TripLog"> | string
    parentId?: StringNullableFilter<"TripLog"> | string | null
    logType?: EnumLogTypeFilter<"TripLog"> | $Enums.LogType
    companyId?: StringFilter<"TripLog"> | string
    vehicleId?: StringNullableFilter<"TripLog"> | string | null
    driverId?: StringNullableFilter<"TripLog"> | string | null
    userId?: StringNullableFilter<"TripLog"> | string | null
    bookingId?: StringNullableFilter<"TripLog"> | string | null
    startLatitude?: FloatNullableFilter<"TripLog"> | number | null
    startLongitude?: FloatNullableFilter<"TripLog"> | number | null
    startAddress?: StringNullableFilter<"TripLog"> | string | null
    endLatitude?: FloatNullableFilter<"TripLog"> | number | null
    endLongitude?: FloatNullableFilter<"TripLog"> | number | null
    endAddress?: StringNullableFilter<"TripLog"> | string | null
    distance?: FloatNullableFilter<"TripLog"> | number | null
    duration?: IntNullableFilter<"TripLog"> | number | null
    finalPrice?: FloatNullableFilter<"TripLog"> | number | null
    tariffUsed?: StringNullableFilter<"TripLog"> | string | null
    governmentTripId?: StringNullableFilter<"TripLog"> | string | null
    tripStartApiSent?: BoolFilter<"TripLog"> | boolean
    tripEndApiSent?: BoolFilter<"TripLog"> | boolean
    apiErrorLog?: StringNullableFilter<"TripLog"> | string | null
    logDetails?: JsonNullableFilter<"TripLog">
    tripStartTime?: DateTimeNullableFilter<"TripLog"> | Date | string | null
    tripEndTime?: DateTimeNullableFilter<"TripLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TripLog"> | Date | string
    updatedAt?: DateTimeFilter<"TripLog"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    parent?: XOR<TripLogNullableScalarRelationFilter, TripLogWhereInput> | null
    children?: TripLogListRelationFilter
    apiRequests?: GovernmentApiRequestListRelationFilter
  }

  export type TripLogOrderByWithRelationInput = {
    id?: SortOrder
    parentId?: SortOrderInput | SortOrder
    logType?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    startAddress?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    endAddress?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    tariffUsed?: SortOrderInput | SortOrder
    governmentTripId?: SortOrderInput | SortOrder
    tripStartApiSent?: SortOrder
    tripEndApiSent?: SortOrder
    apiErrorLog?: SortOrderInput | SortOrder
    logDetails?: SortOrderInput | SortOrder
    tripStartTime?: SortOrderInput | SortOrder
    tripEndTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
    driver?: DriverOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    booking?: BookingOrderByWithRelationInput
    parent?: TripLogOrderByWithRelationInput
    children?: TripLogOrderByRelationAggregateInput
    apiRequests?: GovernmentApiRequestOrderByRelationAggregateInput
  }

  export type TripLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bookingId?: string
    AND?: TripLogWhereInput | TripLogWhereInput[]
    OR?: TripLogWhereInput[]
    NOT?: TripLogWhereInput | TripLogWhereInput[]
    parentId?: StringNullableFilter<"TripLog"> | string | null
    logType?: EnumLogTypeFilter<"TripLog"> | $Enums.LogType
    companyId?: StringFilter<"TripLog"> | string
    vehicleId?: StringNullableFilter<"TripLog"> | string | null
    driverId?: StringNullableFilter<"TripLog"> | string | null
    userId?: StringNullableFilter<"TripLog"> | string | null
    startLatitude?: FloatNullableFilter<"TripLog"> | number | null
    startLongitude?: FloatNullableFilter<"TripLog"> | number | null
    startAddress?: StringNullableFilter<"TripLog"> | string | null
    endLatitude?: FloatNullableFilter<"TripLog"> | number | null
    endLongitude?: FloatNullableFilter<"TripLog"> | number | null
    endAddress?: StringNullableFilter<"TripLog"> | string | null
    distance?: FloatNullableFilter<"TripLog"> | number | null
    duration?: IntNullableFilter<"TripLog"> | number | null
    finalPrice?: FloatNullableFilter<"TripLog"> | number | null
    tariffUsed?: StringNullableFilter<"TripLog"> | string | null
    governmentTripId?: StringNullableFilter<"TripLog"> | string | null
    tripStartApiSent?: BoolFilter<"TripLog"> | boolean
    tripEndApiSent?: BoolFilter<"TripLog"> | boolean
    apiErrorLog?: StringNullableFilter<"TripLog"> | string | null
    logDetails?: JsonNullableFilter<"TripLog">
    tripStartTime?: DateTimeNullableFilter<"TripLog"> | Date | string | null
    tripEndTime?: DateTimeNullableFilter<"TripLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TripLog"> | Date | string
    updatedAt?: DateTimeFilter<"TripLog"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    vehicle?: XOR<VehicleNullableScalarRelationFilter, VehicleWhereInput> | null
    driver?: XOR<DriverNullableScalarRelationFilter, DriverWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
    parent?: XOR<TripLogNullableScalarRelationFilter, TripLogWhereInput> | null
    children?: TripLogListRelationFilter
    apiRequests?: GovernmentApiRequestListRelationFilter
  }, "id" | "bookingId">

  export type TripLogOrderByWithAggregationInput = {
    id?: SortOrder
    parentId?: SortOrderInput | SortOrder
    logType?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrderInput | SortOrder
    driverId?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    bookingId?: SortOrderInput | SortOrder
    startLatitude?: SortOrderInput | SortOrder
    startLongitude?: SortOrderInput | SortOrder
    startAddress?: SortOrderInput | SortOrder
    endLatitude?: SortOrderInput | SortOrder
    endLongitude?: SortOrderInput | SortOrder
    endAddress?: SortOrderInput | SortOrder
    distance?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    finalPrice?: SortOrderInput | SortOrder
    tariffUsed?: SortOrderInput | SortOrder
    governmentTripId?: SortOrderInput | SortOrder
    tripStartApiSent?: SortOrder
    tripEndApiSent?: SortOrder
    apiErrorLog?: SortOrderInput | SortOrder
    logDetails?: SortOrderInput | SortOrder
    tripStartTime?: SortOrderInput | SortOrder
    tripEndTime?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TripLogCountOrderByAggregateInput
    _avg?: TripLogAvgOrderByAggregateInput
    _max?: TripLogMaxOrderByAggregateInput
    _min?: TripLogMinOrderByAggregateInput
    _sum?: TripLogSumOrderByAggregateInput
  }

  export type TripLogScalarWhereWithAggregatesInput = {
    AND?: TripLogScalarWhereWithAggregatesInput | TripLogScalarWhereWithAggregatesInput[]
    OR?: TripLogScalarWhereWithAggregatesInput[]
    NOT?: TripLogScalarWhereWithAggregatesInput | TripLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TripLog"> | string
    parentId?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    logType?: EnumLogTypeWithAggregatesFilter<"TripLog"> | $Enums.LogType
    companyId?: StringWithAggregatesFilter<"TripLog"> | string
    vehicleId?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    driverId?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    userId?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    bookingId?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    startLatitude?: FloatNullableWithAggregatesFilter<"TripLog"> | number | null
    startLongitude?: FloatNullableWithAggregatesFilter<"TripLog"> | number | null
    startAddress?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    endLatitude?: FloatNullableWithAggregatesFilter<"TripLog"> | number | null
    endLongitude?: FloatNullableWithAggregatesFilter<"TripLog"> | number | null
    endAddress?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    distance?: FloatNullableWithAggregatesFilter<"TripLog"> | number | null
    duration?: IntNullableWithAggregatesFilter<"TripLog"> | number | null
    finalPrice?: FloatNullableWithAggregatesFilter<"TripLog"> | number | null
    tariffUsed?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    governmentTripId?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    tripStartApiSent?: BoolWithAggregatesFilter<"TripLog"> | boolean
    tripEndApiSent?: BoolWithAggregatesFilter<"TripLog"> | boolean
    apiErrorLog?: StringNullableWithAggregatesFilter<"TripLog"> | string | null
    logDetails?: JsonNullableWithAggregatesFilter<"TripLog">
    tripStartTime?: DateTimeNullableWithAggregatesFilter<"TripLog"> | Date | string | null
    tripEndTime?: DateTimeNullableWithAggregatesFilter<"TripLog"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TripLog"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TripLog"> | Date | string
  }

  export type GovernmentApiRequestWhereInput = {
    AND?: GovernmentApiRequestWhereInput | GovernmentApiRequestWhereInput[]
    OR?: GovernmentApiRequestWhereInput[]
    NOT?: GovernmentApiRequestWhereInput | GovernmentApiRequestWhereInput[]
    id?: StringFilter<"GovernmentApiRequest"> | string
    tripLogId?: StringFilter<"GovernmentApiRequest"> | string
    requestType?: EnumApiRequestTypeFilter<"GovernmentApiRequest"> | $Enums.ApiRequestType
    endpoint?: StringFilter<"GovernmentApiRequest"> | string
    payload?: JsonFilter<"GovernmentApiRequest">
    response?: JsonNullableFilter<"GovernmentApiRequest">
    statusCode?: IntNullableFilter<"GovernmentApiRequest"> | number | null
    success?: BoolFilter<"GovernmentApiRequest"> | boolean
    errorMessage?: StringNullableFilter<"GovernmentApiRequest"> | string | null
    retryCount?: IntFilter<"GovernmentApiRequest"> | number
    createdAt?: DateTimeFilter<"GovernmentApiRequest"> | Date | string
    updatedAt?: DateTimeFilter<"GovernmentApiRequest"> | Date | string
    tripLog?: XOR<TripLogScalarRelationFilter, TripLogWhereInput>
  }

  export type GovernmentApiRequestOrderByWithRelationInput = {
    id?: SortOrder
    tripLogId?: SortOrder
    requestType?: SortOrder
    endpoint?: SortOrder
    payload?: SortOrder
    response?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tripLog?: TripLogOrderByWithRelationInput
  }

  export type GovernmentApiRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: GovernmentApiRequestWhereInput | GovernmentApiRequestWhereInput[]
    OR?: GovernmentApiRequestWhereInput[]
    NOT?: GovernmentApiRequestWhereInput | GovernmentApiRequestWhereInput[]
    tripLogId?: StringFilter<"GovernmentApiRequest"> | string
    requestType?: EnumApiRequestTypeFilter<"GovernmentApiRequest"> | $Enums.ApiRequestType
    endpoint?: StringFilter<"GovernmentApiRequest"> | string
    payload?: JsonFilter<"GovernmentApiRequest">
    response?: JsonNullableFilter<"GovernmentApiRequest">
    statusCode?: IntNullableFilter<"GovernmentApiRequest"> | number | null
    success?: BoolFilter<"GovernmentApiRequest"> | boolean
    errorMessage?: StringNullableFilter<"GovernmentApiRequest"> | string | null
    retryCount?: IntFilter<"GovernmentApiRequest"> | number
    createdAt?: DateTimeFilter<"GovernmentApiRequest"> | Date | string
    updatedAt?: DateTimeFilter<"GovernmentApiRequest"> | Date | string
    tripLog?: XOR<TripLogScalarRelationFilter, TripLogWhereInput>
  }, "id">

  export type GovernmentApiRequestOrderByWithAggregationInput = {
    id?: SortOrder
    tripLogId?: SortOrder
    requestType?: SortOrder
    endpoint?: SortOrder
    payload?: SortOrder
    response?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    success?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: GovernmentApiRequestCountOrderByAggregateInput
    _avg?: GovernmentApiRequestAvgOrderByAggregateInput
    _max?: GovernmentApiRequestMaxOrderByAggregateInput
    _min?: GovernmentApiRequestMinOrderByAggregateInput
    _sum?: GovernmentApiRequestSumOrderByAggregateInput
  }

  export type GovernmentApiRequestScalarWhereWithAggregatesInput = {
    AND?: GovernmentApiRequestScalarWhereWithAggregatesInput | GovernmentApiRequestScalarWhereWithAggregatesInput[]
    OR?: GovernmentApiRequestScalarWhereWithAggregatesInput[]
    NOT?: GovernmentApiRequestScalarWhereWithAggregatesInput | GovernmentApiRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GovernmentApiRequest"> | string
    tripLogId?: StringWithAggregatesFilter<"GovernmentApiRequest"> | string
    requestType?: EnumApiRequestTypeWithAggregatesFilter<"GovernmentApiRequest"> | $Enums.ApiRequestType
    endpoint?: StringWithAggregatesFilter<"GovernmentApiRequest"> | string
    payload?: JsonWithAggregatesFilter<"GovernmentApiRequest">
    response?: JsonNullableWithAggregatesFilter<"GovernmentApiRequest">
    statusCode?: IntNullableWithAggregatesFilter<"GovernmentApiRequest"> | number | null
    success?: BoolWithAggregatesFilter<"GovernmentApiRequest"> | boolean
    errorMessage?: StringNullableWithAggregatesFilter<"GovernmentApiRequest"> | string | null
    retryCount?: IntWithAggregatesFilter<"GovernmentApiRequest"> | number
    createdAt?: DateTimeWithAggregatesFilter<"GovernmentApiRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GovernmentApiRequest"> | Date | string
  }

  export type LocationUpdateWhereInput = {
    AND?: LocationUpdateWhereInput | LocationUpdateWhereInput[]
    OR?: LocationUpdateWhereInput[]
    NOT?: LocationUpdateWhereInput | LocationUpdateWhereInput[]
    id?: StringFilter<"LocationUpdate"> | string
    driverId?: StringFilter<"LocationUpdate"> | string
    vehicleId?: StringFilter<"LocationUpdate"> | string
    latitude?: FloatFilter<"LocationUpdate"> | number
    longitude?: FloatFilter<"LocationUpdate"> | number
    accuracy?: FloatNullableFilter<"LocationUpdate"> | number | null
    speed?: FloatNullableFilter<"LocationUpdate"> | number | null
    heading?: FloatNullableFilter<"LocationUpdate"> | number | null
    altitude?: FloatNullableFilter<"LocationUpdate"> | number | null
    createdAt?: DateTimeFilter<"LocationUpdate"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }

  export type LocationUpdateOrderByWithRelationInput = {
    id?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    heading?: SortOrderInput | SortOrder
    altitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    driver?: DriverOrderByWithRelationInput
    vehicle?: VehicleOrderByWithRelationInput
  }

  export type LocationUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LocationUpdateWhereInput | LocationUpdateWhereInput[]
    OR?: LocationUpdateWhereInput[]
    NOT?: LocationUpdateWhereInput | LocationUpdateWhereInput[]
    driverId?: StringFilter<"LocationUpdate"> | string
    vehicleId?: StringFilter<"LocationUpdate"> | string
    latitude?: FloatFilter<"LocationUpdate"> | number
    longitude?: FloatFilter<"LocationUpdate"> | number
    accuracy?: FloatNullableFilter<"LocationUpdate"> | number | null
    speed?: FloatNullableFilter<"LocationUpdate"> | number | null
    heading?: FloatNullableFilter<"LocationUpdate"> | number | null
    altitude?: FloatNullableFilter<"LocationUpdate"> | number | null
    createdAt?: DateTimeFilter<"LocationUpdate"> | Date | string
    driver?: XOR<DriverScalarRelationFilter, DriverWhereInput>
    vehicle?: XOR<VehicleScalarRelationFilter, VehicleWhereInput>
  }, "id">

  export type LocationUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrderInput | SortOrder
    speed?: SortOrderInput | SortOrder
    heading?: SortOrderInput | SortOrder
    altitude?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: LocationUpdateCountOrderByAggregateInput
    _avg?: LocationUpdateAvgOrderByAggregateInput
    _max?: LocationUpdateMaxOrderByAggregateInput
    _min?: LocationUpdateMinOrderByAggregateInput
    _sum?: LocationUpdateSumOrderByAggregateInput
  }

  export type LocationUpdateScalarWhereWithAggregatesInput = {
    AND?: LocationUpdateScalarWhereWithAggregatesInput | LocationUpdateScalarWhereWithAggregatesInput[]
    OR?: LocationUpdateScalarWhereWithAggregatesInput[]
    NOT?: LocationUpdateScalarWhereWithAggregatesInput | LocationUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LocationUpdate"> | string
    driverId?: StringWithAggregatesFilter<"LocationUpdate"> | string
    vehicleId?: StringWithAggregatesFilter<"LocationUpdate"> | string
    latitude?: FloatWithAggregatesFilter<"LocationUpdate"> | number
    longitude?: FloatWithAggregatesFilter<"LocationUpdate"> | number
    accuracy?: FloatNullableWithAggregatesFilter<"LocationUpdate"> | number | null
    speed?: FloatNullableWithAggregatesFilter<"LocationUpdate"> | number | null
    heading?: FloatNullableWithAggregatesFilter<"LocationUpdate"> | number | null
    altitude?: FloatNullableWithAggregatesFilter<"LocationUpdate"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"LocationUpdate"> | Date | string
  }

  export type SubscriptionWhereInput = {
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    id?: StringFilter<"Subscription"> | string
    companyId?: StringFilter<"Subscription"> | string
    subscriptionType?: EnumSubscriptionTypeFilter<"Subscription"> | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pricePerMonth?: FloatFilter<"Subscription"> | number
    paymentProvider?: StringNullableFilter<"Subscription"> | string | null
    externalId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type SubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    companyId?: SortOrder
    subscriptionType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    pricePerMonth?: SortOrder
    paymentProvider?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    company?: CompanyOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type SubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubscriptionWhereInput | SubscriptionWhereInput[]
    OR?: SubscriptionWhereInput[]
    NOT?: SubscriptionWhereInput | SubscriptionWhereInput[]
    companyId?: StringFilter<"Subscription"> | string
    subscriptionType?: EnumSubscriptionTypeFilter<"Subscription"> | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pricePerMonth?: FloatFilter<"Subscription"> | number
    paymentProvider?: StringNullableFilter<"Subscription"> | string | null
    externalId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
    company?: XOR<CompanyScalarRelationFilter, CompanyWhereInput>
    payments?: PaymentListRelationFilter
  }, "id">

  export type SubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    companyId?: SortOrder
    subscriptionType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    pricePerMonth?: SortOrder
    paymentProvider?: SortOrderInput | SortOrder
    externalId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SubscriptionCountOrderByAggregateInput
    _avg?: SubscriptionAvgOrderByAggregateInput
    _max?: SubscriptionMaxOrderByAggregateInput
    _min?: SubscriptionMinOrderByAggregateInput
    _sum?: SubscriptionSumOrderByAggregateInput
  }

  export type SubscriptionScalarWhereWithAggregatesInput = {
    AND?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    OR?: SubscriptionScalarWhereWithAggregatesInput[]
    NOT?: SubscriptionScalarWhereWithAggregatesInput | SubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Subscription"> | string
    companyId?: StringWithAggregatesFilter<"Subscription"> | string
    subscriptionType?: EnumSubscriptionTypeWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusWithAggregatesFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"Subscription"> | Date | string | null
    pricePerMonth?: FloatWithAggregatesFilter<"Subscription"> | number
    paymentProvider?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    externalId?: StringNullableWithAggregatesFilter<"Subscription"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Subscription"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    subscriptionId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    provider?: StringFilter<"Payment"> | string
    externalId?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    periodStart?: DateTimeFilter<"Payment"> | Date | string
    periodEnd?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    externalId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    subscription?: SubscriptionOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    subscriptionId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    provider?: StringFilter<"Payment"> | string
    externalId?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    periodStart?: DateTimeFilter<"Payment"> | Date | string
    periodEnd?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    subscription?: XOR<SubscriptionScalarRelationFilter, SubscriptionWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    externalId?: SortOrderInput | SortOrder
    paymentMethod?: SortOrderInput | SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    subscriptionId?: StringWithAggregatesFilter<"Payment"> | string
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    currency?: StringWithAggregatesFilter<"Payment"> | string
    status?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    provider?: StringWithAggregatesFilter<"Payment"> | string
    externalId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    paymentMethod?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    periodStart?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    periodEnd?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserCreateNestedManyWithoutUserInput
    driverProfile?: DriverCreateNestedOneWithoutUserInput
    riderBookings?: BookingCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    driverProfile?: DriverUncheckedCreateNestedOneWithoutUserInput
    riderBookings?: BookingUncheckedCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUncheckedUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUncheckedUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyCreateInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutCompanyInput
    drivers?: DriverCreateNestedManyWithoutCompanyInput
    tariffs?: TariffCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    bookings?: BookingCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCompanyInput
    drivers?: DriverUncheckedCreateNestedManyWithoutCompanyInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateManyInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserCreateInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCompanyUserInput
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type CompanyUserUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    role?: string
    createdAt?: Date | string
  }

  export type CompanyUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompanyUserNestedInput
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type CompanyUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    role?: string
    createdAt?: Date | string
  }

  export type CompanyUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVehiclesInput
    drivers?: DriverCreateNestedManyWithoutVehicleInput
    tariffs?: TariffCreateNestedManyWithoutVehicleInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateInput = {
    id?: string
    companyId: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVehicleInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVehiclesNestedInput
    drivers?: DriverUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleCreateManyInput = {
    id?: string
    companyId: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateInput = {
    id?: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverProfileInput
    company: CompanyCreateNestedOneWithoutDriversInput
    vehicle?: VehicleCreateNestedOneWithoutDriversInput
    bookings?: BookingCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateInput = {
    id?: string
    userId: string
    companyId: string
    vehicleId?: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverProfileNestedInput
    company?: CompanyUpdateOneRequiredWithoutDriversNestedInput
    vehicle?: VehicleUpdateOneWithoutDriversNestedInput
    bookings?: BookingUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverCreateManyInput = {
    id?: string
    userId: string
    companyId: string
    vehicleId?: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffCreateInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTariffsInput
    vehicle?: VehicleCreateNestedOneWithoutTariffsInput
    bookings?: BookingCreateNestedManyWithoutTariffInput
  }

  export type TariffUncheckedCreateInput = {
    id?: string
    companyId: string
    vehicleId?: string | null
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutTariffInput
  }

  export type TariffUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTariffsNestedInput
    vehicle?: VehicleUpdateOneWithoutTariffsNestedInput
    bookings?: BookingUpdateManyWithoutTariffNestedInput
  }

  export type TariffUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutTariffNestedInput
  }

  export type TariffCreateManyInput = {
    id?: string
    companyId: string
    vehicleId?: string | null
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rider: UserCreateNestedOneWithoutRiderBookingsInput
    company: CompanyCreateNestedOneWithoutBookingsInput
    driver?: DriverCreateNestedOneWithoutBookingsInput
    vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    tariff: TariffCreateNestedOneWithoutBookingsInput
    tripLog?: TripLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    riderId: string
    companyId: string
    driverId?: string | null
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripLog?: TripLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rider?: UserUpdateOneRequiredWithoutRiderBookingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutBookingsNestedInput
    driver?: DriverUpdateOneWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    tariff?: TariffUpdateOneRequiredWithoutBookingsNestedInput
    tripLog?: TripLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripLog?: TripLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    riderId: string
    companyId: string
    driverId?: string | null
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogCreateInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTripLogsInput
    vehicle?: VehicleCreateNestedOneWithoutTripLogsInput
    driver?: DriverCreateNestedOneWithoutTripLogsInput
    user?: UserCreateNestedOneWithoutTripLogsInput
    booking?: BookingCreateNestedOneWithoutTripLogInput
    parent?: TripLogCreateNestedOneWithoutChildrenInput
    children?: TripLogCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUncheckedCreateInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: TripLogUncheckedCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTripLogsNestedInput
    vehicle?: VehicleUpdateOneWithoutTripLogsNestedInput
    driver?: DriverUpdateOneWithoutTripLogsNestedInput
    user?: UserUpdateOneWithoutTripLogsNestedInput
    booking?: BookingUpdateOneWithoutTripLogNestedInput
    parent?: TripLogUpdateOneWithoutChildrenNestedInput
    children?: TripLogUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: TripLogUncheckedUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogCreateManyInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernmentApiRequestCreateInput = {
    id?: string
    requestType: $Enums.ApiRequestType
    endpoint: string
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    success?: boolean
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    tripLog: TripLogCreateNestedOneWithoutApiRequestsInput
  }

  export type GovernmentApiRequestUncheckedCreateInput = {
    id?: string
    tripLogId: string
    requestType: $Enums.ApiRequestType
    endpoint: string
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    success?: boolean
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernmentApiRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumApiRequestTypeFieldUpdateOperationsInput | $Enums.ApiRequestType
    endpoint?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripLog?: TripLogUpdateOneRequiredWithoutApiRequestsNestedInput
  }

  export type GovernmentApiRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripLogId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumApiRequestTypeFieldUpdateOperationsInput | $Enums.ApiRequestType
    endpoint?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernmentApiRequestCreateManyInput = {
    id?: string
    tripLogId: string
    requestType: $Enums.ApiRequestType
    endpoint: string
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    success?: boolean
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernmentApiRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumApiRequestTypeFieldUpdateOperationsInput | $Enums.ApiRequestType
    endpoint?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernmentApiRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tripLogId?: StringFieldUpdateOperationsInput | string
    requestType?: EnumApiRequestTypeFieldUpdateOperationsInput | $Enums.ApiRequestType
    endpoint?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateCreateInput = {
    id?: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
    driver: DriverCreateNestedOneWithoutLocationUpdatesInput
    vehicle: VehicleCreateNestedOneWithoutLocationUpdatesInput
  }

  export type LocationUpdateUncheckedCreateInput = {
    id?: string
    driverId: string
    vehicleId: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
  }

  export type LocationUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutLocationUpdatesNestedInput
    vehicle?: VehicleUpdateOneRequiredWithoutLocationUpdatesNestedInput
  }

  export type LocationUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateCreateManyInput = {
    id?: string
    driverId: string
    vehicleId: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
  }

  export type LocationUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionCreateInput = {
    id?: string
    subscriptionType: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate?: Date | string | null
    pricePerMonth: number
    paymentProvider?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSubscriptionsInput
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateInput = {
    id?: string
    companyId: string
    subscriptionType: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate?: Date | string | null
    pricePerMonth: number
    paymentProvider?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSubscriptionsNestedInput
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionCreateManyInput = {
    id?: string
    companyId: string
    subscriptionType: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate?: Date | string | null
    pricePerMonth: number
    paymentProvider?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    provider: string
    externalId?: string | null
    paymentMethod?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    subscription: SubscriptionCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    subscriptionId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    provider: string
    externalId?: string | null
    paymentMethod?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    subscription?: SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    subscriptionId: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    provider: string
    externalId?: string | null
    paymentMethod?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionId?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type CompanyUserListRelationFilter = {
    every?: CompanyUserWhereInput
    some?: CompanyUserWhereInput
    none?: CompanyUserWhereInput
  }

  export type DriverNullableScalarRelationFilter = {
    is?: DriverWhereInput | null
    isNot?: DriverWhereInput | null
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type TripLogListRelationFilter = {
    every?: TripLogWhereInput
    some?: TripLogWhereInput
    none?: TripLogWhereInput
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    password?: SortOrder
    role?: SortOrder
    phone?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[]
    notIn?: $Enums.SubscriptionType[]
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type EnumCompanyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[]
    notIn?: $Enums.CompanyStatus[]
    not?: NestedEnumCompanyStatusFilter<$PrismaModel> | $Enums.CompanyStatus
  }

  export type VehicleListRelationFilter = {
    every?: VehicleWhereInput
    some?: VehicleWhereInput
    none?: VehicleWhereInput
  }

  export type DriverListRelationFilter = {
    every?: DriverWhereInput
    some?: DriverWhereInput
    none?: DriverWhereInput
  }

  export type TariffListRelationFilter = {
    every?: TariffWhereInput
    some?: TariffWhereInput
    none?: TariffWhereInput
  }

  export type SubscriptionListRelationFilter = {
    every?: SubscriptionWhereInput
    some?: SubscriptionWhereInput
    none?: SubscriptionWhereInput
  }

  export type VehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DriverOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TariffOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CompanyCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    taxNumber?: SortOrder
    taxiLicenseNumber?: SortOrder
    contactPersonName?: SortOrder
    contactPersonEmail?: SortOrder
    contactPersonPhone?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    bankAccount?: SortOrder
    subscriptionType?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    chironClientId?: SortOrder
    chironClientSecret?: SortOrder
    chironJwtTokenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    taxNumber?: SortOrder
    taxiLicenseNumber?: SortOrder
    contactPersonName?: SortOrder
    contactPersonEmail?: SortOrder
    contactPersonPhone?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    bankAccount?: SortOrder
    subscriptionType?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    chironClientId?: SortOrder
    chironClientSecret?: SortOrder
    chironJwtTokenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CompanyMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    address?: SortOrder
    taxNumber?: SortOrder
    taxiLicenseNumber?: SortOrder
    contactPersonName?: SortOrder
    contactPersonEmail?: SortOrder
    contactPersonPhone?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    bankAccount?: SortOrder
    subscriptionType?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    chironClientId?: SortOrder
    chironClientSecret?: SortOrder
    chironJwtTokenId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[]
    notIn?: $Enums.SubscriptionType[]
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type EnumCompanyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[]
    notIn?: $Enums.CompanyStatus[]
    not?: NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatusFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatusFilter<$PrismaModel>
  }

  export type CompanyScalarRelationFilter = {
    is?: CompanyWhereInput
    isNot?: CompanyWhereInput
  }

  export type CompanyUserUserIdCompanyIdCompoundUniqueInput = {
    userId: string
    companyId: string
  }

  export type CompanyUserCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyUserMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type CompanyUserMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumVehicleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[]
    notIn?: $Enums.VehicleStatus[]
    not?: NestedEnumVehicleStatusFilter<$PrismaModel> | $Enums.VehicleStatus
  }

  export type LocationUpdateListRelationFilter = {
    every?: LocationUpdateWhereInput
    some?: LocationUpdateWhereInput
    none?: LocationUpdateWhereInput
  }

  export type LocationUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VehicleCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    taxiLicenseNumber?: SortOrder
    insuranceExpiry?: SortOrder
    keuringExpiry?: SortOrder
    pictures?: SortOrder
    status?: SortOrder
    taxiLightWebhookOnUrl?: SortOrder
    taxiLightWebhookOffUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type VehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    taxiLicenseNumber?: SortOrder
    insuranceExpiry?: SortOrder
    keuringExpiry?: SortOrder
    pictures?: SortOrder
    status?: SortOrder
    taxiLightWebhookOnUrl?: SortOrder
    taxiLightWebhookOffUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    licensePlate?: SortOrder
    brand?: SortOrder
    model?: SortOrder
    year?: SortOrder
    color?: SortOrder
    taxiLicenseNumber?: SortOrder
    insuranceExpiry?: SortOrder
    keuringExpiry?: SortOrder
    pictures?: SortOrder
    status?: SortOrder
    taxiLightWebhookOnUrl?: SortOrder
    taxiLightWebhookOffUrl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumVehicleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[]
    notIn?: $Enums.VehicleStatus[]
    not?: NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel> | $Enums.VehicleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleStatusFilter<$PrismaModel>
    _max?: NestedEnumVehicleStatusFilter<$PrismaModel>
  }

  export type EnumDriverStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DriverStatus | EnumDriverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DriverStatus[]
    notIn?: $Enums.DriverStatus[]
    not?: NestedEnumDriverStatusFilter<$PrismaModel> | $Enums.DriverStatus
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type VehicleNullableScalarRelationFilter = {
    is?: VehicleWhereInput | null
    isNot?: VehicleWhereInput | null
  }

  export type DriverCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    taxiDriverLicense?: SortOrder
    licenseExpiry?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    picture?: SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverAvgOrderByAggregateInput = {
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
  }

  export type DriverMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    taxiDriverLicense?: SortOrder
    licenseExpiry?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    picture?: SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    taxiDriverLicense?: SortOrder
    licenseExpiry?: SortOrder
    address?: SortOrder
    phone?: SortOrder
    email?: SortOrder
    picture?: SortOrder
    status?: SortOrder
    isOnline?: SortOrder
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
    lastLocationUpdate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DriverSumOrderByAggregateInput = {
    currentLatitude?: SortOrder
    currentLongitude?: SortOrder
  }

  export type EnumDriverStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DriverStatus | EnumDriverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DriverStatus[]
    notIn?: $Enums.DriverStatus[]
    not?: NestedEnumDriverStatusWithAggregatesFilter<$PrismaModel> | $Enums.DriverStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDriverStatusFilter<$PrismaModel>
    _max?: NestedEnumDriverStatusFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumTariffTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TariffType | EnumTariffTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TariffType[]
    notIn?: $Enums.TariffType[]
    not?: NestedEnumTariffTypeFilter<$PrismaModel> | $Enums.TariffType
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type TariffCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    pricePerKm?: SortOrder
    pricePerMinute?: SortOrder
    nightSurcharge?: SortOrder
    weekendSurcharge?: SortOrder
    isActive?: SortOrder
    nightStartTime?: SortOrder
    nightEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffAvgOrderByAggregateInput = {
    startPrice?: SortOrder
    pricePerKm?: SortOrder
    pricePerMinute?: SortOrder
    nightSurcharge?: SortOrder
    weekendSurcharge?: SortOrder
  }

  export type TariffMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    pricePerKm?: SortOrder
    pricePerMinute?: SortOrder
    nightSurcharge?: SortOrder
    weekendSurcharge?: SortOrder
    isActive?: SortOrder
    nightStartTime?: SortOrder
    nightEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    name?: SortOrder
    code?: SortOrder
    type?: SortOrder
    startPrice?: SortOrder
    pricePerKm?: SortOrder
    pricePerMinute?: SortOrder
    nightSurcharge?: SortOrder
    weekendSurcharge?: SortOrder
    isActive?: SortOrder
    nightStartTime?: SortOrder
    nightEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TariffSumOrderByAggregateInput = {
    startPrice?: SortOrder
    pricePerKm?: SortOrder
    pricePerMinute?: SortOrder
    nightSurcharge?: SortOrder
    weekendSurcharge?: SortOrder
  }

  export type EnumTariffTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TariffType | EnumTariffTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TariffType[]
    notIn?: $Enums.TariffType[]
    not?: NestedEnumTariffTypeWithAggregatesFilter<$PrismaModel> | $Enums.TariffType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTariffTypeFilter<$PrismaModel>
    _max?: NestedEnumTariffTypeFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type TariffScalarRelationFilter = {
    is?: TariffWhereInput
    isNot?: TariffWhereInput
  }

  export type TripLogNullableScalarRelationFilter = {
    is?: TripLogWhereInput | null
    isNot?: TripLogWhereInput | null
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    riderId?: SortOrder
    companyId?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    tariffId?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    pickupAddress?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    destinationAddress?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
    riderName?: SortOrder
    riderPhone?: SortOrder
    notes?: SortOrder
    scheduledTime?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    riderId?: SortOrder
    companyId?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    tariffId?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    pickupAddress?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    destinationAddress?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
    riderName?: SortOrder
    riderPhone?: SortOrder
    notes?: SortOrder
    scheduledTime?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    riderId?: SortOrder
    companyId?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    tariffId?: SortOrder
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    pickupAddress?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    destinationAddress?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
    riderName?: SortOrder
    riderPhone?: SortOrder
    notes?: SortOrder
    scheduledTime?: SortOrder
    acceptedAt?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    cancelledAt?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    pickupLatitude?: SortOrder
    pickupLongitude?: SortOrder
    destinationLatitude?: SortOrder
    destinationLongitude?: SortOrder
    estimatedPrice?: SortOrder
    finalPrice?: SortOrder
    estimatedDuration?: SortOrder
    actualDuration?: SortOrder
    distance?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[]
    notIn?: $Enums.LogType[]
    not?: NestedEnumLogTypeFilter<$PrismaModel> | $Enums.LogType
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type GovernmentApiRequestListRelationFilter = {
    every?: GovernmentApiRequestWhereInput
    some?: GovernmentApiRequestWhereInput
    none?: GovernmentApiRequestWhereInput
  }

  export type GovernmentApiRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TripLogCountOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    logType?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    startAddress?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    endAddress?: SortOrder
    distance?: SortOrder
    duration?: SortOrder
    finalPrice?: SortOrder
    tariffUsed?: SortOrder
    governmentTripId?: SortOrder
    tripStartApiSent?: SortOrder
    tripEndApiSent?: SortOrder
    apiErrorLog?: SortOrder
    logDetails?: SortOrder
    tripStartTime?: SortOrder
    tripEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripLogAvgOrderByAggregateInput = {
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    distance?: SortOrder
    duration?: SortOrder
    finalPrice?: SortOrder
  }

  export type TripLogMaxOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    logType?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    startAddress?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    endAddress?: SortOrder
    distance?: SortOrder
    duration?: SortOrder
    finalPrice?: SortOrder
    tariffUsed?: SortOrder
    governmentTripId?: SortOrder
    tripStartApiSent?: SortOrder
    tripEndApiSent?: SortOrder
    apiErrorLog?: SortOrder
    tripStartTime?: SortOrder
    tripEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripLogMinOrderByAggregateInput = {
    id?: SortOrder
    parentId?: SortOrder
    logType?: SortOrder
    companyId?: SortOrder
    vehicleId?: SortOrder
    driverId?: SortOrder
    userId?: SortOrder
    bookingId?: SortOrder
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    startAddress?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    endAddress?: SortOrder
    distance?: SortOrder
    duration?: SortOrder
    finalPrice?: SortOrder
    tariffUsed?: SortOrder
    governmentTripId?: SortOrder
    tripStartApiSent?: SortOrder
    tripEndApiSent?: SortOrder
    apiErrorLog?: SortOrder
    tripStartTime?: SortOrder
    tripEndTime?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TripLogSumOrderByAggregateInput = {
    startLatitude?: SortOrder
    startLongitude?: SortOrder
    endLatitude?: SortOrder
    endLongitude?: SortOrder
    distance?: SortOrder
    duration?: SortOrder
    finalPrice?: SortOrder
  }

  export type EnumLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[]
    notIn?: $Enums.LogType[]
    not?: NestedEnumLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.LogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogTypeFilter<$PrismaModel>
    _max?: NestedEnumLogTypeFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumApiRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiRequestType | EnumApiRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiRequestType[]
    notIn?: $Enums.ApiRequestType[]
    not?: NestedEnumApiRequestTypeFilter<$PrismaModel> | $Enums.ApiRequestType
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TripLogScalarRelationFilter = {
    is?: TripLogWhereInput
    isNot?: TripLogWhereInput
  }

  export type GovernmentApiRequestCountOrderByAggregateInput = {
    id?: SortOrder
    tripLogId?: SortOrder
    requestType?: SortOrder
    endpoint?: SortOrder
    payload?: SortOrder
    response?: SortOrder
    statusCode?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernmentApiRequestAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    retryCount?: SortOrder
  }

  export type GovernmentApiRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    tripLogId?: SortOrder
    requestType?: SortOrder
    endpoint?: SortOrder
    statusCode?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernmentApiRequestMinOrderByAggregateInput = {
    id?: SortOrder
    tripLogId?: SortOrder
    requestType?: SortOrder
    endpoint?: SortOrder
    statusCode?: SortOrder
    success?: SortOrder
    errorMessage?: SortOrder
    retryCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type GovernmentApiRequestSumOrderByAggregateInput = {
    statusCode?: SortOrder
    retryCount?: SortOrder
  }

  export type EnumApiRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiRequestType | EnumApiRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiRequestType[]
    notIn?: $Enums.ApiRequestType[]
    not?: NestedEnumApiRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApiRequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumApiRequestTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type DriverScalarRelationFilter = {
    is?: DriverWhereInput
    isNot?: DriverWhereInput
  }

  export type VehicleScalarRelationFilter = {
    is?: VehicleWhereInput
    isNot?: VehicleWhereInput
  }

  export type LocationUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    speed?: SortOrder
    heading?: SortOrder
    altitude?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationUpdateAvgOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    speed?: SortOrder
    heading?: SortOrder
    altitude?: SortOrder
  }

  export type LocationUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    speed?: SortOrder
    heading?: SortOrder
    altitude?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    driverId?: SortOrder
    vehicleId?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    speed?: SortOrder
    heading?: SortOrder
    altitude?: SortOrder
    createdAt?: SortOrder
  }

  export type LocationUpdateSumOrderByAggregateInput = {
    latitude?: SortOrder
    longitude?: SortOrder
    accuracy?: SortOrder
    speed?: SortOrder
    heading?: SortOrder
    altitude?: SortOrder
  }

  export type EnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    subscriptionType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    pricePerMonth?: SortOrder
    paymentProvider?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionAvgOrderByAggregateInput = {
    pricePerMonth?: SortOrder
  }

  export type SubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    subscriptionType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    pricePerMonth?: SortOrder
    paymentProvider?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    companyId?: SortOrder
    subscriptionType?: SortOrder
    status?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    pricePerMonth?: SortOrder
    paymentProvider?: SortOrder
    externalId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SubscriptionSumOrderByAggregateInput = {
    pricePerMonth?: SortOrder
  }

  export type EnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type SubscriptionScalarRelationFilter = {
    is?: SubscriptionWhereInput
    isNot?: SubscriptionWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    externalId?: SortOrder
    paymentMethod?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    externalId?: SortOrder
    paymentMethod?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    subscriptionId?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    status?: SortOrder
    provider?: SortOrder
    externalId?: SortOrder
    paymentMethod?: SortOrder
    periodStart?: SortOrder
    periodEnd?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CompanyUserCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type DriverCreateNestedOneWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    connect?: DriverWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutRiderInput = {
    create?: XOR<BookingCreateWithoutRiderInput, BookingUncheckedCreateWithoutRiderInput> | BookingCreateWithoutRiderInput[] | BookingUncheckedCreateWithoutRiderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRiderInput | BookingCreateOrConnectWithoutRiderInput[]
    createMany?: BookingCreateManyRiderInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripLogCreateNestedManyWithoutUserInput = {
    create?: XOR<TripLogCreateWithoutUserInput, TripLogUncheckedCreateWithoutUserInput> | TripLogCreateWithoutUserInput[] | TripLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutUserInput | TripLogCreateOrConnectWithoutUserInput[]
    createMany?: TripLogCreateManyUserInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type DriverUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    connect?: DriverWhereUniqueInput
  }

  export type BookingUncheckedCreateNestedManyWithoutRiderInput = {
    create?: XOR<BookingCreateWithoutRiderInput, BookingUncheckedCreateWithoutRiderInput> | BookingCreateWithoutRiderInput[] | BookingUncheckedCreateWithoutRiderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRiderInput | BookingCreateOrConnectWithoutRiderInput[]
    createMany?: BookingCreateManyRiderInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TripLogCreateWithoutUserInput, TripLogUncheckedCreateWithoutUserInput> | TripLogCreateWithoutUserInput[] | TripLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutUserInput | TripLogCreateOrConnectWithoutUserInput[]
    createMany?: TripLogCreateManyUserInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CompanyUserUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type DriverUpdateOneWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    upsert?: DriverUpsertWithoutUserInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutUserInput, DriverUpdateWithoutUserInput>, DriverUncheckedUpdateWithoutUserInput>
  }

  export type BookingUpdateManyWithoutRiderNestedInput = {
    create?: XOR<BookingCreateWithoutRiderInput, BookingUncheckedCreateWithoutRiderInput> | BookingCreateWithoutRiderInput[] | BookingUncheckedCreateWithoutRiderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRiderInput | BookingCreateOrConnectWithoutRiderInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRiderInput | BookingUpsertWithWhereUniqueWithoutRiderInput[]
    createMany?: BookingCreateManyRiderInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRiderInput | BookingUpdateWithWhereUniqueWithoutRiderInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRiderInput | BookingUpdateManyWithWhereWithoutRiderInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<TripLogCreateWithoutUserInput, TripLogUncheckedCreateWithoutUserInput> | TripLogCreateWithoutUserInput[] | TripLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutUserInput | TripLogCreateOrConnectWithoutUserInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutUserInput | TripLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TripLogCreateManyUserInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutUserInput | TripLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutUserInput | TripLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput> | CompanyUserCreateWithoutUserInput[] | CompanyUserUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutUserInput | CompanyUserCreateOrConnectWithoutUserInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutUserInput | CompanyUserUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CompanyUserCreateManyUserInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutUserInput | CompanyUserUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutUserInput | CompanyUserUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type DriverUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    connectOrCreate?: DriverCreateOrConnectWithoutUserInput
    upsert?: DriverUpsertWithoutUserInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutUserInput, DriverUpdateWithoutUserInput>, DriverUncheckedUpdateWithoutUserInput>
  }

  export type BookingUncheckedUpdateManyWithoutRiderNestedInput = {
    create?: XOR<BookingCreateWithoutRiderInput, BookingUncheckedCreateWithoutRiderInput> | BookingCreateWithoutRiderInput[] | BookingUncheckedCreateWithoutRiderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutRiderInput | BookingCreateOrConnectWithoutRiderInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutRiderInput | BookingUpsertWithWhereUniqueWithoutRiderInput[]
    createMany?: BookingCreateManyRiderInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutRiderInput | BookingUpdateWithWhereUniqueWithoutRiderInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutRiderInput | BookingUpdateManyWithWhereWithoutRiderInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TripLogCreateWithoutUserInput, TripLogUncheckedCreateWithoutUserInput> | TripLogCreateWithoutUserInput[] | TripLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutUserInput | TripLogCreateOrConnectWithoutUserInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutUserInput | TripLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TripLogCreateManyUserInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutUserInput | TripLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutUserInput | TripLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type VehicleCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VehicleCreateWithoutCompanyInput, VehicleUncheckedCreateWithoutCompanyInput> | VehicleCreateWithoutCompanyInput[] | VehicleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCompanyInput | VehicleCreateOrConnectWithoutCompanyInput[]
    createMany?: VehicleCreateManyCompanyInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type DriverCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DriverCreateWithoutCompanyInput, DriverUncheckedCreateWithoutCompanyInput> | DriverCreateWithoutCompanyInput[] | DriverUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutCompanyInput | DriverCreateOrConnectWithoutCompanyInput[]
    createMany?: DriverCreateManyCompanyInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type TariffCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TariffCreateWithoutCompanyInput, TariffUncheckedCreateWithoutCompanyInput> | TariffCreateWithoutCompanyInput[] | TariffUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TariffCreateOrConnectWithoutCompanyInput | TariffCreateOrConnectWithoutCompanyInput[]
    createMany?: TariffCreateManyCompanyInputEnvelope
    connect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
  }

  export type CompanyUserCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type SubscriptionCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput> | SubscriptionCreateWithoutCompanyInput[] | SubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCompanyInput | SubscriptionCreateOrConnectWithoutCompanyInput[]
    createMany?: SubscriptionCreateManyCompanyInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BookingCreateWithoutCompanyInput, BookingUncheckedCreateWithoutCompanyInput> | BookingCreateWithoutCompanyInput[] | BookingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCompanyInput | BookingCreateOrConnectWithoutCompanyInput[]
    createMany?: BookingCreateManyCompanyInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripLogCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TripLogCreateWithoutCompanyInput, TripLogUncheckedCreateWithoutCompanyInput> | TripLogCreateWithoutCompanyInput[] | TripLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutCompanyInput | TripLogCreateOrConnectWithoutCompanyInput[]
    createMany?: TripLogCreateManyCompanyInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type VehicleUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<VehicleCreateWithoutCompanyInput, VehicleUncheckedCreateWithoutCompanyInput> | VehicleCreateWithoutCompanyInput[] | VehicleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCompanyInput | VehicleCreateOrConnectWithoutCompanyInput[]
    createMany?: VehicleCreateManyCompanyInputEnvelope
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
  }

  export type DriverUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<DriverCreateWithoutCompanyInput, DriverUncheckedCreateWithoutCompanyInput> | DriverCreateWithoutCompanyInput[] | DriverUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutCompanyInput | DriverCreateOrConnectWithoutCompanyInput[]
    createMany?: DriverCreateManyCompanyInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type TariffUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TariffCreateWithoutCompanyInput, TariffUncheckedCreateWithoutCompanyInput> | TariffCreateWithoutCompanyInput[] | TariffUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TariffCreateOrConnectWithoutCompanyInput | TariffCreateOrConnectWithoutCompanyInput[]
    createMany?: TariffCreateManyCompanyInputEnvelope
    connect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
  }

  export type CompanyUserUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
  }

  export type SubscriptionUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput> | SubscriptionCreateWithoutCompanyInput[] | SubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCompanyInput | SubscriptionCreateOrConnectWithoutCompanyInput[]
    createMany?: SubscriptionCreateManyCompanyInputEnvelope
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<BookingCreateWithoutCompanyInput, BookingUncheckedCreateWithoutCompanyInput> | BookingCreateWithoutCompanyInput[] | BookingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCompanyInput | BookingCreateOrConnectWithoutCompanyInput[]
    createMany?: BookingCreateManyCompanyInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripLogUncheckedCreateNestedManyWithoutCompanyInput = {
    create?: XOR<TripLogCreateWithoutCompanyInput, TripLogUncheckedCreateWithoutCompanyInput> | TripLogCreateWithoutCompanyInput[] | TripLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutCompanyInput | TripLogCreateOrConnectWithoutCompanyInput[]
    createMany?: TripLogCreateManyCompanyInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type EnumSubscriptionTypeFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionType
  }

  export type EnumCompanyStatusFieldUpdateOperationsInput = {
    set?: $Enums.CompanyStatus
  }

  export type VehicleUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VehicleCreateWithoutCompanyInput, VehicleUncheckedCreateWithoutCompanyInput> | VehicleCreateWithoutCompanyInput[] | VehicleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCompanyInput | VehicleCreateOrConnectWithoutCompanyInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutCompanyInput | VehicleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VehicleCreateManyCompanyInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutCompanyInput | VehicleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutCompanyInput | VehicleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type DriverUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DriverCreateWithoutCompanyInput, DriverUncheckedCreateWithoutCompanyInput> | DriverCreateWithoutCompanyInput[] | DriverUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutCompanyInput | DriverCreateOrConnectWithoutCompanyInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutCompanyInput | DriverUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DriverCreateManyCompanyInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutCompanyInput | DriverUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutCompanyInput | DriverUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type TariffUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TariffCreateWithoutCompanyInput, TariffUncheckedCreateWithoutCompanyInput> | TariffCreateWithoutCompanyInput[] | TariffUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TariffCreateOrConnectWithoutCompanyInput | TariffCreateOrConnectWithoutCompanyInput[]
    upsert?: TariffUpsertWithWhereUniqueWithoutCompanyInput | TariffUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TariffCreateManyCompanyInputEnvelope
    set?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    disconnect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    delete?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    connect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    update?: TariffUpdateWithWhereUniqueWithoutCompanyInput | TariffUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TariffUpdateManyWithWhereWithoutCompanyInput | TariffUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TariffScalarWhereInput | TariffScalarWhereInput[]
  }

  export type CompanyUserUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type SubscriptionUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput> | SubscriptionCreateWithoutCompanyInput[] | SubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCompanyInput | SubscriptionCreateOrConnectWithoutCompanyInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCompanyInput | SubscriptionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SubscriptionCreateManyCompanyInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCompanyInput | SubscriptionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCompanyInput | SubscriptionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BookingCreateWithoutCompanyInput, BookingUncheckedCreateWithoutCompanyInput> | BookingCreateWithoutCompanyInput[] | BookingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCompanyInput | BookingCreateOrConnectWithoutCompanyInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCompanyInput | BookingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BookingCreateManyCompanyInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCompanyInput | BookingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCompanyInput | BookingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripLogUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TripLogCreateWithoutCompanyInput, TripLogUncheckedCreateWithoutCompanyInput> | TripLogCreateWithoutCompanyInput[] | TripLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutCompanyInput | TripLogCreateOrConnectWithoutCompanyInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutCompanyInput | TripLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TripLogCreateManyCompanyInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutCompanyInput | TripLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutCompanyInput | TripLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type VehicleUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<VehicleCreateWithoutCompanyInput, VehicleUncheckedCreateWithoutCompanyInput> | VehicleCreateWithoutCompanyInput[] | VehicleUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: VehicleCreateOrConnectWithoutCompanyInput | VehicleCreateOrConnectWithoutCompanyInput[]
    upsert?: VehicleUpsertWithWhereUniqueWithoutCompanyInput | VehicleUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: VehicleCreateManyCompanyInputEnvelope
    set?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    disconnect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    delete?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    connect?: VehicleWhereUniqueInput | VehicleWhereUniqueInput[]
    update?: VehicleUpdateWithWhereUniqueWithoutCompanyInput | VehicleUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: VehicleUpdateManyWithWhereWithoutCompanyInput | VehicleUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
  }

  export type DriverUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<DriverCreateWithoutCompanyInput, DriverUncheckedCreateWithoutCompanyInput> | DriverCreateWithoutCompanyInput[] | DriverUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutCompanyInput | DriverCreateOrConnectWithoutCompanyInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutCompanyInput | DriverUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: DriverCreateManyCompanyInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutCompanyInput | DriverUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutCompanyInput | DriverUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type TariffUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TariffCreateWithoutCompanyInput, TariffUncheckedCreateWithoutCompanyInput> | TariffCreateWithoutCompanyInput[] | TariffUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TariffCreateOrConnectWithoutCompanyInput | TariffCreateOrConnectWithoutCompanyInput[]
    upsert?: TariffUpsertWithWhereUniqueWithoutCompanyInput | TariffUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TariffCreateManyCompanyInputEnvelope
    set?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    disconnect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    delete?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    connect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    update?: TariffUpdateWithWhereUniqueWithoutCompanyInput | TariffUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TariffUpdateManyWithWhereWithoutCompanyInput | TariffUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TariffScalarWhereInput | TariffScalarWhereInput[]
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput> | CompanyUserCreateWithoutCompanyInput[] | CompanyUserUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: CompanyUserCreateOrConnectWithoutCompanyInput | CompanyUserCreateOrConnectWithoutCompanyInput[]
    upsert?: CompanyUserUpsertWithWhereUniqueWithoutCompanyInput | CompanyUserUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: CompanyUserCreateManyCompanyInputEnvelope
    set?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    disconnect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    delete?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    connect?: CompanyUserWhereUniqueInput | CompanyUserWhereUniqueInput[]
    update?: CompanyUserUpdateWithWhereUniqueWithoutCompanyInput | CompanyUserUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: CompanyUserUpdateManyWithWhereWithoutCompanyInput | CompanyUserUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
  }

  export type SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput> | SubscriptionCreateWithoutCompanyInput[] | SubscriptionUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: SubscriptionCreateOrConnectWithoutCompanyInput | SubscriptionCreateOrConnectWithoutCompanyInput[]
    upsert?: SubscriptionUpsertWithWhereUniqueWithoutCompanyInput | SubscriptionUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: SubscriptionCreateManyCompanyInputEnvelope
    set?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    disconnect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    delete?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    connect?: SubscriptionWhereUniqueInput | SubscriptionWhereUniqueInput[]
    update?: SubscriptionUpdateWithWhereUniqueWithoutCompanyInput | SubscriptionUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: SubscriptionUpdateManyWithWhereWithoutCompanyInput | SubscriptionUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<BookingCreateWithoutCompanyInput, BookingUncheckedCreateWithoutCompanyInput> | BookingCreateWithoutCompanyInput[] | BookingUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutCompanyInput | BookingCreateOrConnectWithoutCompanyInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutCompanyInput | BookingUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: BookingCreateManyCompanyInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutCompanyInput | BookingUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutCompanyInput | BookingUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripLogUncheckedUpdateManyWithoutCompanyNestedInput = {
    create?: XOR<TripLogCreateWithoutCompanyInput, TripLogUncheckedCreateWithoutCompanyInput> | TripLogCreateWithoutCompanyInput[] | TripLogUncheckedCreateWithoutCompanyInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutCompanyInput | TripLogCreateOrConnectWithoutCompanyInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutCompanyInput | TripLogUpsertWithWhereUniqueWithoutCompanyInput[]
    createMany?: TripLogCreateManyCompanyInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutCompanyInput | TripLogUpdateWithWhereUniqueWithoutCompanyInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutCompanyInput | TripLogUpdateManyWithWhereWithoutCompanyInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutCompanyUserInput = {
    create?: XOR<UserCreateWithoutCompanyUserInput, UserUncheckedCreateWithoutCompanyUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyUserInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutUsersInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    connect?: CompanyWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCompanyUserNestedInput = {
    create?: XOR<UserCreateWithoutCompanyUserInput, UserUncheckedCreateWithoutCompanyUserInput>
    connectOrCreate?: UserCreateOrConnectWithoutCompanyUserInput
    upsert?: UserUpsertWithoutCompanyUserInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCompanyUserInput, UserUpdateWithoutCompanyUserInput>, UserUncheckedUpdateWithoutCompanyUserInput>
  }

  export type CompanyUpdateOneRequiredWithoutUsersNestedInput = {
    create?: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutUsersInput
    upsert?: CompanyUpsertWithoutUsersInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutUsersInput, CompanyUpdateWithoutUsersInput>, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyCreateNestedOneWithoutVehiclesInput = {
    create?: XOR<CompanyCreateWithoutVehiclesInput, CompanyUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVehiclesInput
    connect?: CompanyWhereUniqueInput
  }

  export type DriverCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput> | DriverCreateWithoutVehicleInput[] | DriverUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVehicleInput | DriverCreateOrConnectWithoutVehicleInput[]
    createMany?: DriverCreateManyVehicleInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type TariffCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TariffCreateWithoutVehicleInput, TariffUncheckedCreateWithoutVehicleInput> | TariffCreateWithoutVehicleInput[] | TariffUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TariffCreateOrConnectWithoutVehicleInput | TariffCreateOrConnectWithoutVehicleInput[]
    createMany?: TariffCreateManyVehicleInputEnvelope
    connect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripLogCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TripLogCreateWithoutVehicleInput, TripLogUncheckedCreateWithoutVehicleInput> | TripLogCreateWithoutVehicleInput[] | TripLogUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutVehicleInput | TripLogCreateOrConnectWithoutVehicleInput[]
    createMany?: TripLogCreateManyVehicleInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type LocationUpdateCreateNestedManyWithoutVehicleInput = {
    create?: XOR<LocationUpdateCreateWithoutVehicleInput, LocationUpdateUncheckedCreateWithoutVehicleInput> | LocationUpdateCreateWithoutVehicleInput[] | LocationUpdateUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: LocationUpdateCreateOrConnectWithoutVehicleInput | LocationUpdateCreateOrConnectWithoutVehicleInput[]
    createMany?: LocationUpdateCreateManyVehicleInputEnvelope
    connect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
  }

  export type DriverUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput> | DriverCreateWithoutVehicleInput[] | DriverUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVehicleInput | DriverCreateOrConnectWithoutVehicleInput[]
    createMany?: DriverCreateManyVehicleInputEnvelope
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
  }

  export type TariffUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TariffCreateWithoutVehicleInput, TariffUncheckedCreateWithoutVehicleInput> | TariffCreateWithoutVehicleInput[] | TariffUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TariffCreateOrConnectWithoutVehicleInput | TariffCreateOrConnectWithoutVehicleInput[]
    createMany?: TariffCreateManyVehicleInputEnvelope
    connect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripLogUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<TripLogCreateWithoutVehicleInput, TripLogUncheckedCreateWithoutVehicleInput> | TripLogCreateWithoutVehicleInput[] | TripLogUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutVehicleInput | TripLogCreateOrConnectWithoutVehicleInput[]
    createMany?: TripLogCreateManyVehicleInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type LocationUpdateUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<LocationUpdateCreateWithoutVehicleInput, LocationUpdateUncheckedCreateWithoutVehicleInput> | LocationUpdateCreateWithoutVehicleInput[] | LocationUpdateUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: LocationUpdateCreateOrConnectWithoutVehicleInput | LocationUpdateCreateOrConnectWithoutVehicleInput[]
    createMany?: LocationUpdateCreateManyVehicleInputEnvelope
    connect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumVehicleStatusFieldUpdateOperationsInput = {
    set?: $Enums.VehicleStatus
  }

  export type CompanyUpdateOneRequiredWithoutVehiclesNestedInput = {
    create?: XOR<CompanyCreateWithoutVehiclesInput, CompanyUncheckedCreateWithoutVehiclesInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutVehiclesInput
    upsert?: CompanyUpsertWithoutVehiclesInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutVehiclesInput, CompanyUpdateWithoutVehiclesInput>, CompanyUncheckedUpdateWithoutVehiclesInput>
  }

  export type DriverUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput> | DriverCreateWithoutVehicleInput[] | DriverUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVehicleInput | DriverCreateOrConnectWithoutVehicleInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutVehicleInput | DriverUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DriverCreateManyVehicleInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutVehicleInput | DriverUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutVehicleInput | DriverUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type TariffUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TariffCreateWithoutVehicleInput, TariffUncheckedCreateWithoutVehicleInput> | TariffCreateWithoutVehicleInput[] | TariffUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TariffCreateOrConnectWithoutVehicleInput | TariffCreateOrConnectWithoutVehicleInput[]
    upsert?: TariffUpsertWithWhereUniqueWithoutVehicleInput | TariffUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TariffCreateManyVehicleInputEnvelope
    set?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    disconnect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    delete?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    connect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    update?: TariffUpdateWithWhereUniqueWithoutVehicleInput | TariffUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TariffUpdateManyWithWhereWithoutVehicleInput | TariffUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TariffScalarWhereInput | TariffScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVehicleInput | BookingUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVehicleInput | BookingUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVehicleInput | BookingUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripLogUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TripLogCreateWithoutVehicleInput, TripLogUncheckedCreateWithoutVehicleInput> | TripLogCreateWithoutVehicleInput[] | TripLogUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutVehicleInput | TripLogCreateOrConnectWithoutVehicleInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutVehicleInput | TripLogUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TripLogCreateManyVehicleInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutVehicleInput | TripLogUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutVehicleInput | TripLogUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type LocationUpdateUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<LocationUpdateCreateWithoutVehicleInput, LocationUpdateUncheckedCreateWithoutVehicleInput> | LocationUpdateCreateWithoutVehicleInput[] | LocationUpdateUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: LocationUpdateCreateOrConnectWithoutVehicleInput | LocationUpdateCreateOrConnectWithoutVehicleInput[]
    upsert?: LocationUpdateUpsertWithWhereUniqueWithoutVehicleInput | LocationUpdateUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: LocationUpdateCreateManyVehicleInputEnvelope
    set?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    disconnect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    delete?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    connect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    update?: LocationUpdateUpdateWithWhereUniqueWithoutVehicleInput | LocationUpdateUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: LocationUpdateUpdateManyWithWhereWithoutVehicleInput | LocationUpdateUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: LocationUpdateScalarWhereInput | LocationUpdateScalarWhereInput[]
  }

  export type DriverUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput> | DriverCreateWithoutVehicleInput[] | DriverUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: DriverCreateOrConnectWithoutVehicleInput | DriverCreateOrConnectWithoutVehicleInput[]
    upsert?: DriverUpsertWithWhereUniqueWithoutVehicleInput | DriverUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: DriverCreateManyVehicleInputEnvelope
    set?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    disconnect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    delete?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    connect?: DriverWhereUniqueInput | DriverWhereUniqueInput[]
    update?: DriverUpdateWithWhereUniqueWithoutVehicleInput | DriverUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: DriverUpdateManyWithWhereWithoutVehicleInput | DriverUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: DriverScalarWhereInput | DriverScalarWhereInput[]
  }

  export type TariffUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TariffCreateWithoutVehicleInput, TariffUncheckedCreateWithoutVehicleInput> | TariffCreateWithoutVehicleInput[] | TariffUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TariffCreateOrConnectWithoutVehicleInput | TariffCreateOrConnectWithoutVehicleInput[]
    upsert?: TariffUpsertWithWhereUniqueWithoutVehicleInput | TariffUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TariffCreateManyVehicleInputEnvelope
    set?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    disconnect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    delete?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    connect?: TariffWhereUniqueInput | TariffWhereUniqueInput[]
    update?: TariffUpdateWithWhereUniqueWithoutVehicleInput | TariffUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TariffUpdateManyWithWhereWithoutVehicleInput | TariffUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TariffScalarWhereInput | TariffScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput> | BookingCreateWithoutVehicleInput[] | BookingUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVehicleInput | BookingCreateOrConnectWithoutVehicleInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVehicleInput | BookingUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: BookingCreateManyVehicleInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVehicleInput | BookingUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVehicleInput | BookingUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripLogUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<TripLogCreateWithoutVehicleInput, TripLogUncheckedCreateWithoutVehicleInput> | TripLogCreateWithoutVehicleInput[] | TripLogUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutVehicleInput | TripLogCreateOrConnectWithoutVehicleInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutVehicleInput | TripLogUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: TripLogCreateManyVehicleInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutVehicleInput | TripLogUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutVehicleInput | TripLogUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type LocationUpdateUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<LocationUpdateCreateWithoutVehicleInput, LocationUpdateUncheckedCreateWithoutVehicleInput> | LocationUpdateCreateWithoutVehicleInput[] | LocationUpdateUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: LocationUpdateCreateOrConnectWithoutVehicleInput | LocationUpdateCreateOrConnectWithoutVehicleInput[]
    upsert?: LocationUpdateUpsertWithWhereUniqueWithoutVehicleInput | LocationUpdateUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: LocationUpdateCreateManyVehicleInputEnvelope
    set?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    disconnect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    delete?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    connect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    update?: LocationUpdateUpdateWithWhereUniqueWithoutVehicleInput | LocationUpdateUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: LocationUpdateUpdateManyWithWhereWithoutVehicleInput | LocationUpdateUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: LocationUpdateScalarWhereInput | LocationUpdateScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDriverProfileInput = {
    create?: XOR<UserCreateWithoutDriverProfileInput, UserUncheckedCreateWithoutDriverProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverProfileInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutDriversInput = {
    create?: XOR<CompanyCreateWithoutDriversInput, CompanyUncheckedCreateWithoutDriversInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDriversInput
    connect?: CompanyWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutDriversInput = {
    create?: XOR<VehicleCreateWithoutDriversInput, VehicleUncheckedCreateWithoutDriversInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDriversInput
    connect?: VehicleWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutDriverInput = {
    create?: XOR<BookingCreateWithoutDriverInput, BookingUncheckedCreateWithoutDriverInput> | BookingCreateWithoutDriverInput[] | BookingUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDriverInput | BookingCreateOrConnectWithoutDriverInput[]
    createMany?: BookingCreateManyDriverInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripLogCreateNestedManyWithoutDriverInput = {
    create?: XOR<TripLogCreateWithoutDriverInput, TripLogUncheckedCreateWithoutDriverInput> | TripLogCreateWithoutDriverInput[] | TripLogUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutDriverInput | TripLogCreateOrConnectWithoutDriverInput[]
    createMany?: TripLogCreateManyDriverInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type LocationUpdateCreateNestedManyWithoutDriverInput = {
    create?: XOR<LocationUpdateCreateWithoutDriverInput, LocationUpdateUncheckedCreateWithoutDriverInput> | LocationUpdateCreateWithoutDriverInput[] | LocationUpdateUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: LocationUpdateCreateOrConnectWithoutDriverInput | LocationUpdateCreateOrConnectWithoutDriverInput[]
    createMany?: LocationUpdateCreateManyDriverInputEnvelope
    connect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<BookingCreateWithoutDriverInput, BookingUncheckedCreateWithoutDriverInput> | BookingCreateWithoutDriverInput[] | BookingUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDriverInput | BookingCreateOrConnectWithoutDriverInput[]
    createMany?: BookingCreateManyDriverInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type TripLogUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<TripLogCreateWithoutDriverInput, TripLogUncheckedCreateWithoutDriverInput> | TripLogCreateWithoutDriverInput[] | TripLogUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutDriverInput | TripLogCreateOrConnectWithoutDriverInput[]
    createMany?: TripLogCreateManyDriverInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type LocationUpdateUncheckedCreateNestedManyWithoutDriverInput = {
    create?: XOR<LocationUpdateCreateWithoutDriverInput, LocationUpdateUncheckedCreateWithoutDriverInput> | LocationUpdateCreateWithoutDriverInput[] | LocationUpdateUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: LocationUpdateCreateOrConnectWithoutDriverInput | LocationUpdateCreateOrConnectWithoutDriverInput[]
    createMany?: LocationUpdateCreateManyDriverInputEnvelope
    connect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
  }

  export type EnumDriverStatusFieldUpdateOperationsInput = {
    set?: $Enums.DriverStatus
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutDriverProfileNestedInput = {
    create?: XOR<UserCreateWithoutDriverProfileInput, UserUncheckedCreateWithoutDriverProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutDriverProfileInput
    upsert?: UserUpsertWithoutDriverProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDriverProfileInput, UserUpdateWithoutDriverProfileInput>, UserUncheckedUpdateWithoutDriverProfileInput>
  }

  export type CompanyUpdateOneRequiredWithoutDriversNestedInput = {
    create?: XOR<CompanyCreateWithoutDriversInput, CompanyUncheckedCreateWithoutDriversInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutDriversInput
    upsert?: CompanyUpsertWithoutDriversInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutDriversInput, CompanyUpdateWithoutDriversInput>, CompanyUncheckedUpdateWithoutDriversInput>
  }

  export type VehicleUpdateOneWithoutDriversNestedInput = {
    create?: XOR<VehicleCreateWithoutDriversInput, VehicleUncheckedCreateWithoutDriversInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutDriversInput
    upsert?: VehicleUpsertWithoutDriversInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutDriversInput, VehicleUpdateWithoutDriversInput>, VehicleUncheckedUpdateWithoutDriversInput>
  }

  export type BookingUpdateManyWithoutDriverNestedInput = {
    create?: XOR<BookingCreateWithoutDriverInput, BookingUncheckedCreateWithoutDriverInput> | BookingCreateWithoutDriverInput[] | BookingUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDriverInput | BookingCreateOrConnectWithoutDriverInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDriverInput | BookingUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: BookingCreateManyDriverInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDriverInput | BookingUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDriverInput | BookingUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripLogUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TripLogCreateWithoutDriverInput, TripLogUncheckedCreateWithoutDriverInput> | TripLogCreateWithoutDriverInput[] | TripLogUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutDriverInput | TripLogCreateOrConnectWithoutDriverInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutDriverInput | TripLogUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TripLogCreateManyDriverInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutDriverInput | TripLogUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutDriverInput | TripLogUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type LocationUpdateUpdateManyWithoutDriverNestedInput = {
    create?: XOR<LocationUpdateCreateWithoutDriverInput, LocationUpdateUncheckedCreateWithoutDriverInput> | LocationUpdateCreateWithoutDriverInput[] | LocationUpdateUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: LocationUpdateCreateOrConnectWithoutDriverInput | LocationUpdateCreateOrConnectWithoutDriverInput[]
    upsert?: LocationUpdateUpsertWithWhereUniqueWithoutDriverInput | LocationUpdateUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: LocationUpdateCreateManyDriverInputEnvelope
    set?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    disconnect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    delete?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    connect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    update?: LocationUpdateUpdateWithWhereUniqueWithoutDriverInput | LocationUpdateUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: LocationUpdateUpdateManyWithWhereWithoutDriverInput | LocationUpdateUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: LocationUpdateScalarWhereInput | LocationUpdateScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<BookingCreateWithoutDriverInput, BookingUncheckedCreateWithoutDriverInput> | BookingCreateWithoutDriverInput[] | BookingUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutDriverInput | BookingCreateOrConnectWithoutDriverInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutDriverInput | BookingUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: BookingCreateManyDriverInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutDriverInput | BookingUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutDriverInput | BookingUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type TripLogUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<TripLogCreateWithoutDriverInput, TripLogUncheckedCreateWithoutDriverInput> | TripLogCreateWithoutDriverInput[] | TripLogUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutDriverInput | TripLogCreateOrConnectWithoutDriverInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutDriverInput | TripLogUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: TripLogCreateManyDriverInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutDriverInput | TripLogUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutDriverInput | TripLogUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type LocationUpdateUncheckedUpdateManyWithoutDriverNestedInput = {
    create?: XOR<LocationUpdateCreateWithoutDriverInput, LocationUpdateUncheckedCreateWithoutDriverInput> | LocationUpdateCreateWithoutDriverInput[] | LocationUpdateUncheckedCreateWithoutDriverInput[]
    connectOrCreate?: LocationUpdateCreateOrConnectWithoutDriverInput | LocationUpdateCreateOrConnectWithoutDriverInput[]
    upsert?: LocationUpdateUpsertWithWhereUniqueWithoutDriverInput | LocationUpdateUpsertWithWhereUniqueWithoutDriverInput[]
    createMany?: LocationUpdateCreateManyDriverInputEnvelope
    set?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    disconnect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    delete?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    connect?: LocationUpdateWhereUniqueInput | LocationUpdateWhereUniqueInput[]
    update?: LocationUpdateUpdateWithWhereUniqueWithoutDriverInput | LocationUpdateUpdateWithWhereUniqueWithoutDriverInput[]
    updateMany?: LocationUpdateUpdateManyWithWhereWithoutDriverInput | LocationUpdateUpdateManyWithWhereWithoutDriverInput[]
    deleteMany?: LocationUpdateScalarWhereInput | LocationUpdateScalarWhereInput[]
  }

  export type CompanyCreateNestedOneWithoutTariffsInput = {
    create?: XOR<CompanyCreateWithoutTariffsInput, CompanyUncheckedCreateWithoutTariffsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTariffsInput
    connect?: CompanyWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutTariffsInput = {
    create?: XOR<VehicleCreateWithoutTariffsInput, VehicleUncheckedCreateWithoutTariffsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTariffsInput
    connect?: VehicleWhereUniqueInput
  }

  export type BookingCreateNestedManyWithoutTariffInput = {
    create?: XOR<BookingCreateWithoutTariffInput, BookingUncheckedCreateWithoutTariffInput> | BookingCreateWithoutTariffInput[] | BookingUncheckedCreateWithoutTariffInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTariffInput | BookingCreateOrConnectWithoutTariffInput[]
    createMany?: BookingCreateManyTariffInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutTariffInput = {
    create?: XOR<BookingCreateWithoutTariffInput, BookingUncheckedCreateWithoutTariffInput> | BookingCreateWithoutTariffInput[] | BookingUncheckedCreateWithoutTariffInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTariffInput | BookingCreateOrConnectWithoutTariffInput[]
    createMany?: BookingCreateManyTariffInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type EnumTariffTypeFieldUpdateOperationsInput = {
    set?: $Enums.TariffType
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type CompanyUpdateOneRequiredWithoutTariffsNestedInput = {
    create?: XOR<CompanyCreateWithoutTariffsInput, CompanyUncheckedCreateWithoutTariffsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTariffsInput
    upsert?: CompanyUpsertWithoutTariffsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTariffsInput, CompanyUpdateWithoutTariffsInput>, CompanyUncheckedUpdateWithoutTariffsInput>
  }

  export type VehicleUpdateOneWithoutTariffsNestedInput = {
    create?: XOR<VehicleCreateWithoutTariffsInput, VehicleUncheckedCreateWithoutTariffsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTariffsInput
    upsert?: VehicleUpsertWithoutTariffsInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutTariffsInput, VehicleUpdateWithoutTariffsInput>, VehicleUncheckedUpdateWithoutTariffsInput>
  }

  export type BookingUpdateManyWithoutTariffNestedInput = {
    create?: XOR<BookingCreateWithoutTariffInput, BookingUncheckedCreateWithoutTariffInput> | BookingCreateWithoutTariffInput[] | BookingUncheckedCreateWithoutTariffInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTariffInput | BookingCreateOrConnectWithoutTariffInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTariffInput | BookingUpsertWithWhereUniqueWithoutTariffInput[]
    createMany?: BookingCreateManyTariffInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTariffInput | BookingUpdateWithWhereUniqueWithoutTariffInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTariffInput | BookingUpdateManyWithWhereWithoutTariffInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutTariffNestedInput = {
    create?: XOR<BookingCreateWithoutTariffInput, BookingUncheckedCreateWithoutTariffInput> | BookingCreateWithoutTariffInput[] | BookingUncheckedCreateWithoutTariffInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutTariffInput | BookingCreateOrConnectWithoutTariffInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutTariffInput | BookingUpsertWithWhereUniqueWithoutTariffInput[]
    createMany?: BookingCreateManyTariffInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutTariffInput | BookingUpdateWithWhereUniqueWithoutTariffInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutTariffInput | BookingUpdateManyWithWhereWithoutTariffInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutRiderBookingsInput = {
    create?: XOR<UserCreateWithoutRiderBookingsInput, UserUncheckedCreateWithoutRiderBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRiderBookingsInput
    connect?: UserWhereUniqueInput
  }

  export type CompanyCreateNestedOneWithoutBookingsInput = {
    create?: XOR<CompanyCreateWithoutBookingsInput, CompanyUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBookingsInput
    connect?: CompanyWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutBookingsInput = {
    create?: XOR<DriverCreateWithoutBookingsInput, DriverUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutBookingsInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutBookingsInput = {
    create?: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBookingsInput
    connect?: VehicleWhereUniqueInput
  }

  export type TariffCreateNestedOneWithoutBookingsInput = {
    create?: XOR<TariffCreateWithoutBookingsInput, TariffUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TariffCreateOrConnectWithoutBookingsInput
    connect?: TariffWhereUniqueInput
  }

  export type TripLogCreateNestedOneWithoutBookingInput = {
    create?: XOR<TripLogCreateWithoutBookingInput, TripLogUncheckedCreateWithoutBookingInput>
    connectOrCreate?: TripLogCreateOrConnectWithoutBookingInput
    connect?: TripLogWhereUniqueInput
  }

  export type TripLogUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<TripLogCreateWithoutBookingInput, TripLogUncheckedCreateWithoutBookingInput>
    connectOrCreate?: TripLogCreateOrConnectWithoutBookingInput
    connect?: TripLogWhereUniqueInput
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type UserUpdateOneRequiredWithoutRiderBookingsNestedInput = {
    create?: XOR<UserCreateWithoutRiderBookingsInput, UserUncheckedCreateWithoutRiderBookingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutRiderBookingsInput
    upsert?: UserUpsertWithoutRiderBookingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutRiderBookingsInput, UserUpdateWithoutRiderBookingsInput>, UserUncheckedUpdateWithoutRiderBookingsInput>
  }

  export type CompanyUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<CompanyCreateWithoutBookingsInput, CompanyUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutBookingsInput
    upsert?: CompanyUpsertWithoutBookingsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutBookingsInput, CompanyUpdateWithoutBookingsInput>, CompanyUncheckedUpdateWithoutBookingsInput>
  }

  export type DriverUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<DriverCreateWithoutBookingsInput, DriverUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutBookingsInput
    upsert?: DriverUpsertWithoutBookingsInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutBookingsInput, DriverUpdateWithoutBookingsInput>, DriverUncheckedUpdateWithoutBookingsInput>
  }

  export type VehicleUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutBookingsInput
    upsert?: VehicleUpsertWithoutBookingsInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutBookingsInput, VehicleUpdateWithoutBookingsInput>, VehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type TariffUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<TariffCreateWithoutBookingsInput, TariffUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: TariffCreateOrConnectWithoutBookingsInput
    upsert?: TariffUpsertWithoutBookingsInput
    connect?: TariffWhereUniqueInput
    update?: XOR<XOR<TariffUpdateToOneWithWhereWithoutBookingsInput, TariffUpdateWithoutBookingsInput>, TariffUncheckedUpdateWithoutBookingsInput>
  }

  export type TripLogUpdateOneWithoutBookingNestedInput = {
    create?: XOR<TripLogCreateWithoutBookingInput, TripLogUncheckedCreateWithoutBookingInput>
    connectOrCreate?: TripLogCreateOrConnectWithoutBookingInput
    upsert?: TripLogUpsertWithoutBookingInput
    disconnect?: TripLogWhereInput | boolean
    delete?: TripLogWhereInput | boolean
    connect?: TripLogWhereUniqueInput
    update?: XOR<XOR<TripLogUpdateToOneWithWhereWithoutBookingInput, TripLogUpdateWithoutBookingInput>, TripLogUncheckedUpdateWithoutBookingInput>
  }

  export type TripLogUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<TripLogCreateWithoutBookingInput, TripLogUncheckedCreateWithoutBookingInput>
    connectOrCreate?: TripLogCreateOrConnectWithoutBookingInput
    upsert?: TripLogUpsertWithoutBookingInput
    disconnect?: TripLogWhereInput | boolean
    delete?: TripLogWhereInput | boolean
    connect?: TripLogWhereUniqueInput
    update?: XOR<XOR<TripLogUpdateToOneWithWhereWithoutBookingInput, TripLogUpdateWithoutBookingInput>, TripLogUncheckedUpdateWithoutBookingInput>
  }

  export type CompanyCreateNestedOneWithoutTripLogsInput = {
    create?: XOR<CompanyCreateWithoutTripLogsInput, CompanyUncheckedCreateWithoutTripLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTripLogsInput
    connect?: CompanyWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutTripLogsInput = {
    create?: XOR<VehicleCreateWithoutTripLogsInput, VehicleUncheckedCreateWithoutTripLogsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTripLogsInput
    connect?: VehicleWhereUniqueInput
  }

  export type DriverCreateNestedOneWithoutTripLogsInput = {
    create?: XOR<DriverCreateWithoutTripLogsInput, DriverUncheckedCreateWithoutTripLogsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTripLogsInput
    connect?: DriverWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTripLogsInput = {
    create?: XOR<UserCreateWithoutTripLogsInput, UserUncheckedCreateWithoutTripLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTripLogsInput
    connect?: UserWhereUniqueInput
  }

  export type BookingCreateNestedOneWithoutTripLogInput = {
    create?: XOR<BookingCreateWithoutTripLogInput, BookingUncheckedCreateWithoutTripLogInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTripLogInput
    connect?: BookingWhereUniqueInput
  }

  export type TripLogCreateNestedOneWithoutChildrenInput = {
    create?: XOR<TripLogCreateWithoutChildrenInput, TripLogUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: TripLogCreateOrConnectWithoutChildrenInput
    connect?: TripLogWhereUniqueInput
  }

  export type TripLogCreateNestedManyWithoutParentInput = {
    create?: XOR<TripLogCreateWithoutParentInput, TripLogUncheckedCreateWithoutParentInput> | TripLogCreateWithoutParentInput[] | TripLogUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutParentInput | TripLogCreateOrConnectWithoutParentInput[]
    createMany?: TripLogCreateManyParentInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type GovernmentApiRequestCreateNestedManyWithoutTripLogInput = {
    create?: XOR<GovernmentApiRequestCreateWithoutTripLogInput, GovernmentApiRequestUncheckedCreateWithoutTripLogInput> | GovernmentApiRequestCreateWithoutTripLogInput[] | GovernmentApiRequestUncheckedCreateWithoutTripLogInput[]
    connectOrCreate?: GovernmentApiRequestCreateOrConnectWithoutTripLogInput | GovernmentApiRequestCreateOrConnectWithoutTripLogInput[]
    createMany?: GovernmentApiRequestCreateManyTripLogInputEnvelope
    connect?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
  }

  export type TripLogUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<TripLogCreateWithoutParentInput, TripLogUncheckedCreateWithoutParentInput> | TripLogCreateWithoutParentInput[] | TripLogUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutParentInput | TripLogCreateOrConnectWithoutParentInput[]
    createMany?: TripLogCreateManyParentInputEnvelope
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
  }

  export type GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput = {
    create?: XOR<GovernmentApiRequestCreateWithoutTripLogInput, GovernmentApiRequestUncheckedCreateWithoutTripLogInput> | GovernmentApiRequestCreateWithoutTripLogInput[] | GovernmentApiRequestUncheckedCreateWithoutTripLogInput[]
    connectOrCreate?: GovernmentApiRequestCreateOrConnectWithoutTripLogInput | GovernmentApiRequestCreateOrConnectWithoutTripLogInput[]
    createMany?: GovernmentApiRequestCreateManyTripLogInputEnvelope
    connect?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
  }

  export type EnumLogTypeFieldUpdateOperationsInput = {
    set?: $Enums.LogType
  }

  export type CompanyUpdateOneRequiredWithoutTripLogsNestedInput = {
    create?: XOR<CompanyCreateWithoutTripLogsInput, CompanyUncheckedCreateWithoutTripLogsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutTripLogsInput
    upsert?: CompanyUpsertWithoutTripLogsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutTripLogsInput, CompanyUpdateWithoutTripLogsInput>, CompanyUncheckedUpdateWithoutTripLogsInput>
  }

  export type VehicleUpdateOneWithoutTripLogsNestedInput = {
    create?: XOR<VehicleCreateWithoutTripLogsInput, VehicleUncheckedCreateWithoutTripLogsInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutTripLogsInput
    upsert?: VehicleUpsertWithoutTripLogsInput
    disconnect?: VehicleWhereInput | boolean
    delete?: VehicleWhereInput | boolean
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutTripLogsInput, VehicleUpdateWithoutTripLogsInput>, VehicleUncheckedUpdateWithoutTripLogsInput>
  }

  export type DriverUpdateOneWithoutTripLogsNestedInput = {
    create?: XOR<DriverCreateWithoutTripLogsInput, DriverUncheckedCreateWithoutTripLogsInput>
    connectOrCreate?: DriverCreateOrConnectWithoutTripLogsInput
    upsert?: DriverUpsertWithoutTripLogsInput
    disconnect?: DriverWhereInput | boolean
    delete?: DriverWhereInput | boolean
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutTripLogsInput, DriverUpdateWithoutTripLogsInput>, DriverUncheckedUpdateWithoutTripLogsInput>
  }

  export type UserUpdateOneWithoutTripLogsNestedInput = {
    create?: XOR<UserCreateWithoutTripLogsInput, UserUncheckedCreateWithoutTripLogsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTripLogsInput
    upsert?: UserUpsertWithoutTripLogsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTripLogsInput, UserUpdateWithoutTripLogsInput>, UserUncheckedUpdateWithoutTripLogsInput>
  }

  export type BookingUpdateOneWithoutTripLogNestedInput = {
    create?: XOR<BookingCreateWithoutTripLogInput, BookingUncheckedCreateWithoutTripLogInput>
    connectOrCreate?: BookingCreateOrConnectWithoutTripLogInput
    upsert?: BookingUpsertWithoutTripLogInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutTripLogInput, BookingUpdateWithoutTripLogInput>, BookingUncheckedUpdateWithoutTripLogInput>
  }

  export type TripLogUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<TripLogCreateWithoutChildrenInput, TripLogUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: TripLogCreateOrConnectWithoutChildrenInput
    upsert?: TripLogUpsertWithoutChildrenInput
    disconnect?: TripLogWhereInput | boolean
    delete?: TripLogWhereInput | boolean
    connect?: TripLogWhereUniqueInput
    update?: XOR<XOR<TripLogUpdateToOneWithWhereWithoutChildrenInput, TripLogUpdateWithoutChildrenInput>, TripLogUncheckedUpdateWithoutChildrenInput>
  }

  export type TripLogUpdateManyWithoutParentNestedInput = {
    create?: XOR<TripLogCreateWithoutParentInput, TripLogUncheckedCreateWithoutParentInput> | TripLogCreateWithoutParentInput[] | TripLogUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutParentInput | TripLogCreateOrConnectWithoutParentInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutParentInput | TripLogUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TripLogCreateManyParentInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutParentInput | TripLogUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutParentInput | TripLogUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type GovernmentApiRequestUpdateManyWithoutTripLogNestedInput = {
    create?: XOR<GovernmentApiRequestCreateWithoutTripLogInput, GovernmentApiRequestUncheckedCreateWithoutTripLogInput> | GovernmentApiRequestCreateWithoutTripLogInput[] | GovernmentApiRequestUncheckedCreateWithoutTripLogInput[]
    connectOrCreate?: GovernmentApiRequestCreateOrConnectWithoutTripLogInput | GovernmentApiRequestCreateOrConnectWithoutTripLogInput[]
    upsert?: GovernmentApiRequestUpsertWithWhereUniqueWithoutTripLogInput | GovernmentApiRequestUpsertWithWhereUniqueWithoutTripLogInput[]
    createMany?: GovernmentApiRequestCreateManyTripLogInputEnvelope
    set?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
    disconnect?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
    delete?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
    connect?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
    update?: GovernmentApiRequestUpdateWithWhereUniqueWithoutTripLogInput | GovernmentApiRequestUpdateWithWhereUniqueWithoutTripLogInput[]
    updateMany?: GovernmentApiRequestUpdateManyWithWhereWithoutTripLogInput | GovernmentApiRequestUpdateManyWithWhereWithoutTripLogInput[]
    deleteMany?: GovernmentApiRequestScalarWhereInput | GovernmentApiRequestScalarWhereInput[]
  }

  export type TripLogUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<TripLogCreateWithoutParentInput, TripLogUncheckedCreateWithoutParentInput> | TripLogCreateWithoutParentInput[] | TripLogUncheckedCreateWithoutParentInput[]
    connectOrCreate?: TripLogCreateOrConnectWithoutParentInput | TripLogCreateOrConnectWithoutParentInput[]
    upsert?: TripLogUpsertWithWhereUniqueWithoutParentInput | TripLogUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: TripLogCreateManyParentInputEnvelope
    set?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    disconnect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    delete?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    connect?: TripLogWhereUniqueInput | TripLogWhereUniqueInput[]
    update?: TripLogUpdateWithWhereUniqueWithoutParentInput | TripLogUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: TripLogUpdateManyWithWhereWithoutParentInput | TripLogUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
  }

  export type GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput = {
    create?: XOR<GovernmentApiRequestCreateWithoutTripLogInput, GovernmentApiRequestUncheckedCreateWithoutTripLogInput> | GovernmentApiRequestCreateWithoutTripLogInput[] | GovernmentApiRequestUncheckedCreateWithoutTripLogInput[]
    connectOrCreate?: GovernmentApiRequestCreateOrConnectWithoutTripLogInput | GovernmentApiRequestCreateOrConnectWithoutTripLogInput[]
    upsert?: GovernmentApiRequestUpsertWithWhereUniqueWithoutTripLogInput | GovernmentApiRequestUpsertWithWhereUniqueWithoutTripLogInput[]
    createMany?: GovernmentApiRequestCreateManyTripLogInputEnvelope
    set?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
    disconnect?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
    delete?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
    connect?: GovernmentApiRequestWhereUniqueInput | GovernmentApiRequestWhereUniqueInput[]
    update?: GovernmentApiRequestUpdateWithWhereUniqueWithoutTripLogInput | GovernmentApiRequestUpdateWithWhereUniqueWithoutTripLogInput[]
    updateMany?: GovernmentApiRequestUpdateManyWithWhereWithoutTripLogInput | GovernmentApiRequestUpdateManyWithWhereWithoutTripLogInput[]
    deleteMany?: GovernmentApiRequestScalarWhereInput | GovernmentApiRequestScalarWhereInput[]
  }

  export type TripLogCreateNestedOneWithoutApiRequestsInput = {
    create?: XOR<TripLogCreateWithoutApiRequestsInput, TripLogUncheckedCreateWithoutApiRequestsInput>
    connectOrCreate?: TripLogCreateOrConnectWithoutApiRequestsInput
    connect?: TripLogWhereUniqueInput
  }

  export type EnumApiRequestTypeFieldUpdateOperationsInput = {
    set?: $Enums.ApiRequestType
  }

  export type TripLogUpdateOneRequiredWithoutApiRequestsNestedInput = {
    create?: XOR<TripLogCreateWithoutApiRequestsInput, TripLogUncheckedCreateWithoutApiRequestsInput>
    connectOrCreate?: TripLogCreateOrConnectWithoutApiRequestsInput
    upsert?: TripLogUpsertWithoutApiRequestsInput
    connect?: TripLogWhereUniqueInput
    update?: XOR<XOR<TripLogUpdateToOneWithWhereWithoutApiRequestsInput, TripLogUpdateWithoutApiRequestsInput>, TripLogUncheckedUpdateWithoutApiRequestsInput>
  }

  export type DriverCreateNestedOneWithoutLocationUpdatesInput = {
    create?: XOR<DriverCreateWithoutLocationUpdatesInput, DriverUncheckedCreateWithoutLocationUpdatesInput>
    connectOrCreate?: DriverCreateOrConnectWithoutLocationUpdatesInput
    connect?: DriverWhereUniqueInput
  }

  export type VehicleCreateNestedOneWithoutLocationUpdatesInput = {
    create?: XOR<VehicleCreateWithoutLocationUpdatesInput, VehicleUncheckedCreateWithoutLocationUpdatesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutLocationUpdatesInput
    connect?: VehicleWhereUniqueInput
  }

  export type DriverUpdateOneRequiredWithoutLocationUpdatesNestedInput = {
    create?: XOR<DriverCreateWithoutLocationUpdatesInput, DriverUncheckedCreateWithoutLocationUpdatesInput>
    connectOrCreate?: DriverCreateOrConnectWithoutLocationUpdatesInput
    upsert?: DriverUpsertWithoutLocationUpdatesInput
    connect?: DriverWhereUniqueInput
    update?: XOR<XOR<DriverUpdateToOneWithWhereWithoutLocationUpdatesInput, DriverUpdateWithoutLocationUpdatesInput>, DriverUncheckedUpdateWithoutLocationUpdatesInput>
  }

  export type VehicleUpdateOneRequiredWithoutLocationUpdatesNestedInput = {
    create?: XOR<VehicleCreateWithoutLocationUpdatesInput, VehicleUncheckedCreateWithoutLocationUpdatesInput>
    connectOrCreate?: VehicleCreateOrConnectWithoutLocationUpdatesInput
    upsert?: VehicleUpsertWithoutLocationUpdatesInput
    connect?: VehicleWhereUniqueInput
    update?: XOR<XOR<VehicleUpdateToOneWithWhereWithoutLocationUpdatesInput, VehicleUpdateWithoutLocationUpdatesInput>, VehicleUncheckedUpdateWithoutLocationUpdatesInput>
  }

  export type CompanyCreateNestedOneWithoutSubscriptionsInput = {
    create?: XOR<CompanyCreateWithoutSubscriptionsInput, CompanyUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSubscriptionsInput
    connect?: CompanyWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutSubscriptionInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumSubscriptionStatusFieldUpdateOperationsInput = {
    set?: $Enums.SubscriptionStatus
  }

  export type CompanyUpdateOneRequiredWithoutSubscriptionsNestedInput = {
    create?: XOR<CompanyCreateWithoutSubscriptionsInput, CompanyUncheckedCreateWithoutSubscriptionsInput>
    connectOrCreate?: CompanyCreateOrConnectWithoutSubscriptionsInput
    upsert?: CompanyUpsertWithoutSubscriptionsInput
    connect?: CompanyWhereUniqueInput
    update?: XOR<XOR<CompanyUpdateToOneWithWhereWithoutSubscriptionsInput, CompanyUpdateWithoutSubscriptionsInput>, CompanyUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type PaymentUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput = {
    create?: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput> | PaymentCreateWithoutSubscriptionInput[] | PaymentUncheckedCreateWithoutSubscriptionInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutSubscriptionInput | PaymentCreateOrConnectWithoutSubscriptionInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutSubscriptionInput | PaymentUpsertWithWhereUniqueWithoutSubscriptionInput[]
    createMany?: PaymentCreateManySubscriptionInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutSubscriptionInput | PaymentUpdateWithWhereUniqueWithoutSubscriptionInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutSubscriptionInput | PaymentUpdateManyWithWhereWithoutSubscriptionInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SubscriptionCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type SubscriptionUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: SubscriptionCreateOrConnectWithoutPaymentsInput
    upsert?: SubscriptionUpsertWithoutPaymentsInput
    connect?: SubscriptionWhereUniqueInput
    update?: XOR<XOR<SubscriptionUpdateToOneWithWhereWithoutPaymentsInput, SubscriptionUpdateWithoutPaymentsInput>, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[]
    notIn?: $Enums.UserRole[]
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedEnumSubscriptionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[]
    notIn?: $Enums.SubscriptionType[]
    not?: NestedEnumSubscriptionTypeFilter<$PrismaModel> | $Enums.SubscriptionType
  }

  export type NestedEnumCompanyStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[]
    notIn?: $Enums.CompanyStatus[]
    not?: NestedEnumCompanyStatusFilter<$PrismaModel> | $Enums.CompanyStatus
  }

  export type NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionType | EnumSubscriptionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionType[]
    notIn?: $Enums.SubscriptionType[]
    not?: NestedEnumSubscriptionTypeWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionTypeFilter<$PrismaModel>
  }

  export type NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.CompanyStatus | EnumCompanyStatusFieldRefInput<$PrismaModel>
    in?: $Enums.CompanyStatus[]
    notIn?: $Enums.CompanyStatus[]
    not?: NestedEnumCompanyStatusWithAggregatesFilter<$PrismaModel> | $Enums.CompanyStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCompanyStatusFilter<$PrismaModel>
    _max?: NestedEnumCompanyStatusFilter<$PrismaModel>
  }

  export type NestedEnumVehicleStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[]
    notIn?: $Enums.VehicleStatus[]
    not?: NestedEnumVehicleStatusFilter<$PrismaModel> | $Enums.VehicleStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VehicleStatus | EnumVehicleStatusFieldRefInput<$PrismaModel>
    in?: $Enums.VehicleStatus[]
    notIn?: $Enums.VehicleStatus[]
    not?: NestedEnumVehicleStatusWithAggregatesFilter<$PrismaModel> | $Enums.VehicleStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVehicleStatusFilter<$PrismaModel>
    _max?: NestedEnumVehicleStatusFilter<$PrismaModel>
  }

  export type NestedEnumDriverStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.DriverStatus | EnumDriverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DriverStatus[]
    notIn?: $Enums.DriverStatus[]
    not?: NestedEnumDriverStatusFilter<$PrismaModel> | $Enums.DriverStatus
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumDriverStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DriverStatus | EnumDriverStatusFieldRefInput<$PrismaModel>
    in?: $Enums.DriverStatus[]
    notIn?: $Enums.DriverStatus[]
    not?: NestedEnumDriverStatusWithAggregatesFilter<$PrismaModel> | $Enums.DriverStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDriverStatusFilter<$PrismaModel>
    _max?: NestedEnumDriverStatusFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumTariffTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TariffType | EnumTariffTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TariffType[]
    notIn?: $Enums.TariffType[]
    not?: NestedEnumTariffTypeFilter<$PrismaModel> | $Enums.TariffType
  }

  export type NestedEnumTariffTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TariffType | EnumTariffTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TariffType[]
    notIn?: $Enums.TariffType[]
    not?: NestedEnumTariffTypeWithAggregatesFilter<$PrismaModel> | $Enums.TariffType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTariffTypeFilter<$PrismaModel>
    _max?: NestedEnumTariffTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[]
    notIn?: $Enums.BookingStatus[]
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumLogTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[]
    notIn?: $Enums.LogType[]
    not?: NestedEnumLogTypeFilter<$PrismaModel> | $Enums.LogType
  }

  export type NestedEnumLogTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LogType | EnumLogTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LogType[]
    notIn?: $Enums.LogType[]
    not?: NestedEnumLogTypeWithAggregatesFilter<$PrismaModel> | $Enums.LogType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLogTypeFilter<$PrismaModel>
    _max?: NestedEnumLogTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumApiRequestTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiRequestType | EnumApiRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiRequestType[]
    notIn?: $Enums.ApiRequestType[]
    not?: NestedEnumApiRequestTypeFilter<$PrismaModel> | $Enums.ApiRequestType
  }

  export type NestedEnumApiRequestTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ApiRequestType | EnumApiRequestTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ApiRequestType[]
    notIn?: $Enums.ApiRequestType[]
    not?: NestedEnumApiRequestTypeWithAggregatesFilter<$PrismaModel> | $Enums.ApiRequestType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumApiRequestTypeFilter<$PrismaModel>
    _max?: NestedEnumApiRequestTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumSubscriptionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusFilter<$PrismaModel> | $Enums.SubscriptionStatus
  }

  export type NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SubscriptionStatus | EnumSubscriptionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SubscriptionStatus[]
    notIn?: $Enums.SubscriptionStatus[]
    not?: NestedEnumSubscriptionStatusWithAggregatesFilter<$PrismaModel> | $Enums.SubscriptionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
    _max?: NestedEnumSubscriptionStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[]
    notIn?: $Enums.PaymentStatus[]
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserCreateNestedManyWithoutUserInput
    driverProfile?: DriverCreateNestedOneWithoutUserInput
    riderBookings?: BookingCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    driverProfile?: DriverUncheckedCreateNestedOneWithoutUserInput
    riderBookings?: BookingUncheckedCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUncheckedUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUncheckedUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserCreateNestedManyWithoutUserInput
    driverProfile?: DriverCreateNestedOneWithoutUserInput
    riderBookings?: BookingCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    driverProfile?: DriverUncheckedCreateNestedOneWithoutUserInput
    riderBookings?: BookingUncheckedCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUncheckedUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUncheckedUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
  }

  export type CompanyUserCreateWithoutUserInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    company: CompanyCreateNestedOneWithoutUsersInput
  }

  export type CompanyUserUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    role?: string
    createdAt?: Date | string
  }

  export type CompanyUserCreateOrConnectWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserCreateManyUserInputEnvelope = {
    data: CompanyUserCreateManyUserInput | CompanyUserCreateManyUserInput[]
  }

  export type DriverCreateWithoutUserInput = {
    id?: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutDriversInput
    vehicle?: VehicleCreateNestedOneWithoutDriversInput
    bookings?: BookingCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutUserInput = {
    id?: string
    companyId: string
    vehicleId?: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutUserInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
  }

  export type BookingCreateWithoutRiderInput = {
    id?: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutBookingsInput
    driver?: DriverCreateNestedOneWithoutBookingsInput
    vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    tariff: TariffCreateNestedOneWithoutBookingsInput
    tripLog?: TripLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutRiderInput = {
    id?: string
    companyId: string
    driverId?: string | null
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripLog?: TripLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutRiderInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutRiderInput, BookingUncheckedCreateWithoutRiderInput>
  }

  export type BookingCreateManyRiderInputEnvelope = {
    data: BookingCreateManyRiderInput | BookingCreateManyRiderInput[]
  }

  export type TripLogCreateWithoutUserInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTripLogsInput
    vehicle?: VehicleCreateNestedOneWithoutTripLogsInput
    driver?: DriverCreateNestedOneWithoutTripLogsInput
    booking?: BookingCreateNestedOneWithoutTripLogInput
    parent?: TripLogCreateNestedOneWithoutChildrenInput
    children?: TripLogCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUncheckedCreateWithoutUserInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: TripLogUncheckedCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput
  }

  export type TripLogCreateOrConnectWithoutUserInput = {
    where: TripLogWhereUniqueInput
    create: XOR<TripLogCreateWithoutUserInput, TripLogUncheckedCreateWithoutUserInput>
  }

  export type TripLogCreateManyUserInputEnvelope = {
    data: TripLogCreateManyUserInput | TripLogCreateManyUserInput[]
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
    create: XOR<CompanyUserCreateWithoutUserInput, CompanyUserUncheckedCreateWithoutUserInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutUserInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutUserInput, CompanyUserUncheckedUpdateWithoutUserInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutUserInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutUserInput>
  }

  export type CompanyUserScalarWhereInput = {
    AND?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    OR?: CompanyUserScalarWhereInput[]
    NOT?: CompanyUserScalarWhereInput | CompanyUserScalarWhereInput[]
    id?: StringFilter<"CompanyUser"> | string
    userId?: StringFilter<"CompanyUser"> | string
    companyId?: StringFilter<"CompanyUser"> | string
    role?: StringFilter<"CompanyUser"> | string
    createdAt?: DateTimeFilter<"CompanyUser"> | Date | string
  }

  export type DriverUpsertWithoutUserInput = {
    update: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
    create: XOR<DriverCreateWithoutUserInput, DriverUncheckedCreateWithoutUserInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutUserInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutUserInput, DriverUncheckedUpdateWithoutUserInput>
  }

  export type DriverUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutDriversNestedInput
    vehicle?: VehicleUpdateOneWithoutDriversNestedInput
    bookings?: BookingUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutRiderInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutRiderInput, BookingUncheckedUpdateWithoutRiderInput>
    create: XOR<BookingCreateWithoutRiderInput, BookingUncheckedCreateWithoutRiderInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutRiderInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutRiderInput, BookingUncheckedUpdateWithoutRiderInput>
  }

  export type BookingUpdateManyWithWhereWithoutRiderInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutRiderInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    riderId?: StringFilter<"Booking"> | string
    companyId?: StringFilter<"Booking"> | string
    driverId?: StringNullableFilter<"Booking"> | string | null
    vehicleId?: StringNullableFilter<"Booking"> | string | null
    tariffId?: StringFilter<"Booking"> | string
    pickupLatitude?: FloatFilter<"Booking"> | number
    pickupLongitude?: FloatFilter<"Booking"> | number
    pickupAddress?: StringFilter<"Booking"> | string
    destinationLatitude?: FloatNullableFilter<"Booking"> | number | null
    destinationLongitude?: FloatNullableFilter<"Booking"> | number | null
    destinationAddress?: StringNullableFilter<"Booking"> | string | null
    estimatedPrice?: FloatNullableFilter<"Booking"> | number | null
    finalPrice?: FloatNullableFilter<"Booking"> | number | null
    estimatedDuration?: IntNullableFilter<"Booking"> | number | null
    actualDuration?: IntNullableFilter<"Booking"> | number | null
    distance?: FloatNullableFilter<"Booking"> | number | null
    riderName?: StringFilter<"Booking"> | string
    riderPhone?: StringFilter<"Booking"> | string
    notes?: StringNullableFilter<"Booking"> | string | null
    scheduledTime?: DateTimeNullableFilter<"Booking"> | Date | string | null
    acceptedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    startedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    cancelledAt?: DateTimeNullableFilter<"Booking"> | Date | string | null
    status?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type TripLogUpsertWithWhereUniqueWithoutUserInput = {
    where: TripLogWhereUniqueInput
    update: XOR<TripLogUpdateWithoutUserInput, TripLogUncheckedUpdateWithoutUserInput>
    create: XOR<TripLogCreateWithoutUserInput, TripLogUncheckedCreateWithoutUserInput>
  }

  export type TripLogUpdateWithWhereUniqueWithoutUserInput = {
    where: TripLogWhereUniqueInput
    data: XOR<TripLogUpdateWithoutUserInput, TripLogUncheckedUpdateWithoutUserInput>
  }

  export type TripLogUpdateManyWithWhereWithoutUserInput = {
    where: TripLogScalarWhereInput
    data: XOR<TripLogUpdateManyMutationInput, TripLogUncheckedUpdateManyWithoutUserInput>
  }

  export type TripLogScalarWhereInput = {
    AND?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
    OR?: TripLogScalarWhereInput[]
    NOT?: TripLogScalarWhereInput | TripLogScalarWhereInput[]
    id?: StringFilter<"TripLog"> | string
    parentId?: StringNullableFilter<"TripLog"> | string | null
    logType?: EnumLogTypeFilter<"TripLog"> | $Enums.LogType
    companyId?: StringFilter<"TripLog"> | string
    vehicleId?: StringNullableFilter<"TripLog"> | string | null
    driverId?: StringNullableFilter<"TripLog"> | string | null
    userId?: StringNullableFilter<"TripLog"> | string | null
    bookingId?: StringNullableFilter<"TripLog"> | string | null
    startLatitude?: FloatNullableFilter<"TripLog"> | number | null
    startLongitude?: FloatNullableFilter<"TripLog"> | number | null
    startAddress?: StringNullableFilter<"TripLog"> | string | null
    endLatitude?: FloatNullableFilter<"TripLog"> | number | null
    endLongitude?: FloatNullableFilter<"TripLog"> | number | null
    endAddress?: StringNullableFilter<"TripLog"> | string | null
    distance?: FloatNullableFilter<"TripLog"> | number | null
    duration?: IntNullableFilter<"TripLog"> | number | null
    finalPrice?: FloatNullableFilter<"TripLog"> | number | null
    tariffUsed?: StringNullableFilter<"TripLog"> | string | null
    governmentTripId?: StringNullableFilter<"TripLog"> | string | null
    tripStartApiSent?: BoolFilter<"TripLog"> | boolean
    tripEndApiSent?: BoolFilter<"TripLog"> | boolean
    apiErrorLog?: StringNullableFilter<"TripLog"> | string | null
    logDetails?: JsonNullableFilter<"TripLog">
    tripStartTime?: DateTimeNullableFilter<"TripLog"> | Date | string | null
    tripEndTime?: DateTimeNullableFilter<"TripLog"> | Date | string | null
    createdAt?: DateTimeFilter<"TripLog"> | Date | string
    updatedAt?: DateTimeFilter<"TripLog"> | Date | string
  }

  export type VehicleCreateWithoutCompanyInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverCreateNestedManyWithoutVehicleInput
    tariffs?: TariffCreateNestedManyWithoutVehicleInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutCompanyInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVehicleInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutCompanyInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutCompanyInput, VehicleUncheckedCreateWithoutCompanyInput>
  }

  export type VehicleCreateManyCompanyInputEnvelope = {
    data: VehicleCreateManyCompanyInput | VehicleCreateManyCompanyInput[]
  }

  export type DriverCreateWithoutCompanyInput = {
    id?: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverProfileInput
    vehicle?: VehicleCreateNestedOneWithoutDriversInput
    bookings?: BookingCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    vehicleId?: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutCompanyInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutCompanyInput, DriverUncheckedCreateWithoutCompanyInput>
  }

  export type DriverCreateManyCompanyInputEnvelope = {
    data: DriverCreateManyCompanyInput | DriverCreateManyCompanyInput[]
  }

  export type TariffCreateWithoutCompanyInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: VehicleCreateNestedOneWithoutTariffsInput
    bookings?: BookingCreateNestedManyWithoutTariffInput
  }

  export type TariffUncheckedCreateWithoutCompanyInput = {
    id?: string
    vehicleId?: string | null
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutTariffInput
  }

  export type TariffCreateOrConnectWithoutCompanyInput = {
    where: TariffWhereUniqueInput
    create: XOR<TariffCreateWithoutCompanyInput, TariffUncheckedCreateWithoutCompanyInput>
  }

  export type TariffCreateManyCompanyInputEnvelope = {
    data: TariffCreateManyCompanyInput | TariffCreateManyCompanyInput[]
  }

  export type CompanyUserCreateWithoutCompanyInput = {
    id?: string
    role?: string
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCompanyUserInput
  }

  export type CompanyUserUncheckedCreateWithoutCompanyInput = {
    id?: string
    userId: string
    role?: string
    createdAt?: Date | string
  }

  export type CompanyUserCreateOrConnectWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserCreateManyCompanyInputEnvelope = {
    data: CompanyUserCreateManyCompanyInput | CompanyUserCreateManyCompanyInput[]
  }

  export type SubscriptionCreateWithoutCompanyInput = {
    id?: string
    subscriptionType: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate?: Date | string | null
    pricePerMonth: number
    paymentProvider?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionUncheckedCreateWithoutCompanyInput = {
    id?: string
    subscriptionType: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate?: Date | string | null
    pricePerMonth: number
    paymentProvider?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutSubscriptionInput
  }

  export type SubscriptionCreateOrConnectWithoutCompanyInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput>
  }

  export type SubscriptionCreateManyCompanyInputEnvelope = {
    data: SubscriptionCreateManyCompanyInput | SubscriptionCreateManyCompanyInput[]
  }

  export type BookingCreateWithoutCompanyInput = {
    id?: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rider: UserCreateNestedOneWithoutRiderBookingsInput
    driver?: DriverCreateNestedOneWithoutBookingsInput
    vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    tariff: TariffCreateNestedOneWithoutBookingsInput
    tripLog?: TripLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutCompanyInput = {
    id?: string
    riderId: string
    driverId?: string | null
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripLog?: TripLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutCompanyInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutCompanyInput, BookingUncheckedCreateWithoutCompanyInput>
  }

  export type BookingCreateManyCompanyInputEnvelope = {
    data: BookingCreateManyCompanyInput | BookingCreateManyCompanyInput[]
  }

  export type TripLogCreateWithoutCompanyInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: VehicleCreateNestedOneWithoutTripLogsInput
    driver?: DriverCreateNestedOneWithoutTripLogsInput
    user?: UserCreateNestedOneWithoutTripLogsInput
    booking?: BookingCreateNestedOneWithoutTripLogInput
    parent?: TripLogCreateNestedOneWithoutChildrenInput
    children?: TripLogCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUncheckedCreateWithoutCompanyInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: TripLogUncheckedCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput
  }

  export type TripLogCreateOrConnectWithoutCompanyInput = {
    where: TripLogWhereUniqueInput
    create: XOR<TripLogCreateWithoutCompanyInput, TripLogUncheckedCreateWithoutCompanyInput>
  }

  export type TripLogCreateManyCompanyInputEnvelope = {
    data: TripLogCreateManyCompanyInput | TripLogCreateManyCompanyInput[]
  }

  export type VehicleUpsertWithWhereUniqueWithoutCompanyInput = {
    where: VehicleWhereUniqueInput
    update: XOR<VehicleUpdateWithoutCompanyInput, VehicleUncheckedUpdateWithoutCompanyInput>
    create: XOR<VehicleCreateWithoutCompanyInput, VehicleUncheckedCreateWithoutCompanyInput>
  }

  export type VehicleUpdateWithWhereUniqueWithoutCompanyInput = {
    where: VehicleWhereUniqueInput
    data: XOR<VehicleUpdateWithoutCompanyInput, VehicleUncheckedUpdateWithoutCompanyInput>
  }

  export type VehicleUpdateManyWithWhereWithoutCompanyInput = {
    where: VehicleScalarWhereInput
    data: XOR<VehicleUpdateManyMutationInput, VehicleUncheckedUpdateManyWithoutCompanyInput>
  }

  export type VehicleScalarWhereInput = {
    AND?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    OR?: VehicleScalarWhereInput[]
    NOT?: VehicleScalarWhereInput | VehicleScalarWhereInput[]
    id?: StringFilter<"Vehicle"> | string
    companyId?: StringFilter<"Vehicle"> | string
    licensePlate?: StringFilter<"Vehicle"> | string
    brand?: StringFilter<"Vehicle"> | string
    model?: StringFilter<"Vehicle"> | string
    year?: IntFilter<"Vehicle"> | number
    color?: StringFilter<"Vehicle"> | string
    taxiLicenseNumber?: StringFilter<"Vehicle"> | string
    insuranceExpiry?: DateTimeFilter<"Vehicle"> | Date | string
    keuringExpiry?: DateTimeFilter<"Vehicle"> | Date | string
    pictures?: StringFilter<"Vehicle"> | string
    status?: EnumVehicleStatusFilter<"Vehicle"> | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: StringNullableFilter<"Vehicle"> | string | null
    taxiLightWebhookOffUrl?: StringNullableFilter<"Vehicle"> | string | null
    createdAt?: DateTimeFilter<"Vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"Vehicle"> | Date | string
  }

  export type DriverUpsertWithWhereUniqueWithoutCompanyInput = {
    where: DriverWhereUniqueInput
    update: XOR<DriverUpdateWithoutCompanyInput, DriverUncheckedUpdateWithoutCompanyInput>
    create: XOR<DriverCreateWithoutCompanyInput, DriverUncheckedCreateWithoutCompanyInput>
  }

  export type DriverUpdateWithWhereUniqueWithoutCompanyInput = {
    where: DriverWhereUniqueInput
    data: XOR<DriverUpdateWithoutCompanyInput, DriverUncheckedUpdateWithoutCompanyInput>
  }

  export type DriverUpdateManyWithWhereWithoutCompanyInput = {
    where: DriverScalarWhereInput
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyWithoutCompanyInput>
  }

  export type DriverScalarWhereInput = {
    AND?: DriverScalarWhereInput | DriverScalarWhereInput[]
    OR?: DriverScalarWhereInput[]
    NOT?: DriverScalarWhereInput | DriverScalarWhereInput[]
    id?: StringFilter<"Driver"> | string
    userId?: StringFilter<"Driver"> | string
    companyId?: StringFilter<"Driver"> | string
    vehicleId?: StringNullableFilter<"Driver"> | string | null
    firstName?: StringFilter<"Driver"> | string
    lastName?: StringFilter<"Driver"> | string
    taxiDriverLicense?: StringFilter<"Driver"> | string
    licenseExpiry?: DateTimeFilter<"Driver"> | Date | string
    address?: StringFilter<"Driver"> | string
    phone?: StringFilter<"Driver"> | string
    email?: StringFilter<"Driver"> | string
    picture?: StringNullableFilter<"Driver"> | string | null
    status?: EnumDriverStatusFilter<"Driver"> | $Enums.DriverStatus
    isOnline?: BoolFilter<"Driver"> | boolean
    currentLatitude?: FloatNullableFilter<"Driver"> | number | null
    currentLongitude?: FloatNullableFilter<"Driver"> | number | null
    lastLocationUpdate?: DateTimeNullableFilter<"Driver"> | Date | string | null
    createdAt?: DateTimeFilter<"Driver"> | Date | string
    updatedAt?: DateTimeFilter<"Driver"> | Date | string
  }

  export type TariffUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TariffWhereUniqueInput
    update: XOR<TariffUpdateWithoutCompanyInput, TariffUncheckedUpdateWithoutCompanyInput>
    create: XOR<TariffCreateWithoutCompanyInput, TariffUncheckedCreateWithoutCompanyInput>
  }

  export type TariffUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TariffWhereUniqueInput
    data: XOR<TariffUpdateWithoutCompanyInput, TariffUncheckedUpdateWithoutCompanyInput>
  }

  export type TariffUpdateManyWithWhereWithoutCompanyInput = {
    where: TariffScalarWhereInput
    data: XOR<TariffUpdateManyMutationInput, TariffUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TariffScalarWhereInput = {
    AND?: TariffScalarWhereInput | TariffScalarWhereInput[]
    OR?: TariffScalarWhereInput[]
    NOT?: TariffScalarWhereInput | TariffScalarWhereInput[]
    id?: StringFilter<"Tariff"> | string
    companyId?: StringFilter<"Tariff"> | string
    vehicleId?: StringNullableFilter<"Tariff"> | string | null
    name?: StringFilter<"Tariff"> | string
    code?: StringFilter<"Tariff"> | string
    type?: EnumTariffTypeFilter<"Tariff"> | $Enums.TariffType
    startPrice?: FloatFilter<"Tariff"> | number
    pricePerKm?: FloatFilter<"Tariff"> | number
    pricePerMinute?: FloatFilter<"Tariff"> | number
    nightSurcharge?: FloatFilter<"Tariff"> | number
    weekendSurcharge?: FloatFilter<"Tariff"> | number
    isActive?: BoolFilter<"Tariff"> | boolean
    nightStartTime?: StringNullableFilter<"Tariff"> | string | null
    nightEndTime?: StringNullableFilter<"Tariff"> | string | null
    createdAt?: DateTimeFilter<"Tariff"> | Date | string
    updatedAt?: DateTimeFilter<"Tariff"> | Date | string
  }

  export type CompanyUserUpsertWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    update: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
    create: XOR<CompanyUserCreateWithoutCompanyInput, CompanyUserUncheckedCreateWithoutCompanyInput>
  }

  export type CompanyUserUpdateWithWhereUniqueWithoutCompanyInput = {
    where: CompanyUserWhereUniqueInput
    data: XOR<CompanyUserUpdateWithoutCompanyInput, CompanyUserUncheckedUpdateWithoutCompanyInput>
  }

  export type CompanyUserUpdateManyWithWhereWithoutCompanyInput = {
    where: CompanyUserScalarWhereInput
    data: XOR<CompanyUserUpdateManyMutationInput, CompanyUserUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SubscriptionUpsertWithWhereUniqueWithoutCompanyInput = {
    where: SubscriptionWhereUniqueInput
    update: XOR<SubscriptionUpdateWithoutCompanyInput, SubscriptionUncheckedUpdateWithoutCompanyInput>
    create: XOR<SubscriptionCreateWithoutCompanyInput, SubscriptionUncheckedCreateWithoutCompanyInput>
  }

  export type SubscriptionUpdateWithWhereUniqueWithoutCompanyInput = {
    where: SubscriptionWhereUniqueInput
    data: XOR<SubscriptionUpdateWithoutCompanyInput, SubscriptionUncheckedUpdateWithoutCompanyInput>
  }

  export type SubscriptionUpdateManyWithWhereWithoutCompanyInput = {
    where: SubscriptionScalarWhereInput
    data: XOR<SubscriptionUpdateManyMutationInput, SubscriptionUncheckedUpdateManyWithoutCompanyInput>
  }

  export type SubscriptionScalarWhereInput = {
    AND?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    OR?: SubscriptionScalarWhereInput[]
    NOT?: SubscriptionScalarWhereInput | SubscriptionScalarWhereInput[]
    id?: StringFilter<"Subscription"> | string
    companyId?: StringFilter<"Subscription"> | string
    subscriptionType?: EnumSubscriptionTypeFilter<"Subscription"> | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFilter<"Subscription"> | $Enums.SubscriptionStatus
    startDate?: DateTimeFilter<"Subscription"> | Date | string
    endDate?: DateTimeNullableFilter<"Subscription"> | Date | string | null
    pricePerMonth?: FloatFilter<"Subscription"> | number
    paymentProvider?: StringNullableFilter<"Subscription"> | string | null
    externalId?: StringNullableFilter<"Subscription"> | string | null
    createdAt?: DateTimeFilter<"Subscription"> | Date | string
    updatedAt?: DateTimeFilter<"Subscription"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutCompanyInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutCompanyInput, BookingUncheckedUpdateWithoutCompanyInput>
    create: XOR<BookingCreateWithoutCompanyInput, BookingUncheckedCreateWithoutCompanyInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutCompanyInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutCompanyInput, BookingUncheckedUpdateWithoutCompanyInput>
  }

  export type BookingUpdateManyWithWhereWithoutCompanyInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutCompanyInput>
  }

  export type TripLogUpsertWithWhereUniqueWithoutCompanyInput = {
    where: TripLogWhereUniqueInput
    update: XOR<TripLogUpdateWithoutCompanyInput, TripLogUncheckedUpdateWithoutCompanyInput>
    create: XOR<TripLogCreateWithoutCompanyInput, TripLogUncheckedCreateWithoutCompanyInput>
  }

  export type TripLogUpdateWithWhereUniqueWithoutCompanyInput = {
    where: TripLogWhereUniqueInput
    data: XOR<TripLogUpdateWithoutCompanyInput, TripLogUncheckedUpdateWithoutCompanyInput>
  }

  export type TripLogUpdateManyWithWhereWithoutCompanyInput = {
    where: TripLogScalarWhereInput
    data: XOR<TripLogUpdateManyMutationInput, TripLogUncheckedUpdateManyWithoutCompanyInput>
  }

  export type UserCreateWithoutCompanyUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    driverProfile?: DriverCreateNestedOneWithoutUserInput
    riderBookings?: BookingCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCompanyUserInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    driverProfile?: DriverUncheckedCreateNestedOneWithoutUserInput
    riderBookings?: BookingUncheckedCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCompanyUserInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCompanyUserInput, UserUncheckedCreateWithoutCompanyUserInput>
  }

  export type CompanyCreateWithoutUsersInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutCompanyInput
    drivers?: DriverCreateNestedManyWithoutCompanyInput
    tariffs?: TariffCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    bookings?: BookingCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCompanyInput
    drivers?: DriverUncheckedCreateNestedManyWithoutCompanyInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutUsersInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
  }

  export type UserUpsertWithoutCompanyUserInput = {
    update: XOR<UserUpdateWithoutCompanyUserInput, UserUncheckedUpdateWithoutCompanyUserInput>
    create: XOR<UserCreateWithoutCompanyUserInput, UserUncheckedCreateWithoutCompanyUserInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCompanyUserInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCompanyUserInput, UserUncheckedUpdateWithoutCompanyUserInput>
  }

  export type UserUpdateWithoutCompanyUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCompanyUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUncheckedUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUncheckedUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutUsersInput = {
    update: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
    create: XOR<CompanyCreateWithoutUsersInput, CompanyUncheckedCreateWithoutUsersInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutUsersInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutUsersInput, CompanyUncheckedUpdateWithoutUsersInput>
  }

  export type CompanyUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyCreateWithoutVehiclesInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverCreateNestedManyWithoutCompanyInput
    tariffs?: TariffCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    bookings?: BookingCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutVehiclesInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutCompanyInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutVehiclesInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutVehiclesInput, CompanyUncheckedCreateWithoutVehiclesInput>
  }

  export type DriverCreateWithoutVehicleInput = {
    id?: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverProfileInput
    company: CompanyCreateNestedOneWithoutDriversInput
    bookings?: BookingCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutVehicleInput = {
    id?: string
    userId: string
    companyId: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutVehicleInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput>
  }

  export type DriverCreateManyVehicleInputEnvelope = {
    data: DriverCreateManyVehicleInput | DriverCreateManyVehicleInput[]
  }

  export type TariffCreateWithoutVehicleInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTariffsInput
    bookings?: BookingCreateNestedManyWithoutTariffInput
  }

  export type TariffUncheckedCreateWithoutVehicleInput = {
    id?: string
    companyId: string
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutTariffInput
  }

  export type TariffCreateOrConnectWithoutVehicleInput = {
    where: TariffWhereUniqueInput
    create: XOR<TariffCreateWithoutVehicleInput, TariffUncheckedCreateWithoutVehicleInput>
  }

  export type TariffCreateManyVehicleInputEnvelope = {
    data: TariffCreateManyVehicleInput | TariffCreateManyVehicleInput[]
  }

  export type BookingCreateWithoutVehicleInput = {
    id?: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rider: UserCreateNestedOneWithoutRiderBookingsInput
    company: CompanyCreateNestedOneWithoutBookingsInput
    driver?: DriverCreateNestedOneWithoutBookingsInput
    tariff: TariffCreateNestedOneWithoutBookingsInput
    tripLog?: TripLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutVehicleInput = {
    id?: string
    riderId: string
    companyId: string
    driverId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripLog?: TripLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput>
  }

  export type BookingCreateManyVehicleInputEnvelope = {
    data: BookingCreateManyVehicleInput | BookingCreateManyVehicleInput[]
  }

  export type TripLogCreateWithoutVehicleInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTripLogsInput
    driver?: DriverCreateNestedOneWithoutTripLogsInput
    user?: UserCreateNestedOneWithoutTripLogsInput
    booking?: BookingCreateNestedOneWithoutTripLogInput
    parent?: TripLogCreateNestedOneWithoutChildrenInput
    children?: TripLogCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUncheckedCreateWithoutVehicleInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: TripLogUncheckedCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput
  }

  export type TripLogCreateOrConnectWithoutVehicleInput = {
    where: TripLogWhereUniqueInput
    create: XOR<TripLogCreateWithoutVehicleInput, TripLogUncheckedCreateWithoutVehicleInput>
  }

  export type TripLogCreateManyVehicleInputEnvelope = {
    data: TripLogCreateManyVehicleInput | TripLogCreateManyVehicleInput[]
  }

  export type LocationUpdateCreateWithoutVehicleInput = {
    id?: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
    driver: DriverCreateNestedOneWithoutLocationUpdatesInput
  }

  export type LocationUpdateUncheckedCreateWithoutVehicleInput = {
    id?: string
    driverId: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
  }

  export type LocationUpdateCreateOrConnectWithoutVehicleInput = {
    where: LocationUpdateWhereUniqueInput
    create: XOR<LocationUpdateCreateWithoutVehicleInput, LocationUpdateUncheckedCreateWithoutVehicleInput>
  }

  export type LocationUpdateCreateManyVehicleInputEnvelope = {
    data: LocationUpdateCreateManyVehicleInput | LocationUpdateCreateManyVehicleInput[]
  }

  export type CompanyUpsertWithoutVehiclesInput = {
    update: XOR<CompanyUpdateWithoutVehiclesInput, CompanyUncheckedUpdateWithoutVehiclesInput>
    create: XOR<CompanyCreateWithoutVehiclesInput, CompanyUncheckedCreateWithoutVehiclesInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutVehiclesInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutVehiclesInput, CompanyUncheckedUpdateWithoutVehiclesInput>
  }

  export type CompanyUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutVehiclesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type DriverUpsertWithWhereUniqueWithoutVehicleInput = {
    where: DriverWhereUniqueInput
    update: XOR<DriverUpdateWithoutVehicleInput, DriverUncheckedUpdateWithoutVehicleInput>
    create: XOR<DriverCreateWithoutVehicleInput, DriverUncheckedCreateWithoutVehicleInput>
  }

  export type DriverUpdateWithWhereUniqueWithoutVehicleInput = {
    where: DriverWhereUniqueInput
    data: XOR<DriverUpdateWithoutVehicleInput, DriverUncheckedUpdateWithoutVehicleInput>
  }

  export type DriverUpdateManyWithWhereWithoutVehicleInput = {
    where: DriverScalarWhereInput
    data: XOR<DriverUpdateManyMutationInput, DriverUncheckedUpdateManyWithoutVehicleInput>
  }

  export type TariffUpsertWithWhereUniqueWithoutVehicleInput = {
    where: TariffWhereUniqueInput
    update: XOR<TariffUpdateWithoutVehicleInput, TariffUncheckedUpdateWithoutVehicleInput>
    create: XOR<TariffCreateWithoutVehicleInput, TariffUncheckedCreateWithoutVehicleInput>
  }

  export type TariffUpdateWithWhereUniqueWithoutVehicleInput = {
    where: TariffWhereUniqueInput
    data: XOR<TariffUpdateWithoutVehicleInput, TariffUncheckedUpdateWithoutVehicleInput>
  }

  export type TariffUpdateManyWithWhereWithoutVehicleInput = {
    where: TariffScalarWhereInput
    data: XOR<TariffUpdateManyMutationInput, TariffUncheckedUpdateManyWithoutVehicleInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutVehicleInput, BookingUncheckedUpdateWithoutVehicleInput>
    create: XOR<BookingCreateWithoutVehicleInput, BookingUncheckedCreateWithoutVehicleInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutVehicleInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutVehicleInput, BookingUncheckedUpdateWithoutVehicleInput>
  }

  export type BookingUpdateManyWithWhereWithoutVehicleInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutVehicleInput>
  }

  export type TripLogUpsertWithWhereUniqueWithoutVehicleInput = {
    where: TripLogWhereUniqueInput
    update: XOR<TripLogUpdateWithoutVehicleInput, TripLogUncheckedUpdateWithoutVehicleInput>
    create: XOR<TripLogCreateWithoutVehicleInput, TripLogUncheckedCreateWithoutVehicleInput>
  }

  export type TripLogUpdateWithWhereUniqueWithoutVehicleInput = {
    where: TripLogWhereUniqueInput
    data: XOR<TripLogUpdateWithoutVehicleInput, TripLogUncheckedUpdateWithoutVehicleInput>
  }

  export type TripLogUpdateManyWithWhereWithoutVehicleInput = {
    where: TripLogScalarWhereInput
    data: XOR<TripLogUpdateManyMutationInput, TripLogUncheckedUpdateManyWithoutVehicleInput>
  }

  export type LocationUpdateUpsertWithWhereUniqueWithoutVehicleInput = {
    where: LocationUpdateWhereUniqueInput
    update: XOR<LocationUpdateUpdateWithoutVehicleInput, LocationUpdateUncheckedUpdateWithoutVehicleInput>
    create: XOR<LocationUpdateCreateWithoutVehicleInput, LocationUpdateUncheckedCreateWithoutVehicleInput>
  }

  export type LocationUpdateUpdateWithWhereUniqueWithoutVehicleInput = {
    where: LocationUpdateWhereUniqueInput
    data: XOR<LocationUpdateUpdateWithoutVehicleInput, LocationUpdateUncheckedUpdateWithoutVehicleInput>
  }

  export type LocationUpdateUpdateManyWithWhereWithoutVehicleInput = {
    where: LocationUpdateScalarWhereInput
    data: XOR<LocationUpdateUpdateManyMutationInput, LocationUpdateUncheckedUpdateManyWithoutVehicleInput>
  }

  export type LocationUpdateScalarWhereInput = {
    AND?: LocationUpdateScalarWhereInput | LocationUpdateScalarWhereInput[]
    OR?: LocationUpdateScalarWhereInput[]
    NOT?: LocationUpdateScalarWhereInput | LocationUpdateScalarWhereInput[]
    id?: StringFilter<"LocationUpdate"> | string
    driverId?: StringFilter<"LocationUpdate"> | string
    vehicleId?: StringFilter<"LocationUpdate"> | string
    latitude?: FloatFilter<"LocationUpdate"> | number
    longitude?: FloatFilter<"LocationUpdate"> | number
    accuracy?: FloatNullableFilter<"LocationUpdate"> | number | null
    speed?: FloatNullableFilter<"LocationUpdate"> | number | null
    heading?: FloatNullableFilter<"LocationUpdate"> | number | null
    altitude?: FloatNullableFilter<"LocationUpdate"> | number | null
    createdAt?: DateTimeFilter<"LocationUpdate"> | Date | string
  }

  export type UserCreateWithoutDriverProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserCreateNestedManyWithoutUserInput
    riderBookings?: BookingCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutDriverProfileInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    riderBookings?: BookingUncheckedCreateNestedManyWithoutRiderInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutDriverProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDriverProfileInput, UserUncheckedCreateWithoutDriverProfileInput>
  }

  export type CompanyCreateWithoutDriversInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutCompanyInput
    tariffs?: TariffCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    bookings?: BookingCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutDriversInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCompanyInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutDriversInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutDriversInput, CompanyUncheckedCreateWithoutDriversInput>
  }

  export type VehicleCreateWithoutDriversInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVehiclesInput
    tariffs?: TariffCreateNestedManyWithoutVehicleInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutDriversInput = {
    id?: string
    companyId: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tariffs?: TariffUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutDriversInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutDriversInput, VehicleUncheckedCreateWithoutDriversInput>
  }

  export type BookingCreateWithoutDriverInput = {
    id?: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rider: UserCreateNestedOneWithoutRiderBookingsInput
    company: CompanyCreateNestedOneWithoutBookingsInput
    vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    tariff: TariffCreateNestedOneWithoutBookingsInput
    tripLog?: TripLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutDriverInput = {
    id?: string
    riderId: string
    companyId: string
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripLog?: TripLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutDriverInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutDriverInput, BookingUncheckedCreateWithoutDriverInput>
  }

  export type BookingCreateManyDriverInputEnvelope = {
    data: BookingCreateManyDriverInput | BookingCreateManyDriverInput[]
  }

  export type TripLogCreateWithoutDriverInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTripLogsInput
    vehicle?: VehicleCreateNestedOneWithoutTripLogsInput
    user?: UserCreateNestedOneWithoutTripLogsInput
    booking?: BookingCreateNestedOneWithoutTripLogInput
    parent?: TripLogCreateNestedOneWithoutChildrenInput
    children?: TripLogCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUncheckedCreateWithoutDriverInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: TripLogUncheckedCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput
  }

  export type TripLogCreateOrConnectWithoutDriverInput = {
    where: TripLogWhereUniqueInput
    create: XOR<TripLogCreateWithoutDriverInput, TripLogUncheckedCreateWithoutDriverInput>
  }

  export type TripLogCreateManyDriverInputEnvelope = {
    data: TripLogCreateManyDriverInput | TripLogCreateManyDriverInput[]
  }

  export type LocationUpdateCreateWithoutDriverInput = {
    id?: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
    vehicle: VehicleCreateNestedOneWithoutLocationUpdatesInput
  }

  export type LocationUpdateUncheckedCreateWithoutDriverInput = {
    id?: string
    vehicleId: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
  }

  export type LocationUpdateCreateOrConnectWithoutDriverInput = {
    where: LocationUpdateWhereUniqueInput
    create: XOR<LocationUpdateCreateWithoutDriverInput, LocationUpdateUncheckedCreateWithoutDriverInput>
  }

  export type LocationUpdateCreateManyDriverInputEnvelope = {
    data: LocationUpdateCreateManyDriverInput | LocationUpdateCreateManyDriverInput[]
  }

  export type UserUpsertWithoutDriverProfileInput = {
    update: XOR<UserUpdateWithoutDriverProfileInput, UserUncheckedUpdateWithoutDriverProfileInput>
    create: XOR<UserCreateWithoutDriverProfileInput, UserUncheckedCreateWithoutDriverProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDriverProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDriverProfileInput, UserUncheckedUpdateWithoutDriverProfileInput>
  }

  export type UserUpdateWithoutDriverProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUpdateManyWithoutUserNestedInput
    riderBookings?: BookingUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutDriverProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    riderBookings?: BookingUncheckedUpdateManyWithoutRiderNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutDriversInput = {
    update: XOR<CompanyUpdateWithoutDriversInput, CompanyUncheckedUpdateWithoutDriversInput>
    create: XOR<CompanyCreateWithoutDriversInput, CompanyUncheckedCreateWithoutDriversInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutDriversInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutDriversInput, CompanyUncheckedUpdateWithoutDriversInput>
  }

  export type CompanyUpdateWithoutDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VehicleUpsertWithoutDriversInput = {
    update: XOR<VehicleUpdateWithoutDriversInput, VehicleUncheckedUpdateWithoutDriversInput>
    create: XOR<VehicleCreateWithoutDriversInput, VehicleUncheckedCreateWithoutDriversInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutDriversInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutDriversInput, VehicleUncheckedUpdateWithoutDriversInput>
  }

  export type VehicleUpdateWithoutDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVehiclesNestedInput
    tariffs?: TariffUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutDriversInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tariffs?: TariffUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutDriverInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutDriverInput, BookingUncheckedUpdateWithoutDriverInput>
    create: XOR<BookingCreateWithoutDriverInput, BookingUncheckedCreateWithoutDriverInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutDriverInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutDriverInput, BookingUncheckedUpdateWithoutDriverInput>
  }

  export type BookingUpdateManyWithWhereWithoutDriverInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutDriverInput>
  }

  export type TripLogUpsertWithWhereUniqueWithoutDriverInput = {
    where: TripLogWhereUniqueInput
    update: XOR<TripLogUpdateWithoutDriverInput, TripLogUncheckedUpdateWithoutDriverInput>
    create: XOR<TripLogCreateWithoutDriverInput, TripLogUncheckedCreateWithoutDriverInput>
  }

  export type TripLogUpdateWithWhereUniqueWithoutDriverInput = {
    where: TripLogWhereUniqueInput
    data: XOR<TripLogUpdateWithoutDriverInput, TripLogUncheckedUpdateWithoutDriverInput>
  }

  export type TripLogUpdateManyWithWhereWithoutDriverInput = {
    where: TripLogScalarWhereInput
    data: XOR<TripLogUpdateManyMutationInput, TripLogUncheckedUpdateManyWithoutDriverInput>
  }

  export type LocationUpdateUpsertWithWhereUniqueWithoutDriverInput = {
    where: LocationUpdateWhereUniqueInput
    update: XOR<LocationUpdateUpdateWithoutDriverInput, LocationUpdateUncheckedUpdateWithoutDriverInput>
    create: XOR<LocationUpdateCreateWithoutDriverInput, LocationUpdateUncheckedCreateWithoutDriverInput>
  }

  export type LocationUpdateUpdateWithWhereUniqueWithoutDriverInput = {
    where: LocationUpdateWhereUniqueInput
    data: XOR<LocationUpdateUpdateWithoutDriverInput, LocationUpdateUncheckedUpdateWithoutDriverInput>
  }

  export type LocationUpdateUpdateManyWithWhereWithoutDriverInput = {
    where: LocationUpdateScalarWhereInput
    data: XOR<LocationUpdateUpdateManyMutationInput, LocationUpdateUncheckedUpdateManyWithoutDriverInput>
  }

  export type CompanyCreateWithoutTariffsInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutCompanyInput
    drivers?: DriverCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    bookings?: BookingCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTariffsInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCompanyInput
    drivers?: DriverUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTariffsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTariffsInput, CompanyUncheckedCreateWithoutTariffsInput>
  }

  export type VehicleCreateWithoutTariffsInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVehiclesInput
    drivers?: DriverCreateNestedManyWithoutVehicleInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutTariffsInput = {
    id?: string
    companyId: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutTariffsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTariffsInput, VehicleUncheckedCreateWithoutTariffsInput>
  }

  export type BookingCreateWithoutTariffInput = {
    id?: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rider: UserCreateNestedOneWithoutRiderBookingsInput
    company: CompanyCreateNestedOneWithoutBookingsInput
    driver?: DriverCreateNestedOneWithoutBookingsInput
    vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    tripLog?: TripLogCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutTariffInput = {
    id?: string
    riderId: string
    companyId: string
    driverId?: string | null
    vehicleId?: string | null
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    tripLog?: TripLogUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutTariffInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTariffInput, BookingUncheckedCreateWithoutTariffInput>
  }

  export type BookingCreateManyTariffInputEnvelope = {
    data: BookingCreateManyTariffInput | BookingCreateManyTariffInput[]
  }

  export type CompanyUpsertWithoutTariffsInput = {
    update: XOR<CompanyUpdateWithoutTariffsInput, CompanyUncheckedUpdateWithoutTariffsInput>
    create: XOR<CompanyCreateWithoutTariffsInput, CompanyUncheckedCreateWithoutTariffsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTariffsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTariffsInput, CompanyUncheckedUpdateWithoutTariffsInput>
  }

  export type CompanyUpdateWithoutTariffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTariffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VehicleUpsertWithoutTariffsInput = {
    update: XOR<VehicleUpdateWithoutTariffsInput, VehicleUncheckedUpdateWithoutTariffsInput>
    create: XOR<VehicleCreateWithoutTariffsInput, VehicleUncheckedCreateWithoutTariffsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutTariffsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutTariffsInput, VehicleUncheckedUpdateWithoutTariffsInput>
  }

  export type VehicleUpdateWithoutTariffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVehiclesNestedInput
    drivers?: DriverUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutTariffsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type BookingUpsertWithWhereUniqueWithoutTariffInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutTariffInput, BookingUncheckedUpdateWithoutTariffInput>
    create: XOR<BookingCreateWithoutTariffInput, BookingUncheckedCreateWithoutTariffInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutTariffInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutTariffInput, BookingUncheckedUpdateWithoutTariffInput>
  }

  export type BookingUpdateManyWithWhereWithoutTariffInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutTariffInput>
  }

  export type UserCreateWithoutRiderBookingsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserCreateNestedManyWithoutUserInput
    driverProfile?: DriverCreateNestedOneWithoutUserInput
    tripLogs?: TripLogCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutRiderBookingsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    driverProfile?: DriverUncheckedCreateNestedOneWithoutUserInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutRiderBookingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutRiderBookingsInput, UserUncheckedCreateWithoutRiderBookingsInput>
  }

  export type CompanyCreateWithoutBookingsInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutCompanyInput
    drivers?: DriverCreateNestedManyWithoutCompanyInput
    tariffs?: TariffCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutBookingsInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCompanyInput
    drivers?: DriverUncheckedCreateNestedManyWithoutCompanyInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutBookingsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutBookingsInput, CompanyUncheckedCreateWithoutBookingsInput>
  }

  export type DriverCreateWithoutBookingsInput = {
    id?: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverProfileInput
    company: CompanyCreateNestedOneWithoutDriversInput
    vehicle?: VehicleCreateNestedOneWithoutDriversInput
    tripLogs?: TripLogCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutBookingsInput = {
    id?: string
    userId: string
    companyId: string
    vehicleId?: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutBookingsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutBookingsInput, DriverUncheckedCreateWithoutBookingsInput>
  }

  export type VehicleCreateWithoutBookingsInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVehiclesInput
    drivers?: DriverCreateNestedManyWithoutVehicleInput
    tariffs?: TariffCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutBookingsInput = {
    id?: string
    companyId: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVehicleInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutBookingsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
  }

  export type TariffCreateWithoutBookingsInput = {
    id?: string
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTariffsInput
    vehicle?: VehicleCreateNestedOneWithoutTariffsInput
  }

  export type TariffUncheckedCreateWithoutBookingsInput = {
    id?: string
    companyId: string
    vehicleId?: string | null
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffCreateOrConnectWithoutBookingsInput = {
    where: TariffWhereUniqueInput
    create: XOR<TariffCreateWithoutBookingsInput, TariffUncheckedCreateWithoutBookingsInput>
  }

  export type TripLogCreateWithoutBookingInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTripLogsInput
    vehicle?: VehicleCreateNestedOneWithoutTripLogsInput
    driver?: DriverCreateNestedOneWithoutTripLogsInput
    user?: UserCreateNestedOneWithoutTripLogsInput
    parent?: TripLogCreateNestedOneWithoutChildrenInput
    children?: TripLogCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUncheckedCreateWithoutBookingInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: TripLogUncheckedCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput
  }

  export type TripLogCreateOrConnectWithoutBookingInput = {
    where: TripLogWhereUniqueInput
    create: XOR<TripLogCreateWithoutBookingInput, TripLogUncheckedCreateWithoutBookingInput>
  }

  export type UserUpsertWithoutRiderBookingsInput = {
    update: XOR<UserUpdateWithoutRiderBookingsInput, UserUncheckedUpdateWithoutRiderBookingsInput>
    create: XOR<UserCreateWithoutRiderBookingsInput, UserUncheckedCreateWithoutRiderBookingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutRiderBookingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutRiderBookingsInput, UserUncheckedUpdateWithoutRiderBookingsInput>
  }

  export type UserUpdateWithoutRiderBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUpdateOneWithoutUserNestedInput
    tripLogs?: TripLogUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutRiderBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUncheckedUpdateOneWithoutUserNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type CompanyUpsertWithoutBookingsInput = {
    update: XOR<CompanyUpdateWithoutBookingsInput, CompanyUncheckedUpdateWithoutBookingsInput>
    create: XOR<CompanyCreateWithoutBookingsInput, CompanyUncheckedCreateWithoutBookingsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutBookingsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutBookingsInput, CompanyUncheckedUpdateWithoutBookingsInput>
  }

  export type CompanyUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type DriverUpsertWithoutBookingsInput = {
    update: XOR<DriverUpdateWithoutBookingsInput, DriverUncheckedUpdateWithoutBookingsInput>
    create: XOR<DriverCreateWithoutBookingsInput, DriverUncheckedCreateWithoutBookingsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutBookingsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutBookingsInput, DriverUncheckedUpdateWithoutBookingsInput>
  }

  export type DriverUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverProfileNestedInput
    company?: CompanyUpdateOneRequiredWithoutDriversNestedInput
    vehicle?: VehicleUpdateOneWithoutDriversNestedInput
    tripLogs?: TripLogUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripLogs?: TripLogUncheckedUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type VehicleUpsertWithoutBookingsInput = {
    update: XOR<VehicleUpdateWithoutBookingsInput, VehicleUncheckedUpdateWithoutBookingsInput>
    create: XOR<VehicleCreateWithoutBookingsInput, VehicleUncheckedCreateWithoutBookingsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutBookingsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutBookingsInput, VehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type VehicleUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVehiclesNestedInput
    drivers?: DriverUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type TariffUpsertWithoutBookingsInput = {
    update: XOR<TariffUpdateWithoutBookingsInput, TariffUncheckedUpdateWithoutBookingsInput>
    create: XOR<TariffCreateWithoutBookingsInput, TariffUncheckedCreateWithoutBookingsInput>
    where?: TariffWhereInput
  }

  export type TariffUpdateToOneWithWhereWithoutBookingsInput = {
    where?: TariffWhereInput
    data: XOR<TariffUpdateWithoutBookingsInput, TariffUncheckedUpdateWithoutBookingsInput>
  }

  export type TariffUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTariffsNestedInput
    vehicle?: VehicleUpdateOneWithoutTariffsNestedInput
  }

  export type TariffUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogUpsertWithoutBookingInput = {
    update: XOR<TripLogUpdateWithoutBookingInput, TripLogUncheckedUpdateWithoutBookingInput>
    create: XOR<TripLogCreateWithoutBookingInput, TripLogUncheckedCreateWithoutBookingInput>
    where?: TripLogWhereInput
  }

  export type TripLogUpdateToOneWithWhereWithoutBookingInput = {
    where?: TripLogWhereInput
    data: XOR<TripLogUpdateWithoutBookingInput, TripLogUncheckedUpdateWithoutBookingInput>
  }

  export type TripLogUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTripLogsNestedInput
    vehicle?: VehicleUpdateOneWithoutTripLogsNestedInput
    driver?: DriverUpdateOneWithoutTripLogsNestedInput
    user?: UserUpdateOneWithoutTripLogsNestedInput
    parent?: TripLogUpdateOneWithoutChildrenNestedInput
    children?: TripLogUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: TripLogUncheckedUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput
  }

  export type CompanyCreateWithoutTripLogsInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutCompanyInput
    drivers?: DriverCreateNestedManyWithoutCompanyInput
    tariffs?: TariffCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionCreateNestedManyWithoutCompanyInput
    bookings?: BookingCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutTripLogsInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCompanyInput
    drivers?: DriverUncheckedCreateNestedManyWithoutCompanyInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    subscriptions?: SubscriptionUncheckedCreateNestedManyWithoutCompanyInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutTripLogsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutTripLogsInput, CompanyUncheckedCreateWithoutTripLogsInput>
  }

  export type VehicleCreateWithoutTripLogsInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVehiclesInput
    drivers?: DriverCreateNestedManyWithoutVehicleInput
    tariffs?: TariffCreateNestedManyWithoutVehicleInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutTripLogsInput = {
    id?: string
    companyId: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVehicleInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutTripLogsInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutTripLogsInput, VehicleUncheckedCreateWithoutTripLogsInput>
  }

  export type DriverCreateWithoutTripLogsInput = {
    id?: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverProfileInput
    company: CompanyCreateNestedOneWithoutDriversInput
    vehicle?: VehicleCreateNestedOneWithoutDriversInput
    bookings?: BookingCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutTripLogsInput = {
    id?: string
    userId: string
    companyId: string
    vehicleId?: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDriverInput
    locationUpdates?: LocationUpdateUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutTripLogsInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutTripLogsInput, DriverUncheckedCreateWithoutTripLogsInput>
  }

  export type UserCreateWithoutTripLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserCreateNestedManyWithoutUserInput
    driverProfile?: DriverCreateNestedOneWithoutUserInput
    riderBookings?: BookingCreateNestedManyWithoutRiderInput
  }

  export type UserUncheckedCreateWithoutTripLogsInput = {
    id?: string
    name?: string | null
    email: string
    emailVerified?: Date | string | null
    image?: string | null
    password?: string | null
    role?: $Enums.UserRole
    phone?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    companyUser?: CompanyUserUncheckedCreateNestedManyWithoutUserInput
    driverProfile?: DriverUncheckedCreateNestedOneWithoutUserInput
    riderBookings?: BookingUncheckedCreateNestedManyWithoutRiderInput
  }

  export type UserCreateOrConnectWithoutTripLogsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTripLogsInput, UserUncheckedCreateWithoutTripLogsInput>
  }

  export type BookingCreateWithoutTripLogInput = {
    id?: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    rider: UserCreateNestedOneWithoutRiderBookingsInput
    company: CompanyCreateNestedOneWithoutBookingsInput
    driver?: DriverCreateNestedOneWithoutBookingsInput
    vehicle?: VehicleCreateNestedOneWithoutBookingsInput
    tariff: TariffCreateNestedOneWithoutBookingsInput
  }

  export type BookingUncheckedCreateWithoutTripLogInput = {
    id?: string
    riderId: string
    companyId: string
    driverId?: string | null
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateOrConnectWithoutTripLogInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutTripLogInput, BookingUncheckedCreateWithoutTripLogInput>
  }

  export type TripLogCreateWithoutChildrenInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTripLogsInput
    vehicle?: VehicleCreateNestedOneWithoutTripLogsInput
    driver?: DriverCreateNestedOneWithoutTripLogsInput
    user?: UserCreateNestedOneWithoutTripLogsInput
    booking?: BookingCreateNestedOneWithoutTripLogInput
    parent?: TripLogCreateNestedOneWithoutChildrenInput
    apiRequests?: GovernmentApiRequestCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUncheckedCreateWithoutChildrenInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    apiRequests?: GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput
  }

  export type TripLogCreateOrConnectWithoutChildrenInput = {
    where: TripLogWhereUniqueInput
    create: XOR<TripLogCreateWithoutChildrenInput, TripLogUncheckedCreateWithoutChildrenInput>
  }

  export type TripLogCreateWithoutParentInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTripLogsInput
    vehicle?: VehicleCreateNestedOneWithoutTripLogsInput
    driver?: DriverCreateNestedOneWithoutTripLogsInput
    user?: UserCreateNestedOneWithoutTripLogsInput
    booking?: BookingCreateNestedOneWithoutTripLogInput
    children?: TripLogCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestCreateNestedManyWithoutTripLogInput
  }

  export type TripLogUncheckedCreateWithoutParentInput = {
    id?: string
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: TripLogUncheckedCreateNestedManyWithoutParentInput
    apiRequests?: GovernmentApiRequestUncheckedCreateNestedManyWithoutTripLogInput
  }

  export type TripLogCreateOrConnectWithoutParentInput = {
    where: TripLogWhereUniqueInput
    create: XOR<TripLogCreateWithoutParentInput, TripLogUncheckedCreateWithoutParentInput>
  }

  export type TripLogCreateManyParentInputEnvelope = {
    data: TripLogCreateManyParentInput | TripLogCreateManyParentInput[]
  }

  export type GovernmentApiRequestCreateWithoutTripLogInput = {
    id?: string
    requestType: $Enums.ApiRequestType
    endpoint: string
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    success?: boolean
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernmentApiRequestUncheckedCreateWithoutTripLogInput = {
    id?: string
    requestType: $Enums.ApiRequestType
    endpoint: string
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    success?: boolean
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernmentApiRequestCreateOrConnectWithoutTripLogInput = {
    where: GovernmentApiRequestWhereUniqueInput
    create: XOR<GovernmentApiRequestCreateWithoutTripLogInput, GovernmentApiRequestUncheckedCreateWithoutTripLogInput>
  }

  export type GovernmentApiRequestCreateManyTripLogInputEnvelope = {
    data: GovernmentApiRequestCreateManyTripLogInput | GovernmentApiRequestCreateManyTripLogInput[]
  }

  export type CompanyUpsertWithoutTripLogsInput = {
    update: XOR<CompanyUpdateWithoutTripLogsInput, CompanyUncheckedUpdateWithoutTripLogsInput>
    create: XOR<CompanyCreateWithoutTripLogsInput, CompanyUncheckedCreateWithoutTripLogsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutTripLogsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutTripLogsInput, CompanyUncheckedUpdateWithoutTripLogsInput>
  }

  export type CompanyUpdateWithoutTripLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutTripLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    subscriptions?: SubscriptionUncheckedUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type VehicleUpsertWithoutTripLogsInput = {
    update: XOR<VehicleUpdateWithoutTripLogsInput, VehicleUncheckedUpdateWithoutTripLogsInput>
    create: XOR<VehicleCreateWithoutTripLogsInput, VehicleUncheckedCreateWithoutTripLogsInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutTripLogsInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutTripLogsInput, VehicleUncheckedUpdateWithoutTripLogsInput>
  }

  export type VehicleUpdateWithoutTripLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVehiclesNestedInput
    drivers?: DriverUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutTripLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type DriverUpsertWithoutTripLogsInput = {
    update: XOR<DriverUpdateWithoutTripLogsInput, DriverUncheckedUpdateWithoutTripLogsInput>
    create: XOR<DriverCreateWithoutTripLogsInput, DriverUncheckedCreateWithoutTripLogsInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutTripLogsInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutTripLogsInput, DriverUncheckedUpdateWithoutTripLogsInput>
  }

  export type DriverUpdateWithoutTripLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverProfileNestedInput
    company?: CompanyUpdateOneRequiredWithoutDriversNestedInput
    vehicle?: VehicleUpdateOneWithoutDriversNestedInput
    bookings?: BookingUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutTripLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type UserUpsertWithoutTripLogsInput = {
    update: XOR<UserUpdateWithoutTripLogsInput, UserUncheckedUpdateWithoutTripLogsInput>
    create: XOR<UserCreateWithoutTripLogsInput, UserUncheckedCreateWithoutTripLogsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTripLogsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTripLogsInput, UserUncheckedUpdateWithoutTripLogsInput>
  }

  export type UserUpdateWithoutTripLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUpdateManyWithoutRiderNestedInput
  }

  export type UserUncheckedUpdateWithoutTripLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    email?: StringFieldUpdateOperationsInput | string
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    password?: NullableStringFieldUpdateOperationsInput | string | null
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    companyUser?: CompanyUserUncheckedUpdateManyWithoutUserNestedInput
    driverProfile?: DriverUncheckedUpdateOneWithoutUserNestedInput
    riderBookings?: BookingUncheckedUpdateManyWithoutRiderNestedInput
  }

  export type BookingUpsertWithoutTripLogInput = {
    update: XOR<BookingUpdateWithoutTripLogInput, BookingUncheckedUpdateWithoutTripLogInput>
    create: XOR<BookingCreateWithoutTripLogInput, BookingUncheckedCreateWithoutTripLogInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutTripLogInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutTripLogInput, BookingUncheckedUpdateWithoutTripLogInput>
  }

  export type BookingUpdateWithoutTripLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rider?: UserUpdateOneRequiredWithoutRiderBookingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutBookingsNestedInput
    driver?: DriverUpdateOneWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    tariff?: TariffUpdateOneRequiredWithoutBookingsNestedInput
  }

  export type BookingUncheckedUpdateWithoutTripLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogUpsertWithoutChildrenInput = {
    update: XOR<TripLogUpdateWithoutChildrenInput, TripLogUncheckedUpdateWithoutChildrenInput>
    create: XOR<TripLogCreateWithoutChildrenInput, TripLogUncheckedCreateWithoutChildrenInput>
    where?: TripLogWhereInput
  }

  export type TripLogUpdateToOneWithWhereWithoutChildrenInput = {
    where?: TripLogWhereInput
    data: XOR<TripLogUpdateWithoutChildrenInput, TripLogUncheckedUpdateWithoutChildrenInput>
  }

  export type TripLogUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTripLogsNestedInput
    vehicle?: VehicleUpdateOneWithoutTripLogsNestedInput
    driver?: DriverUpdateOneWithoutTripLogsNestedInput
    user?: UserUpdateOneWithoutTripLogsNestedInput
    booking?: BookingUpdateOneWithoutTripLogNestedInput
    parent?: TripLogUpdateOneWithoutChildrenNestedInput
    apiRequests?: GovernmentApiRequestUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apiRequests?: GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUpsertWithWhereUniqueWithoutParentInput = {
    where: TripLogWhereUniqueInput
    update: XOR<TripLogUpdateWithoutParentInput, TripLogUncheckedUpdateWithoutParentInput>
    create: XOR<TripLogCreateWithoutParentInput, TripLogUncheckedCreateWithoutParentInput>
  }

  export type TripLogUpdateWithWhereUniqueWithoutParentInput = {
    where: TripLogWhereUniqueInput
    data: XOR<TripLogUpdateWithoutParentInput, TripLogUncheckedUpdateWithoutParentInput>
  }

  export type TripLogUpdateManyWithWhereWithoutParentInput = {
    where: TripLogScalarWhereInput
    data: XOR<TripLogUpdateManyMutationInput, TripLogUncheckedUpdateManyWithoutParentInput>
  }

  export type GovernmentApiRequestUpsertWithWhereUniqueWithoutTripLogInput = {
    where: GovernmentApiRequestWhereUniqueInput
    update: XOR<GovernmentApiRequestUpdateWithoutTripLogInput, GovernmentApiRequestUncheckedUpdateWithoutTripLogInput>
    create: XOR<GovernmentApiRequestCreateWithoutTripLogInput, GovernmentApiRequestUncheckedCreateWithoutTripLogInput>
  }

  export type GovernmentApiRequestUpdateWithWhereUniqueWithoutTripLogInput = {
    where: GovernmentApiRequestWhereUniqueInput
    data: XOR<GovernmentApiRequestUpdateWithoutTripLogInput, GovernmentApiRequestUncheckedUpdateWithoutTripLogInput>
  }

  export type GovernmentApiRequestUpdateManyWithWhereWithoutTripLogInput = {
    where: GovernmentApiRequestScalarWhereInput
    data: XOR<GovernmentApiRequestUpdateManyMutationInput, GovernmentApiRequestUncheckedUpdateManyWithoutTripLogInput>
  }

  export type GovernmentApiRequestScalarWhereInput = {
    AND?: GovernmentApiRequestScalarWhereInput | GovernmentApiRequestScalarWhereInput[]
    OR?: GovernmentApiRequestScalarWhereInput[]
    NOT?: GovernmentApiRequestScalarWhereInput | GovernmentApiRequestScalarWhereInput[]
    id?: StringFilter<"GovernmentApiRequest"> | string
    tripLogId?: StringFilter<"GovernmentApiRequest"> | string
    requestType?: EnumApiRequestTypeFilter<"GovernmentApiRequest"> | $Enums.ApiRequestType
    endpoint?: StringFilter<"GovernmentApiRequest"> | string
    payload?: JsonFilter<"GovernmentApiRequest">
    response?: JsonNullableFilter<"GovernmentApiRequest">
    statusCode?: IntNullableFilter<"GovernmentApiRequest"> | number | null
    success?: BoolFilter<"GovernmentApiRequest"> | boolean
    errorMessage?: StringNullableFilter<"GovernmentApiRequest"> | string | null
    retryCount?: IntFilter<"GovernmentApiRequest"> | number
    createdAt?: DateTimeFilter<"GovernmentApiRequest"> | Date | string
    updatedAt?: DateTimeFilter<"GovernmentApiRequest"> | Date | string
  }

  export type TripLogCreateWithoutApiRequestsInput = {
    id?: string
    logType: $Enums.LogType
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutTripLogsInput
    vehicle?: VehicleCreateNestedOneWithoutTripLogsInput
    driver?: DriverCreateNestedOneWithoutTripLogsInput
    user?: UserCreateNestedOneWithoutTripLogsInput
    booking?: BookingCreateNestedOneWithoutTripLogInput
    parent?: TripLogCreateNestedOneWithoutChildrenInput
    children?: TripLogCreateNestedManyWithoutParentInput
  }

  export type TripLogUncheckedCreateWithoutApiRequestsInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: TripLogUncheckedCreateNestedManyWithoutParentInput
  }

  export type TripLogCreateOrConnectWithoutApiRequestsInput = {
    where: TripLogWhereUniqueInput
    create: XOR<TripLogCreateWithoutApiRequestsInput, TripLogUncheckedCreateWithoutApiRequestsInput>
  }

  export type TripLogUpsertWithoutApiRequestsInput = {
    update: XOR<TripLogUpdateWithoutApiRequestsInput, TripLogUncheckedUpdateWithoutApiRequestsInput>
    create: XOR<TripLogCreateWithoutApiRequestsInput, TripLogUncheckedCreateWithoutApiRequestsInput>
    where?: TripLogWhereInput
  }

  export type TripLogUpdateToOneWithWhereWithoutApiRequestsInput = {
    where?: TripLogWhereInput
    data: XOR<TripLogUpdateWithoutApiRequestsInput, TripLogUncheckedUpdateWithoutApiRequestsInput>
  }

  export type TripLogUpdateWithoutApiRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTripLogsNestedInput
    vehicle?: VehicleUpdateOneWithoutTripLogsNestedInput
    driver?: DriverUpdateOneWithoutTripLogsNestedInput
    user?: UserUpdateOneWithoutTripLogsNestedInput
    booking?: BookingUpdateOneWithoutTripLogNestedInput
    parent?: TripLogUpdateOneWithoutChildrenNestedInput
    children?: TripLogUpdateManyWithoutParentNestedInput
  }

  export type TripLogUncheckedUpdateWithoutApiRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: TripLogUncheckedUpdateManyWithoutParentNestedInput
  }

  export type DriverCreateWithoutLocationUpdatesInput = {
    id?: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutDriverProfileInput
    company: CompanyCreateNestedOneWithoutDriversInput
    vehicle?: VehicleCreateNestedOneWithoutDriversInput
    bookings?: BookingCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogCreateNestedManyWithoutDriverInput
  }

  export type DriverUncheckedCreateWithoutLocationUpdatesInput = {
    id?: string
    userId: string
    companyId: string
    vehicleId?: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookings?: BookingUncheckedCreateNestedManyWithoutDriverInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutDriverInput
  }

  export type DriverCreateOrConnectWithoutLocationUpdatesInput = {
    where: DriverWhereUniqueInput
    create: XOR<DriverCreateWithoutLocationUpdatesInput, DriverUncheckedCreateWithoutLocationUpdatesInput>
  }

  export type VehicleCreateWithoutLocationUpdatesInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutVehiclesInput
    drivers?: DriverCreateNestedManyWithoutVehicleInput
    tariffs?: TariffCreateNestedManyWithoutVehicleInput
    bookings?: BookingCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogCreateNestedManyWithoutVehicleInput
  }

  export type VehicleUncheckedCreateWithoutLocationUpdatesInput = {
    id?: string
    companyId: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    drivers?: DriverUncheckedCreateNestedManyWithoutVehicleInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVehicleInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type VehicleCreateOrConnectWithoutLocationUpdatesInput = {
    where: VehicleWhereUniqueInput
    create: XOR<VehicleCreateWithoutLocationUpdatesInput, VehicleUncheckedCreateWithoutLocationUpdatesInput>
  }

  export type DriverUpsertWithoutLocationUpdatesInput = {
    update: XOR<DriverUpdateWithoutLocationUpdatesInput, DriverUncheckedUpdateWithoutLocationUpdatesInput>
    create: XOR<DriverCreateWithoutLocationUpdatesInput, DriverUncheckedCreateWithoutLocationUpdatesInput>
    where?: DriverWhereInput
  }

  export type DriverUpdateToOneWithWhereWithoutLocationUpdatesInput = {
    where?: DriverWhereInput
    data: XOR<DriverUpdateWithoutLocationUpdatesInput, DriverUncheckedUpdateWithoutLocationUpdatesInput>
  }

  export type DriverUpdateWithoutLocationUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverProfileNestedInput
    company?: CompanyUpdateOneRequiredWithoutDriversNestedInput
    vehicle?: VehicleUpdateOneWithoutDriversNestedInput
    bookings?: BookingUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutLocationUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type VehicleUpsertWithoutLocationUpdatesInput = {
    update: XOR<VehicleUpdateWithoutLocationUpdatesInput, VehicleUncheckedUpdateWithoutLocationUpdatesInput>
    create: XOR<VehicleCreateWithoutLocationUpdatesInput, VehicleUncheckedCreateWithoutLocationUpdatesInput>
    where?: VehicleWhereInput
  }

  export type VehicleUpdateToOneWithWhereWithoutLocationUpdatesInput = {
    where?: VehicleWhereInput
    data: XOR<VehicleUpdateWithoutLocationUpdatesInput, VehicleUncheckedUpdateWithoutLocationUpdatesInput>
  }

  export type VehicleUpdateWithoutLocationUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutVehiclesNestedInput
    drivers?: DriverUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutLocationUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type CompanyCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleCreateNestedManyWithoutCompanyInput
    drivers?: DriverCreateNestedManyWithoutCompanyInput
    tariffs?: TariffCreateNestedManyWithoutCompanyInput
    users?: CompanyUserCreateNestedManyWithoutCompanyInput
    bookings?: BookingCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogCreateNestedManyWithoutCompanyInput
  }

  export type CompanyUncheckedCreateWithoutSubscriptionsInput = {
    id?: string
    name: string
    address: string
    taxNumber: string
    taxiLicenseNumber: string
    contactPersonName: string
    contactPersonEmail: string
    contactPersonPhone: string
    email: string
    phone: string
    bankAccount?: string | null
    subscriptionType?: $Enums.SubscriptionType
    logo?: string | null
    status?: $Enums.CompanyStatus
    chironClientId?: string | null
    chironClientSecret?: string | null
    chironJwtTokenId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicles?: VehicleUncheckedCreateNestedManyWithoutCompanyInput
    drivers?: DriverUncheckedCreateNestedManyWithoutCompanyInput
    tariffs?: TariffUncheckedCreateNestedManyWithoutCompanyInput
    users?: CompanyUserUncheckedCreateNestedManyWithoutCompanyInput
    bookings?: BookingUncheckedCreateNestedManyWithoutCompanyInput
    tripLogs?: TripLogUncheckedCreateNestedManyWithoutCompanyInput
  }

  export type CompanyCreateOrConnectWithoutSubscriptionsInput = {
    where: CompanyWhereUniqueInput
    create: XOR<CompanyCreateWithoutSubscriptionsInput, CompanyUncheckedCreateWithoutSubscriptionsInput>
  }

  export type PaymentCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    provider: string
    externalId?: string | null
    paymentMethod?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutSubscriptionInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    provider: string
    externalId?: string | null
    paymentMethod?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentCreateManySubscriptionInputEnvelope = {
    data: PaymentCreateManySubscriptionInput | PaymentCreateManySubscriptionInput[]
  }

  export type CompanyUpsertWithoutSubscriptionsInput = {
    update: XOR<CompanyUpdateWithoutSubscriptionsInput, CompanyUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<CompanyCreateWithoutSubscriptionsInput, CompanyUncheckedCreateWithoutSubscriptionsInput>
    where?: CompanyWhereInput
  }

  export type CompanyUpdateToOneWithWhereWithoutSubscriptionsInput = {
    where?: CompanyWhereInput
    data: XOR<CompanyUpdateWithoutSubscriptionsInput, CompanyUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type CompanyUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUpdateManyWithoutCompanyNestedInput
  }

  export type CompanyUncheckedUpdateWithoutSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    taxNumber?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    contactPersonName?: StringFieldUpdateOperationsInput | string
    contactPersonEmail?: StringFieldUpdateOperationsInput | string
    contactPersonPhone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    bankAccount?: NullableStringFieldUpdateOperationsInput | string | null
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumCompanyStatusFieldUpdateOperationsInput | $Enums.CompanyStatus
    chironClientId?: NullableStringFieldUpdateOperationsInput | string | null
    chironClientSecret?: NullableStringFieldUpdateOperationsInput | string | null
    chironJwtTokenId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicles?: VehicleUncheckedUpdateManyWithoutCompanyNestedInput
    drivers?: DriverUncheckedUpdateManyWithoutCompanyNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutCompanyNestedInput
    users?: CompanyUserUncheckedUpdateManyWithoutCompanyNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutCompanyNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutCompanyNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
    create: XOR<PaymentCreateWithoutSubscriptionInput, PaymentUncheckedCreateWithoutSubscriptionInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutSubscriptionInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutSubscriptionInput, PaymentUncheckedUpdateWithoutSubscriptionInput>
  }

  export type PaymentUpdateManyWithWhereWithoutSubscriptionInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutSubscriptionInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    subscriptionId?: StringFilter<"Payment"> | string
    amount?: FloatFilter<"Payment"> | number
    currency?: StringFilter<"Payment"> | string
    status?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    provider?: StringFilter<"Payment"> | string
    externalId?: StringNullableFilter<"Payment"> | string | null
    paymentMethod?: StringNullableFilter<"Payment"> | string | null
    periodStart?: DateTimeFilter<"Payment"> | Date | string
    periodEnd?: DateTimeFilter<"Payment"> | Date | string
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type SubscriptionCreateWithoutPaymentsInput = {
    id?: string
    subscriptionType: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate?: Date | string | null
    pricePerMonth: number
    paymentProvider?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    company: CompanyCreateNestedOneWithoutSubscriptionsInput
  }

  export type SubscriptionUncheckedCreateWithoutPaymentsInput = {
    id?: string
    companyId: string
    subscriptionType: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate?: Date | string | null
    pricePerMonth: number
    paymentProvider?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SubscriptionCreateOrConnectWithoutPaymentsInput = {
    where: SubscriptionWhereUniqueInput
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
  }

  export type SubscriptionUpsertWithoutPaymentsInput = {
    update: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
    create: XOR<SubscriptionCreateWithoutPaymentsInput, SubscriptionUncheckedCreateWithoutPaymentsInput>
    where?: SubscriptionWhereInput
  }

  export type SubscriptionUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: SubscriptionWhereInput
    data: XOR<SubscriptionUpdateWithoutPaymentsInput, SubscriptionUncheckedUpdateWithoutPaymentsInput>
  }

  export type SubscriptionUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutSubscriptionsNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type CompanyUserCreateManyUserInput = {
    id?: string
    companyId: string
    role?: string
    createdAt?: Date | string
  }

  export type BookingCreateManyRiderInput = {
    id?: string
    companyId: string
    driverId?: string | null
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripLogCreateManyUserInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutUsersNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutRiderInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutBookingsNestedInput
    driver?: DriverUpdateOneWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    tariff?: TariffUpdateOneRequiredWithoutBookingsNestedInput
    tripLog?: TripLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutRiderInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripLog?: TripLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutRiderInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTripLogsNestedInput
    vehicle?: VehicleUpdateOneWithoutTripLogsNestedInput
    driver?: DriverUpdateOneWithoutTripLogsNestedInput
    booking?: BookingUpdateOneWithoutTripLogNestedInput
    parent?: TripLogUpdateOneWithoutChildrenNestedInput
    children?: TripLogUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: TripLogUncheckedUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VehicleCreateManyCompanyInput = {
    id?: string
    licensePlate: string
    brand: string
    model: string
    year: number
    color: string
    taxiLicenseNumber: string
    insuranceExpiry: Date | string
    keuringExpiry: Date | string
    pictures: string
    status?: $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: string | null
    taxiLightWebhookOffUrl?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DriverCreateManyCompanyInput = {
    id?: string
    userId: string
    vehicleId?: string | null
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffCreateManyCompanyInput = {
    id?: string
    vehicleId?: string | null
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CompanyUserCreateManyCompanyInput = {
    id?: string
    userId: string
    role?: string
    createdAt?: Date | string
  }

  export type SubscriptionCreateManyCompanyInput = {
    id?: string
    subscriptionType: $Enums.SubscriptionType
    status?: $Enums.SubscriptionStatus
    startDate: Date | string
    endDate?: Date | string | null
    pricePerMonth: number
    paymentProvider?: string | null
    externalId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyCompanyInput = {
    id?: string
    riderId: string
    driverId?: string | null
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripLogCreateManyCompanyInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VehicleUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    drivers?: DriverUncheckedUpdateManyWithoutVehicleNestedInput
    tariffs?: TariffUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVehicleNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutVehicleNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type VehicleUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    licensePlate?: StringFieldUpdateOperationsInput | string
    brand?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    taxiLicenseNumber?: StringFieldUpdateOperationsInput | string
    insuranceExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    keuringExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    pictures?: StringFieldUpdateOperationsInput | string
    status?: EnumVehicleStatusFieldUpdateOperationsInput | $Enums.VehicleStatus
    taxiLightWebhookOnUrl?: NullableStringFieldUpdateOperationsInput | string | null
    taxiLightWebhookOffUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverProfileNestedInput
    vehicle?: VehicleUpdateOneWithoutDriversNestedInput
    bookings?: BookingUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneWithoutTariffsNestedInput
    bookings?: BookingUpdateManyWithoutTariffNestedInput
  }

  export type TariffUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutTariffNestedInput
  }

  export type TariffUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCompanyUserNestedInput
  }

  export type CompanyUserUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CompanyUserUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SubscriptionUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutSubscriptionNestedInput
  }

  export type SubscriptionUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    subscriptionType?: EnumSubscriptionTypeFieldUpdateOperationsInput | $Enums.SubscriptionType
    status?: EnumSubscriptionStatusFieldUpdateOperationsInput | $Enums.SubscriptionStatus
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    pricePerMonth?: FloatFieldUpdateOperationsInput | number
    paymentProvider?: NullableStringFieldUpdateOperationsInput | string | null
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rider?: UserUpdateOneRequiredWithoutRiderBookingsNestedInput
    driver?: DriverUpdateOneWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    tariff?: TariffUpdateOneRequiredWithoutBookingsNestedInput
    tripLog?: TripLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripLog?: TripLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneWithoutTripLogsNestedInput
    driver?: DriverUpdateOneWithoutTripLogsNestedInput
    user?: UserUpdateOneWithoutTripLogsNestedInput
    booking?: BookingUpdateOneWithoutTripLogNestedInput
    parent?: TripLogUpdateOneWithoutChildrenNestedInput
    children?: TripLogUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: TripLogUncheckedUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateManyWithoutCompanyInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DriverCreateManyVehicleInput = {
    id?: string
    userId: string
    companyId: string
    firstName: string
    lastName: string
    taxiDriverLicense: string
    licenseExpiry: Date | string
    address: string
    phone: string
    email: string
    picture?: string | null
    status?: $Enums.DriverStatus
    isOnline?: boolean
    currentLatitude?: number | null
    currentLongitude?: number | null
    lastLocationUpdate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TariffCreateManyVehicleInput = {
    id?: string
    companyId: string
    name: string
    code: string
    type?: $Enums.TariffType
    startPrice: number
    pricePerKm: number
    pricePerMinute: number
    nightSurcharge?: number
    weekendSurcharge?: number
    isActive?: boolean
    nightStartTime?: string | null
    nightEndTime?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyVehicleInput = {
    id?: string
    riderId: string
    companyId: string
    driverId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripLogCreateManyVehicleInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateCreateManyVehicleInput = {
    id?: string
    driverId: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
  }

  export type DriverUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDriverProfileNestedInput
    company?: CompanyUpdateOneRequiredWithoutDriversNestedInput
    bookings?: BookingUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutDriverNestedInput
    tripLogs?: TripLogUncheckedUpdateManyWithoutDriverNestedInput
    locationUpdates?: LocationUpdateUncheckedUpdateManyWithoutDriverNestedInput
  }

  export type DriverUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    taxiDriverLicense?: StringFieldUpdateOperationsInput | string
    licenseExpiry?: DateTimeFieldUpdateOperationsInput | Date | string
    address?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumDriverStatusFieldUpdateOperationsInput | $Enums.DriverStatus
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    currentLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    currentLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    lastLocationUpdate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TariffUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTariffsNestedInput
    bookings?: BookingUpdateManyWithoutTariffNestedInput
  }

  export type TariffUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookings?: BookingUncheckedUpdateManyWithoutTariffNestedInput
  }

  export type TariffUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    type?: EnumTariffTypeFieldUpdateOperationsInput | $Enums.TariffType
    startPrice?: FloatFieldUpdateOperationsInput | number
    pricePerKm?: FloatFieldUpdateOperationsInput | number
    pricePerMinute?: FloatFieldUpdateOperationsInput | number
    nightSurcharge?: FloatFieldUpdateOperationsInput | number
    weekendSurcharge?: FloatFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    nightStartTime?: NullableStringFieldUpdateOperationsInput | string | null
    nightEndTime?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rider?: UserUpdateOneRequiredWithoutRiderBookingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutBookingsNestedInput
    driver?: DriverUpdateOneWithoutBookingsNestedInput
    tariff?: TariffUpdateOneRequiredWithoutBookingsNestedInput
    tripLog?: TripLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripLog?: TripLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTripLogsNestedInput
    driver?: DriverUpdateOneWithoutTripLogsNestedInput
    user?: UserUpdateOneWithoutTripLogsNestedInput
    booking?: BookingUpdateOneWithoutTripLogNestedInput
    parent?: TripLogUpdateOneWithoutChildrenNestedInput
    children?: TripLogUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: TripLogUncheckedUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    driver?: DriverUpdateOneRequiredWithoutLocationUpdatesNestedInput
  }

  export type LocationUpdateUncheckedUpdateWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateUncheckedUpdateManyWithoutVehicleInput = {
    id?: StringFieldUpdateOperationsInput | string
    driverId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyDriverInput = {
    id?: string
    riderId: string
    companyId: string
    vehicleId?: string | null
    tariffId: string
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripLogCreateManyDriverInput = {
    id?: string
    parentId?: string | null
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LocationUpdateCreateManyDriverInput = {
    id?: string
    vehicleId: string
    latitude: number
    longitude: number
    accuracy?: number | null
    speed?: number | null
    heading?: number | null
    altitude?: number | null
    createdAt?: Date | string
  }

  export type BookingUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rider?: UserUpdateOneRequiredWithoutRiderBookingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    tariff?: TariffUpdateOneRequiredWithoutBookingsNestedInput
    tripLog?: TripLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripLog?: TripLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    tariffId?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTripLogsNestedInput
    vehicle?: VehicleUpdateOneWithoutTripLogsNestedInput
    user?: UserUpdateOneWithoutTripLogsNestedInput
    booking?: BookingUpdateOneWithoutTripLogNestedInput
    parent?: TripLogUpdateOneWithoutChildrenNestedInput
    children?: TripLogUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: TripLogUncheckedUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: VehicleUpdateOneRequiredWithoutLocationUpdatesNestedInput
  }

  export type LocationUpdateUncheckedUpdateWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LocationUpdateUncheckedUpdateManyWithoutDriverInput = {
    id?: StringFieldUpdateOperationsInput | string
    vehicleId?: StringFieldUpdateOperationsInput | string
    latitude?: FloatFieldUpdateOperationsInput | number
    longitude?: FloatFieldUpdateOperationsInput | number
    accuracy?: NullableFloatFieldUpdateOperationsInput | number | null
    speed?: NullableFloatFieldUpdateOperationsInput | number | null
    heading?: NullableFloatFieldUpdateOperationsInput | number | null
    altitude?: NullableFloatFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateManyTariffInput = {
    id?: string
    riderId: string
    companyId: string
    driverId?: string | null
    vehicleId?: string | null
    pickupLatitude: number
    pickupLongitude: number
    pickupAddress: string
    destinationLatitude?: number | null
    destinationLongitude?: number | null
    destinationAddress?: string | null
    estimatedPrice?: number | null
    finalPrice?: number | null
    estimatedDuration?: number | null
    actualDuration?: number | null
    distance?: number | null
    riderName: string
    riderPhone: string
    notes?: string | null
    scheduledTime?: Date | string | null
    acceptedAt?: Date | string | null
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    cancelledAt?: Date | string | null
    status?: $Enums.BookingStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateWithoutTariffInput = {
    id?: StringFieldUpdateOperationsInput | string
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    rider?: UserUpdateOneRequiredWithoutRiderBookingsNestedInput
    company?: CompanyUpdateOneRequiredWithoutBookingsNestedInput
    driver?: DriverUpdateOneWithoutBookingsNestedInput
    vehicle?: VehicleUpdateOneWithoutBookingsNestedInput
    tripLog?: TripLogUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutTariffInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tripLog?: TripLogUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutTariffInput = {
    id?: StringFieldUpdateOperationsInput | string
    riderId?: StringFieldUpdateOperationsInput | string
    companyId?: StringFieldUpdateOperationsInput | string
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    pickupLatitude?: FloatFieldUpdateOperationsInput | number
    pickupLongitude?: FloatFieldUpdateOperationsInput | number
    pickupAddress?: StringFieldUpdateOperationsInput | string
    destinationLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    destinationAddress?: NullableStringFieldUpdateOperationsInput | string | null
    estimatedPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    estimatedDuration?: NullableIntFieldUpdateOperationsInput | number | null
    actualDuration?: NullableIntFieldUpdateOperationsInput | number | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    riderName?: StringFieldUpdateOperationsInput | string
    riderPhone?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    scheduledTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    acceptedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TripLogCreateManyParentInput = {
    id?: string
    logType: $Enums.LogType
    companyId: string
    vehicleId?: string | null
    driverId?: string | null
    userId?: string | null
    bookingId?: string | null
    startLatitude?: number | null
    startLongitude?: number | null
    startAddress?: string | null
    endLatitude?: number | null
    endLongitude?: number | null
    endAddress?: string | null
    distance?: number | null
    duration?: number | null
    finalPrice?: number | null
    tariffUsed?: string | null
    governmentTripId?: string | null
    tripStartApiSent?: boolean
    tripEndApiSent?: boolean
    apiErrorLog?: string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: Date | string | null
    tripEndTime?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type GovernmentApiRequestCreateManyTripLogInput = {
    id?: string
    requestType: $Enums.ApiRequestType
    endpoint: string
    payload: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: number | null
    success?: boolean
    errorMessage?: string | null
    retryCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TripLogUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    company?: CompanyUpdateOneRequiredWithoutTripLogsNestedInput
    vehicle?: VehicleUpdateOneWithoutTripLogsNestedInput
    driver?: DriverUpdateOneWithoutTripLogsNestedInput
    user?: UserUpdateOneWithoutTripLogsNestedInput
    booking?: BookingUpdateOneWithoutTripLogNestedInput
    children?: TripLogUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: TripLogUncheckedUpdateManyWithoutParentNestedInput
    apiRequests?: GovernmentApiRequestUncheckedUpdateManyWithoutTripLogNestedInput
  }

  export type TripLogUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    logType?: EnumLogTypeFieldUpdateOperationsInput | $Enums.LogType
    companyId?: StringFieldUpdateOperationsInput | string
    vehicleId?: NullableStringFieldUpdateOperationsInput | string | null
    driverId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    bookingId?: NullableStringFieldUpdateOperationsInput | string | null
    startLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    startAddress?: NullableStringFieldUpdateOperationsInput | string | null
    endLatitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endLongitude?: NullableFloatFieldUpdateOperationsInput | number | null
    endAddress?: NullableStringFieldUpdateOperationsInput | string | null
    distance?: NullableFloatFieldUpdateOperationsInput | number | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    finalPrice?: NullableFloatFieldUpdateOperationsInput | number | null
    tariffUsed?: NullableStringFieldUpdateOperationsInput | string | null
    governmentTripId?: NullableStringFieldUpdateOperationsInput | string | null
    tripStartApiSent?: BoolFieldUpdateOperationsInput | boolean
    tripEndApiSent?: BoolFieldUpdateOperationsInput | boolean
    apiErrorLog?: NullableStringFieldUpdateOperationsInput | string | null
    logDetails?: NullableJsonNullValueInput | InputJsonValue
    tripStartTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    tripEndTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernmentApiRequestUpdateWithoutTripLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumApiRequestTypeFieldUpdateOperationsInput | $Enums.ApiRequestType
    endpoint?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernmentApiRequestUncheckedUpdateWithoutTripLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumApiRequestTypeFieldUpdateOperationsInput | $Enums.ApiRequestType
    endpoint?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GovernmentApiRequestUncheckedUpdateManyWithoutTripLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: EnumApiRequestTypeFieldUpdateOperationsInput | $Enums.ApiRequestType
    endpoint?: StringFieldUpdateOperationsInput | string
    payload?: JsonNullValueInput | InputJsonValue
    response?: NullableJsonNullValueInput | InputJsonValue
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    success?: BoolFieldUpdateOperationsInput | boolean
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManySubscriptionInput = {
    id?: string
    amount: number
    currency?: string
    status?: $Enums.PaymentStatus
    provider: string
    externalId?: string | null
    paymentMethod?: string | null
    periodStart: Date | string
    periodEnd: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutSubscriptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    currency?: StringFieldUpdateOperationsInput | string
    status?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    provider?: StringFieldUpdateOperationsInput | string
    externalId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethod?: NullableStringFieldUpdateOperationsInput | string | null
    periodStart?: DateTimeFieldUpdateOperationsInput | Date | string
    periodEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}